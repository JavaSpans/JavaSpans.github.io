<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>html 学习目录(连载中)</title>
    <url>/posts/c258b0a1.html</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr>
<h4 id="前端电脑笔记将会分为以下几个阶段"><a href="#前端电脑笔记将会分为以下几个阶段" class="headerlink" title="前端电脑笔记将会分为以下几个阶段"></a>前端电脑笔记将会分为以下几个阶段</h4><h1 id="（目录）"><a href="#（目录）" class="headerlink" title="（目录）"></a><strong>（目录）</strong></h1><h2 id="一、html入门"><a href="#一、html入门" class="headerlink" title="一、html入门"></a>一、html入门</h2><ul>
<li><h5 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h5><ol>
<li><h5 id="html简介"><a href="#html简介" class="headerlink" title="html简介"></a><a href="https://baike.baidu.com/item/HTML/97049?fr=aladdin">html简介</a></h5></li>
<li><h5 id="html初步认识"><a href="#html初步认识" class="headerlink" title="html初步认识"></a><a href="https://benat.cn/posts/d7e9d6a9.html">html初步认识</a></h5></li>
<li><h5 id="html标签基础"><a href="#html标签基础" class="headerlink" title="html标签基础"></a><a href="https://benat.cn/posts/1a147173.html">html标签基础</a></h5></li>
<li><h5 id="html和css"><a href="#html和css" class="headerlink" title="html和css"></a><a href="https://benat.cn/posts/4642a5d8.html">html和css</a></h5></li>
<li><h5 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a><a href="https://benat.cn/posts/a9ba4134.html">JavaScript基础</a></h5></li>
<li><h5 id="JavaScript高级基础"><a href="#JavaScript高级基础" class="headerlink" title="JavaScript高级基础"></a><a href="https://benat.cn/posts/831f8dce.html">JavaScript高级基础</a></h5></li>
<li><h5 id="Bootstrap框架基础"><a href="#Bootstrap框架基础" class="headerlink" title="Bootstrap框架基础"></a><a href="https://benat.cn/posts/c369155.html">Bootstrap框架基础</a></h5></li>
<li><h5 id="xml基础笔记"><a href="#xml基础笔记" class="headerlink" title="xml基础笔记"></a><a href="https://benat.cn/posts/3b93ba3b.html">xml基础笔记</a></h5></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学校笔记(连载中)</title>
    <url>/posts/df344879.html</url>
    <content><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ol>
<li><h5 id="数据类型结构"><a href="#数据类型结构" class="headerlink" title="数据类型结构"></a><a href="https://benat.cn/posts/37015d6b.html">数据类型结构</a></h5></li>
<li><h5 id="三元运算符和switch"><a href="#三元运算符和switch" class="headerlink" title="三元运算符和switch"></a><a href="https://benat.cn/posts/ef68d2a6.html">三元运算符和switch</a></h5></li>
<li><h5 id="Static关键字和代码块"><a href="#Static关键字和代码块" class="headerlink" title="Static关键字和代码块"></a><a href="https://benat.cn/posts/8c6f2d57.html">Static关键字和代码块</a></h5></li>
<li><h5 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a><a href="https://benat.cn/posts/ec8d8377.html">Final关键字</a></h5></li>
<li><h5 id="构造方法和getset"><a href="#构造方法和getset" class="headerlink" title="构造方法和getset"></a><a href="https://benat.cn/posts/e2abe5ec.html">构造方法和getset</a></h5></li>
<li><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><a href="https://benat.cn/posts/d7363e83.html">抽象类</a></h5></li>
<li><h5 id="循环结构三大循环"><a href="#循环结构三大循环" class="headerlink" title="循环结构三大循环"></a><a href="https://benat.cn/posts/5f91e7e3.html">循环结构三大循环</a></h5></li>
<li><h5 id="方-法"><a href="#方-法" class="headerlink" title="方 法"></a><a href="https://benat.cn/posts/69244af4.html">方 法</a></h5></li>
<li><h5 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a><a href="https://benat.cn/posts/70ec998a.html">方法的重载</a></h5></li>
<li><h5 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a><a href="https://benat.cn/posts/4a246c51.html">命令行传参</a></h5></li>
<li><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><a href="https://benat.cn/posts/6963fb18.html">可变参数</a></h5></li>
<li><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a><a href="https://benat.cn/posts/a0b50c75.html">递归</a></h5></li>
<li><h5 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a><a href="https://benat.cn/posts/340249a9.html">数组的定义</a></h5></li>
<li><h5 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a><a href="https://benat.cn/posts/5d966776.html">Java内存分析</a></h5></li>
<li><h5 id="Arrays集合"><a href="#Arrays集合" class="headerlink" title="Arrays集合"></a><a href="https://benat.cn/posts/c3c27062.html">Arrays集合</a></h5></li>
<li><h5 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a><a href="https://benat.cn/posts/28239a8d.html">面对对象</a></h5></li>
<li><h5 id="面对对象的三大特性"><a href="#面对对象的三大特性" class="headerlink" title="面对对象的三大特性"></a><a href="https://benat.cn/posts/bf990afe.html">面对对象的三大特性</a></h5></li>
<li><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a><a href="https://benat.cn/posts/a6c6c4c.html">static关键字</a></h5></li>
<li><h5 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a><a href="https://benat.cn/posts/bcf3512a.html">抽象类</a></h5></li>
<li><h5 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a><a href="https://benat.cn/posts/224e502b.html">接口的定义和实现</a></h5></li>
<li><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><a href="https://benat.cn/posts/9bc01b38.html">内部类</a></h5></li>
<li><h5 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a><a href="https://benat.cn/posts/7792860f.html">异常机制</a></h5></li>
<li><h5 id="自定义异常机制"><a href="#自定义异常机制" class="headerlink" title="自定义异常机制"></a><a href="https://benat.cn/posts/5f2e64d3.html">自定义异常机制</a></h5></li>
<li><h5 id="常用API和类"><a href="#常用API和类" class="headerlink" title="常用API和类"></a><a href="https://benat.cn/posts/d84486e7.html">常用API和类</a></h5></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学校笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 学习目录(连载中)</title>
    <url>/posts/7bdea972.html</url>
    <content><![CDATA[<h1 id="今天开始正式写Java笔记"><a href="#今天开始正式写Java笔记" class="headerlink" title="今天开始正式写Java笔记"></a>今天开始正式写Java笔记</h1><blockquote>
<h2 id="为什么要写Java笔记？"><a href="#为什么要写Java笔记？" class="headerlink" title="为什么要写Java笔记？"></a>为什么要写Java笔记？</h2></blockquote>
<blockquote>
<p>作为一个学习技术和分享笔记的小博客</p>
<p>本着学习和分享Java菜鸟笔记开始有目录了。<del>在这里我要立个Flag，从入门到入坟一定要坚持写完</del>。顺便巩固一下自己的基础（就是因为鄙人太菜了，哎~），生存不易,还需努力！！！</p>
</blockquote>
<h3 id="最主要的是我觉的基础真的真的真的是超级重要，只有你基础牢，才可以把后面的框架学好，理解清楚！！！"><a href="#最主要的是我觉的基础真的真的真的是超级重要，只有你基础牢，才可以把后面的框架学好，理解清楚！！！" class="headerlink" title="最主要的是我觉的基础真的真的真的是超级重要，只有你基础牢，才可以把后面的框架学好，理解清楚！！！"></a>最主要的是我觉的基础真的真的真的是超级重要，只有你基础牢，才可以把后面的框架学好，理解清楚！！！</h3><hr>
<h4 id="JAVA笔记将会分为以下几个阶段"><a href="#JAVA笔记将会分为以下几个阶段" class="headerlink" title="JAVA笔记将会分为以下几个阶段"></a>JAVA笔记将会分为以下几个阶段</h4><h1 id="（目录）"><a href="#（目录）" class="headerlink" title="（目录）"></a><strong>（目录）</strong></h1><h1 id="一、JAVA入门"><a href="#一、JAVA入门" class="headerlink" title="一、JAVA入门"></a>一、JAVA入门</h1><ul>
<li><h4 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h4><ol>
<li><h5 id="JAVA简介"><a href="#JAVA简介" class="headerlink" title="JAVA简介"></a><a href="https://baike.baidu.com/item/java/85979?fromtitle=Java%E8%AF%AD%E8%A8%80&fromid=4148931#1">JAVA简介</a></h5></li>
<li><h5 id="关键字以及数据类型"><a href="#关键字以及数据类型" class="headerlink" title="关键字以及数据类型"></a><a href="https://benat.cn/posts/1f3c832.html">关键字以及数据类型</a></h5></li>
<li><h5 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a><a href="https://benat.cn/posts/94320cfe.html">变量是什么</a></h5></li>
<li><h5 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a><a href="https://benat.cn/posts/6280299f.html">类型的转换</a></h5></li>
<li><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="https://benat.cn/posts/f29265a7.html">运算符</a></h5></li>
<li><h5 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a><a href="https://benat.cn/posts/e2abe5ec.html">Scanner对象</a></h5></li>
<li><h5 id="顺序结构和IF选择结构"><a href="#顺序结构和IF选择结构" class="headerlink" title="顺序结构和IF选择结构"></a><a href="https://benat.cn/posts/d7363e83.html">顺序结构和IF选择结构</a></h5></li>
<li><h5 id="循环结构三大循环"><a href="#循环结构三大循环" class="headerlink" title="循环结构三大循环"></a><a href="https://benat.cn/posts/5f91e7e3.html">循环结构三大循环</a></h5></li>
<li><h5 id="方-法"><a href="#方-法" class="headerlink" title="方 法"></a><a href="https://benat.cn/posts/69244af4.html">方 法</a></h5></li>
<li><h5 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a><a href="https://benat.cn/posts/70ec998a.html">方法的重载</a></h5></li>
<li><h5 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a><a href="https://benat.cn/posts/4a246c51.html">命令行传参</a></h5></li>
<li><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><a href="https://benat.cn/posts/6963fb18.html">可变参数</a></h5></li>
<li><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a><a href="https://benat.cn/posts/a0b50c75.html">递归</a></h5></li>
<li><h5 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a><a href="https://benat.cn/posts/340249a9.html">数组的定义</a></h5></li>
<li><h5 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a><a href="https://benat.cn/posts/5d966776.html">Java内存分析</a></h5></li>
<li><h5 id="Arrays集合"><a href="#Arrays集合" class="headerlink" title="Arrays集合"></a><a href="https://benat.cn/posts/c3c27062.html">Arrays集合</a></h5></li>
<li><h5 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a><a href="https://benat.cn/posts/28239a8d.html">面对对象</a></h5></li>
<li><h5 id="面对对象的三大特性"><a href="#面对对象的三大特性" class="headerlink" title="面对对象的三大特性"></a><a href="https://benat.cn/posts/bf990afe.html">面对对象的三大特性</a></h5></li>
<li><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a><a href="https://benat.cn/posts/a6c6c4c.html">static关键字</a></h5></li>
<li><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><a href="https://benat.cn/posts/bcf3512a.html">抽象类</a></h5></li>
<li><h5 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a><a href="https://benat.cn/posts/224e502b.html">接口的定义和实现</a></h5></li>
<li><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><a href="https://benat.cn/posts/9bc01b38.html">内部类</a></h5></li>
<li><h5 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a><a href="https://benat.cn/posts/7792860f.html">异常机制</a></h5></li>
<li><h5 id="自定义异常机制"><a href="#自定义异常机制" class="headerlink" title="自定义异常机制"></a><a href="https://benat.cn/posts/5f2e64d3.html">自定义异常机制</a></h5></li>
<li><h5 id="常用API和类"><a href="#常用API和类" class="headerlink" title="常用API和类"></a><a href="https://benat.cn/posts/d84486e7.html">常用API和类</a></h5></li>
<li><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><a href="https://benat.cn/posts/5729df21.html">多线程</a></h5></li>
<li><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a><a href="https://benat.cn/posts/9d32b1d.html">同步</a></h5></li>
<li><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><a href="https://benat.cn/posts/de7c53fe.html">线程池</a></h5></li>
<li><h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><a href="https://benat.cn/posts/bbcf5ff7.html">Lambda表达式</a></h5></li>
<li><h5 id="File类"><a href="#File类" class="headerlink" title="File类"></a><a href="https://benat.cn/posts/70b5696.html">File类</a></h5></li>
<li><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a><a href="https://benat.cn/posts/fe53c3fa.html">递归</a></h5></li>
<li><h5 id="字符流、字节流"><a href="#字符流、字节流" class="headerlink" title="字符流、字节流"></a><a href="https://benat.cn/posts/3966ff99.html">字符流、字节流</a></h5></li>
<li><h5 id="字符缓冲流、字节缓冲流"><a href="#字符缓冲流、字节缓冲流" class="headerlink" title="字符缓冲流、字节缓冲流"></a><a href="https://benat.cn/posts/a3af51be.html">字符缓冲流、字节缓冲流</a></h5></li>
<li><h5 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><a href="https://benat.cn/posts/f6491ffb.html">网络编程</a></h5></li>
<li><h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a><a href="https://benat.cn/posts/69144af4.html">函数式接口</a></h5></li>
<li><h5 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a><a href="https://benat.cn/posts/69413af4.html">Stream流</a></h5></li>
<li><h5 id="Junit、反射、注解"><a href="#Junit、反射、注解" class="headerlink" title="Junit、反射、注解"></a><a href="https://benat.cn/posts/61344af4.html">Junit、反射、注解</a></h5></li>
<li><h5 id="数据库的基本笔记"><a href="#数据库的基本笔记" class="headerlink" title="数据库的基本笔记"></a><a href="https://benat.cn/posts/e5d60199.html">数据库的基本笔记</a></h5></li>
<li><h5 id="MySQL约束笔记"><a href="#MySQL约束笔记" class="headerlink" title="MySQL约束笔记"></a><a href="https://benat.cn/posts/973b63a3.html">MySQL约束笔记</a></h5></li>
<li><h5 id="MySQL多表查询和事务"><a href="#MySQL多表查询和事务" class="headerlink" title="MySQL多表查询和事务"></a><a href="https://benat.cn/posts/983a747a.html">MySQL多表查询和事务</a></h5></li>
<li><h5 id="JDBC基础知识"><a href="#JDBC基础知识" class="headerlink" title="JDBC基础知识"></a><a href="https://benat.cn/posts/6b3156dd.html">JDBC基础知识</a></h5></li>
<li><h5 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a><a href="https://benat.cn/posts/6331d382.html">JDBC连接池</a></h5></li>
<li><h5 id="Tomcat-Servlet笔记"><a href="#Tomcat-Servlet笔记" class="headerlink" title="Tomcat&amp;Servlet笔记"></a><a href="https://benat.cn/posts/2683a04f.html">Tomcat&amp;Servlet笔记</a></h5></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 学习目录(连载中)</title>
    <url>/posts/6e48d4f4.html</url>
    <content><![CDATA[<ol>
<li><h5 id="数据库的基本笔记"><a href="#数据库的基本笔记" class="headerlink" title="数据库的基本笔记"></a><a href="https://benat.cn/posts/e5d60199.html">数据库的基本笔记</a></h5></li>
<li><h5 id="MySQL约束笔记"><a href="#MySQL约束笔记" class="headerlink" title="MySQL约束笔记"></a><a href="https://benat.cn/posts/973b63a3.html">MySQL约束笔记</a></h5></li>
<li><h5 id="MySQL多表查询和事务"><a href="#MySQL多表查询和事务" class="headerlink" title="MySQL多表查询和事务"></a><a href="https://benat.cn/posts/983a747a.html">MySQL多表查询和事务</a></h5></li>
<li><h5 id="JDBC基础知识"><a href="#JDBC基础知识" class="headerlink" title="JDBC基础知识"></a><a href="https://benat.cn/posts/6b3156dd.html">JDBC基础知识</a></h5></li>
<li><h5 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a><a href="https://benat.cn/posts/6331d382.html">JDBC连接池</a></h5></li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>其他学习拓展(连载中)</title>
    <url>/posts/8d422b92.html</url>
    <content><![CDATA[<p><a href="https://benat.cn/posts/3f0598a9.html">Debug的使用性</a></p>
<p><a href="https://benat.cn/posts/81406da.html">反编译 class 文件</a></p>
<p>1.<a href="https://benat.cn/posts/48c8b89.html">Object类、常用API</a></p>
<p>2.<a href="https://benat.cn/posts/8eb50902.html">Object类、常用API2</a></p>
<p>3.<a href="https://benat.cn/posts/a69633d1.html">Collection、泛型</a></p>
<p>4.<a href="https://benat.cn/posts/206428c3.html">List、Set、数据结构、Collections</a></p>
<p>5.<a href="https://benat.cn/posts/abe0ec5b.html">Map</a></p>
<p>6.<a href="https://benat.cn/posts/580b947d.html">异常、线程</a></p>
<p>7.<a href="https://benat.cn/posts/d2b27c03.html">线程池、Lambda表达式</a></p>
<p>8.<a href="https://benat.cn/posts/cdb4f0f7.html">File类、递归</a></p>
<p>9.<a href="https://benat.cn/posts/39666f99.html">字节流、字符流</a></p>
<p>10.<a href="https://benat.cn/posts/9b6019cd.html">缓冲流、转换流、序列化流</a></p>
<p>11.<a href="https://benat.cn/posts/f6491cfb.html">网络编程</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>andirons学校笔记(连载中)</title>
    <url>/posts/da58cdbf.html</url>
    <content><![CDATA[<h3 id="安卓体系"><a href="#安卓体系" class="headerlink" title="安卓体系"></a>安卓体系</h3><h5 id="应用层Applications"><a href="#应用层Applications" class="headerlink" title="应用层Applications"></a>应用层Applications</h5><h5 id="框架层面APPlication-Framewoork"><a href="#框架层面APPlication-Framewoork" class="headerlink" title="框架层面APPlication Framewoork"></a>框架层面APPlication Framewoork</h5><h5 id="库"><a href="#库" class="headerlink" title="库"></a>库</h5><h4 id="hello项目"><a href="#hello项目" class="headerlink" title="hello项目"></a>hello项目</h4><ol>
<li><p>包名是标识APP的，必须是唯一的，且一般是公司的域名反向。即com.公司名.项目名</p>
</li>
<li><p>Empty Activity 是保证项目本身没有附带多余的控件，初学者使用！</p>
</li>
<li><p>use legacy android.support libraries： Android 高版本的包是 androidx，低版本的是Android，如果你需要使用低版本的Android来编程，则可以勾选这个选项。</p>
</li>
<li><p>AndroidManifest.xml  清单文件、配置文件同时也是布局文件</p>
<p>清单文件，四大组件的注册以及权限的授予都在这里</p>
<p>intent-filter ：意图过滤器的作用有：指派那个Activity为启动界面，在广播、服务等组件通信过程中进行过滤</p>
<p>新建项目的步骤：建立多个 package(activity(界面)、bean(用户类)、utils(工具)等等)，将资源文件复制粘贴到相关的文件夹里面，最后开始编码。</p>
</li>
<li><p>File - Settings</p>
<p>Appearabce：Android设置外观，可以选择亮色调或者暗色调主题。</p>
<p>Editor- Font：设置编辑器文字大小。</p>
<p>Plugis：可以加载相关的jar包，是的所有的项目可以直接使用。</p>
</li>
<li><p>res - values</p>
<p>根据css样式，我们应该将控件的相同属性定义成一个样式，保存在styles.xml中，将项目中常用的颜色定义在colors.xml中，将项目中常用的文本内容定义在string.xml中。</p>
</li>
</ol>
<h4 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h4><p>​	LinearLayout  线性布局 双标签</p>
<p>如果控件和用户进行交互就一定要有id ， </p>
<h4 id="五种-常用的布局"><a href="#五种-常用的布局" class="headerlink" title="五种 常用的布局"></a>五种 常用的布局</h4><p>线性布局：以水平或垂直方向排列</p>
<p>相对布局 :通过相对定位排列</p>
<p>帧布局: 开辟空白区域，帧里的控件(层)叠加</p>
<p>表格布局：表格形式排列  允许跨列 ，不允许跨行</p>
<p>约束布局：可视化的方式编写布局</p>
<p>网格布局: 允许跨列 ，允许跨行</p>
<h5 id="线性布局-1"><a href="#线性布局-1" class="headerlink" title="线性布局"></a>线性布局</h5><p>注释 <!--  --></p>
<p> 根标签的线性布局允许省略排列方向，默认为水平排列</p>
<p>按照排列方向依次放置控件</p>
<p>Button，Edittext 强制添加id属性</p>
<p>id的命名规则为：控件缩写_实现功能</p>
<p>首先设定控件的布局属性，在设定控件的自身属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/btn_one&quot;</span><br><span class="line">	android:layout_width=&quot;width&quot;</span><br><span class="line">	android:id=layout_height=&quot;&quot;</span><br><span class="line">	android:text=&quot;按钮2&quot;/&gt;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">当控件使用权重属性时。布局宽度一定要设置为0dp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在相对布局中.首先放置的控件一般为直接相对父布局进行定位的空间--&gt;</span><br><span class="line">&lt;!-- 定位控件时，一般需要指定x和y两个方向的定位--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><h4 id="1-LinearLayout-线性布局"><a href="#1-LinearLayout-线性布局" class="headerlink" title="1.LinearLayout 线性布局"></a>1.LinearLayout 线性布局</h4><h5 id="以水平或垂直来排列内部控件，不考虑控件间的相互定位。"><a href="#以水平或垂直来排列内部控件，不考虑控件间的相互定位。" class="headerlink" title="以水平或垂直来排列内部控件，不考虑控件间的相互定位。"></a>以水平或垂直来排列内部控件，不考虑控件间的相互定位。</h5><h5 id="允许在水平和垂直位置上进行权重的设定、"><a href="#允许在水平和垂直位置上进行权重的设定、" class="headerlink" title="允许在水平和垂直位置上进行权重的设定、"></a>允许在水平和垂直位置上进行权重的设定、</h5><h4 id="2-RelativeLayout-相对布局"><a href="#2-RelativeLayout-相对布局" class="headerlink" title="2.RelativeLayout 相对布局"></a>2.RelativeLayout 相对布局</h4><h5 id="根据控件与父布局的相对定位或者控件与控件的相对定位来摆放控件"><a href="#根据控件与父布局的相对定位或者控件与控件的相对定位来摆放控件" class="headerlink" title="根据控件与父布局的相对定位或者控件与控件的相对定位来摆放	控件"></a>根据控件与父布局的相对定位或者控件与控件的相对定位来摆放	控件</h5><h5 id="在整个布局中，优先定位直接根据父布局定位的控件，再去放置其他控件"><a href="#在整个布局中，优先定位直接根据父布局定位的控件，再去放置其他控件" class="headerlink" title="在整个布局中，优先定位直接根据父布局定位的控件，再去放置	其他控件"></a>在整个布局中，优先定位直接根据父布局定位的控件，再去放置	其他控件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		根据父布局定位，则有左、右、上、下</span><br><span class="line"></span><br><span class="line">​			android:layout_alignParentLeft</span><br><span class="line"></span><br><span class="line">​			android:layout_alignParentRight</span><br><span class="line"></span><br><span class="line">			android:layout_alignParentTop</span><br><span class="line">			</span><br><span class="line">			android:layout_alignParentBootom</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中心位置：android:layout_centerInparent</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		根据其他控件定位，则有在什么的左边、右边、上面、下面、</span><br><span class="line"></span><br><span class="line">​			android:layout_toLeftOf</span><br><span class="line"></span><br><span class="line">​			android:layout_toRightOf</span><br><span class="line"></span><br><span class="line">​			android:layout_above</span><br><span class="line"></span><br><span class="line">​			android:layout_below</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		以及左右、上下对齐</span><br><span class="line"></span><br><span class="line">​		android:layout_alignLeft</span><br><span class="line">​		android:layout_alignRight</span><br><span class="line">​		android:layout_alignTop</span><br><span class="line">​		android:layout_alignBottom</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强制横屏  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按钮背景透明  Button_ android:background:&quot;@null&quot;;</span><br><span class="line">强制最少宽度  minwidth =“200dp“;</span><br></pre></td></tr></table></figure>



<h5 id="相对布局的缺点是不可以进行权重的设定，因此它不能够完美的替换其他布局，为零弥补这个缺点，发明了约束布局，允许通过设定百分比来完美地替换其他布局"><a href="#相对布局的缺点是不可以进行权重的设定，因此它不能够完美的替换其他布局，为零弥补这个缺点，发明了约束布局，允许通过设定百分比来完美地替换其他布局" class="headerlink" title="相对布局的缺点是不可以进行权重的设定，因此它不能够完美的替换其他布局，为零弥补这个缺点，发明了约束布局，允许通过设定百分比来完美地替换其他布局"></a>相对布局的缺点是不可以进行权重的设定，因此它不能够完美的替换其他布局，为零弥补这个缺点，发明了约束布局，允许通过设定百分比来完美地替换其他布局</h5><h5 id="在相对布局中没有android-layout-gravity属性，因为相对布局本身进行通过定位来实现的"><a href="#在相对布局中没有android-layout-gravity属性，因为相对布局本身进行通过定位来实现的" class="headerlink" title="在相对布局中没有android:layout_gravity属性，因为相对布局本身进行通过定位来实现的"></a>在相对布局中没有android:layout_gravity属性，因为相对布局本身进行通过定位来实现的</h5><h4 id="3、FrameLayout-帧布局"><a href="#3、FrameLayout-帧布局" class="headerlink" title="3、FrameLayout 帧布局"></a>3、FrameLayout 帧布局</h4><h5 id="①-每一个控件代表一帧，后放置的控件默认会遮挡住前面的控件"><a href="#①-每一个控件代表一帧，后放置的控件默认会遮挡住前面的控件" class="headerlink" title="① 每一个控件代表一帧，后放置的控件默认会遮挡住前面的控件"></a>① 每一个控件代表一帧，后放置的控件默认会遮挡住前面的控件</h5><h5 id="②-默认控件是占据整个屏幕的"><a href="#②-默认控件是占据整个屏幕的" class="headerlink" title="② 默认控件是占据整个屏幕的"></a>② 默认控件是占据整个屏幕的</h5><h4 id="4、TableLayout-表格布局"><a href="#4、TableLayout-表格布局" class="headerlink" title="4、TableLayout 表格布局"></a>4、TableLayout 表格布局</h4><h5 id="①-多行多列，每个单元格放置一个控件"><a href="#①-多行多列，每个单元格放置一个控件" class="headerlink" title="① 多行多列，每个单元格放置一个控件"></a>① 多行多列，每个单元格放置一个控件</h5><h5 id="②-在行上可以实现权重的设定"><a href="#②-在行上可以实现权重的设定" class="headerlink" title="② 在行上可以实现权重的设定"></a>② 在行上可以实现权重的设定</h5><h5 id="③-在行上可以执行单元格的合并；在列上不可以，因为每一行必须被TableRow所包裹"><a href="#③-在行上可以执行单元格的合并；在列上不可以，因为每一行必须被TableRow所包裹" class="headerlink" title="③ 在行上可以执行单元格的合并；在列上不可以，因为每一行必须被TableRow所包裹"></a>③ 在行上可以执行单元格的合并；在列上不可以，因为每一行必须被TableRow所包裹</h5><h4 id="5、GridLayout-网格布局"><a href="#5、GridLayout-网格布局" class="headerlink" title="5、GridLayout 网格布局"></a>5、GridLayout 网格布局</h4><h5 id="①-多行多列，且存在跨行及跨列合并单元格的情况"><a href="#①-多行多列，且存在跨行及跨列合并单元格的情况" class="headerlink" title="① 多行多列，且存在跨行及跨列合并单元格的情况"></a>① 多行多列，且存在跨行及跨列合并单元格的情况</h5><h5 id="②-在行上以及列上均可以实现权重的设定，这样就能够实现全屏设定"><a href="#②-在行上以及列上均可以实现权重的设定，这样就能够实现全屏设定" class="headerlink" title="② 在行上以及列上均可以实现权重的设定，这样就能够实现全屏设定"></a>② 在行上以及列上均可以实现权重的设定，这样就能够实现全屏设定</h5><h5 id="③-在行上、列上都可以执行单元格的合并；因为网格布局没有TableRow，是通过android-layout-column、android-layout-row来直接设定行和列，或者直接通过android-layout-columnCount、android-layout-rowCount设定总的行数和列数以后，系统根据放置顺序直接识别行和列"><a href="#③-在行上、列上都可以执行单元格的合并；因为网格布局没有TableRow，是通过android-layout-column、android-layout-row来直接设定行和列，或者直接通过android-layout-columnCount、android-layout-rowCount设定总的行数和列数以后，系统根据放置顺序直接识别行和列" class="headerlink" title="③ 在行上、列上都可以执行单元格的合并；因为网格布局没有TableRow，是通过android:layout_column、android:layout_row来直接设定行和列，或者直接通过android:layout_columnCount、android:layout_rowCount设定总的行数和列数以后，系统根据放置顺序直接识别行和列"></a>③ 在行上、列上都可以执行单元格的合并；因为网格布局没有TableRow，是通过android:layout_column、android:layout_row来直接设定行和列，或者直接通过android:layout_columnCount、android:layout_rowCount设定总的行数和列数以后，系统根据放置顺序直接识别行和列</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <categories>
        <category>andirons</category>
      </categories>
      <tags>
        <tag>学校笔记</tag>
        <tag>andirons</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序学习(连载中)</title>
    <url>/posts/d347236.html</url>
    <content><![CDATA[<h5 id="页面给方法传参"><a href="#页面给方法传参" class="headerlink" title="页面给方法传参"></a><a href="https://benat.cn/posts/c8ea6d71.html">页面给方法传参</a></h5>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>学校笔记</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>java学校笔记Final关键字</title>
    <url>/posts/ec8d8377.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 学习内容;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final</span>关键字 &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * final 关键</span></span><br><span class="line"><span class="comment">	 * public private  --权限修饰符</span></span><br><span class="line"><span class="comment">	 * static --修饰符</span></span><br><span class="line"><span class="comment">	 * void 四种八类 --数据类型</span></span><br><span class="line"><span class="comment">	 * class</span></span><br><span class="line"><span class="comment">	 * this super </span></span><br><span class="line"><span class="comment">	 * final(最终，最后) 关键字 --修饰符</span></span><br><span class="line"><span class="comment">	 * 1.修饰类</span></span><br><span class="line"><span class="comment">	 * 2.修饰方法</span></span><br><span class="line"><span class="comment">	 * 3.修饰变量</span></span><br><span class="line"><span class="comment">	 *	final 修饰的类不能有子类（不能被继承）</span></span><br><span class="line"><span class="comment">	 *	final 修饰的方法不能被重写,但是可以被继承</span></span><br><span class="line"><span class="comment">	 *	final 修饰的变量初始化后就不能重新赋值</span></span><br><span class="line"><span class="comment">	 *	final static int i = 30；这是常量的定义</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Rectangle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学校笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java学校笔记三元运算符和switch</title>
    <url>/posts/ef68d2a6.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 学习内容;</span><br><span class="line"><span class="comment">/*package java01;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">import java.util.Scanner;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class Class10 &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//三元运算符 ？:</span></span><br><span class="line"><span class="comment">		int x = 9;</span></span><br><span class="line"><span class="comment">		/*		int y = 6;</span></span><br><span class="line"><span class="comment">		int max = x&gt;y?x:y;</span></span><br><span class="line"><span class="comment">		System.out.println(max);</span></span><br><span class="line"><span class="comment"> Scanner scan = new Scanner(System.in);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 int c = scan.nextInt();</span></span><br><span class="line"><span class="comment">	 c = x % 2==0?&#x27;t&#x27;:&#x27;f&#x27;;</span></span><br><span class="line"><span class="comment">		System.out.println((char)c);</span></span><br><span class="line"><span class="comment">	&#125; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//switch break; default;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switc注意事项</span></span><br><span class="line"><span class="comment">1.可以直接放数字</span></span><br><span class="line"><span class="comment">2.一种情况只能出现一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学校笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java学校笔记Static关键字和代码块</title>
    <url>/posts/8c6f2d57.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 学习内容;</span><br><span class="line"><span class="comment">// static 修饰的变量属于对象共享的数据，属于静态变量不在再是成员变量。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static 修饰的变量是属于类的 ，而不是属于对象的。</span></span><br><span class="line"><span class="comment"> * static 修饰的方法属于静态方法。</span></span><br><span class="line"><span class="comment"> * 所以访问静态方法以及静态变量有两种方法：</span></span><br><span class="line"><span class="comment"> * 1.通过对象访问</span></span><br><span class="line"><span class="comment"> * 2.通过类目访问--推荐使用</span></span><br><span class="line"><span class="comment"> * 没有创建对象时，静态方法以及静态变量依然存在。</span></span><br><span class="line"><span class="comment"> * 3.静态无法访问成员变量以及成员方法</span></span><br><span class="line"><span class="comment"> * 静态方法只能访问静态方法以及静态变量。</span></span><br><span class="line"><span class="comment"> * 成员方法可以访问静态方法以及静态变量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 静态代码块 </span></span><br><span class="line"><span class="comment"> * 1.静态代码块的执行优先于构造方法,在创建对象时优先执行。</span></span><br><span class="line"><span class="comment"> * 2.静态代码块只在创建第一次对象的时候执行一次。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 格式：</span></span><br><span class="line"><span class="comment"> * static&#123;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Static</span>关键字和代码块 &#123;</span><br><span class="line">	<span class="keyword">public</span> Static关键字和代码块() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Static关键字和代码块(<span class="type">int</span> sTuNo, String name, <span class="type">int</span> age) &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	<span class="built_in">this</span>.sTuNo = sTuNo;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sTuNo;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age ;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> room;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Stydent [sTuNo=&quot;</span> + sTuNo + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学校笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java学校笔记数据类型结构</title>
    <url>/posts/37015d6b.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 学习内容;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 数据类型结构 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		<span class="comment">//1.数据类型：基本数据类型、引用数据类型</span></span><br><span class="line">		<span class="comment">/*基本数据类型：四种八类</span></span><br><span class="line"><span class="comment">		 * （1）整数类型（byte、short、int、long）</span></span><br><span class="line"><span class="comment">		 * （2）浮点数类型（float、double）</span></span><br><span class="line"><span class="comment">		 * （3）字符类型（char）</span></span><br><span class="line"><span class="comment">		 * （4）布尔类型（boolean）</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">​	<span class="comment">//(1)整数类型</span></span><br><span class="line">​	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * byte：字节型，一个字节（占8位），范围：-2^7~2^7-1   -128~127,默认值0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * short:短整型，二个字节（占16位），范围：-2^15~2^15-1,默认值0</span></span><br><span class="line"><span class="comment">     * int：整型，Java中默认的整数类型，四个字节（占32位），范围：-2^31~2^31-1,默认值0</span></span><br><span class="line"><span class="comment">     * long:长整型，八个字节（占64位），范围：</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）浮点型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 单精度浮点型：float，默认值0.0f，四个字节（占32位）</span></span><br><span class="line"><span class="comment">     * 双精度浮点型：double，默认值0.0d，八个字节（占64位）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//（3）字符类型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * char:0~65535或&#x27;\u0000&#x27;~&#x27;\uffff&#x27;,默认值0或\u0000</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="comment">//(4)布尔类型</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * boolean:true flase</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.变量：内存单元</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    score = scan.nextInt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学校笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>html初步了解</title>
    <url>/posts/d7e9d6a9.html</url>
    <content><![CDATA[<h3 id="html初步了解"><a href="#html初步了解" class="headerlink" title="html初步了解"></a>html初步了解</h3><h5 id="（1）PPT指出互联网中相关的一些专业术语。"><a href="#（1）PPT指出互联网中相关的一些专业术语。" class="headerlink" title="（1）PPT指出互联网中相关的一些专业术语。"></a>（1）PPT指出互联网中相关的一些专业术语。</h5><h5 id="（2）展示PPT，对“Internet网络、WWW、URL、DNS、HTTP、Web、W3C组织”等专业术语进行详细讲解，并举例说明。"><a href="#（2）展示PPT，对“Internet网络、WWW、URL、DNS、HTTP、Web、W3C组织”等专业术语进行详细讲解，并举例说明。" class="headerlink" title="（2）展示PPT，对“Internet网络、WWW、URL、DNS、HTTP、Web、W3C组织”等专业术语进行详细讲解，并举例说明。"></a>（2）展示PPT，对“Internet网络、WWW、URL、DNS、HTTP、Web、W3C组织”等专业术语进行详细讲解，并举例说明。</h5><h5 id="所谓Internet网络就是通常所说的互联网，是由一些使用公用语言互相通信的计算机连接而成的网络。简单地说，互联网就是将世界范围内不同国家、不同地区的众多计算机连接起来形成的结果。"><a href="#所谓Internet网络就是通常所说的互联网，是由一些使用公用语言互相通信的计算机连接而成的网络。简单地说，互联网就是将世界范围内不同国家、不同地区的众多计算机连接起来形成的结果。" class="headerlink" title="所谓Internet网络就是通常所说的互联网，是由一些使用公用语言互相通信的计算机连接而成的网络。简单地说，互联网就是将世界范围内不同国家、不同地区的众多计算机连接起来形成的结果。"></a>所谓Internet网络就是通常所说的互联网，是由一些使用公用语言互相通信的计算机连接而成的网络。简单地说，互联网就是将世界范围内不同国家、不同地区的众多计算机连接起来形成的结果。</h5><h5 id="互联网实现了全球信息资源的共享，形成了一个能够共同参与、相互交流的互动平台。通过互联网远在千里之外的朋友可以相互发送邮件、共同完成一项工作、共同娱乐。因此，互联网最大的成功之处并不在于技术层面，而在于对人类生活的影响，可以说互联网的出现是人类通信技术史上的一次革命。"><a href="#互联网实现了全球信息资源的共享，形成了一个能够共同参与、相互交流的互动平台。通过互联网远在千里之外的朋友可以相互发送邮件、共同完成一项工作、共同娱乐。因此，互联网最大的成功之处并不在于技术层面，而在于对人类生活的影响，可以说互联网的出现是人类通信技术史上的一次革命。" class="headerlink" title="互联网实现了全球信息资源的共享，形成了一个能够共同参与、相互交流的互动平台。通过互联网远在千里之外的朋友可以相互发送邮件、共同完成一项工作、共同娱乐。因此，互联网最大的成功之处并不在于技术层面，而在于对人类生活的影响，可以说互联网的出现是人类通信技术史上的一次革命。"></a>互联网实现了全球信息资源的共享，形成了一个能够共同参与、相互交流的互动平台。通过互联网远在千里之外的朋友可以相互发送邮件、共同完成一项工作、共同娱乐。因此，互联网最大的成功之处并不在于技术层面，而在于对人类生活的影响，可以说互联网的出现是人类通信技术史上的一次革命。</h5><h5 id="WWW（英文World-Wide-Web的缩写）中文译为“万维网”。但WWW不是网络，也不代表Internet，它只是Internet提供的一种服务——即网页浏览服务，我们上网时通过浏览器阅读网页信息就是在使用WWW服务。WWW是Internet上最主要的服务，其他许多网络功能，如网上聊天、网上购物等，都是基于WWW服务的。"><a href="#WWW（英文World-Wide-Web的缩写）中文译为“万维网”。但WWW不是网络，也不代表Internet，它只是Internet提供的一种服务——即网页浏览服务，我们上网时通过浏览器阅读网页信息就是在使用WWW服务。WWW是Internet上最主要的服务，其他许多网络功能，如网上聊天、网上购物等，都是基于WWW服务的。" class="headerlink" title="WWW（英文World Wide Web的缩写）中文译为“万维网”。但WWW不是网络，也不代表Internet，它只是Internet提供的一种服务——即网页浏览服务，我们上网时通过浏览器阅读网页信息就是在使用WWW服务。WWW是Internet上最主要的服务，其他许多网络功能，如网上聊天、网上购物等，都是基于WWW服务的。"></a>WWW（英文World Wide Web的缩写）中文译为“万维网”。但WWW不是网络，也不代表Internet，它只是Internet提供的一种服务——即网页浏览服务，我们上网时通过浏览器阅读网页信息就是在使用WWW服务。WWW是Internet上最主要的服务，其他许多网络功能，如网上聊天、网上购物等，都是基于WWW服务的。</h5><h5 id="URL（英文Uniform-Resource-Locator的缩写）中文译为“统一资源定位符”。URL其实就是Web地址，俗称“网址”。URL可以是“本地磁盘”，也可以是局域网上的某一台计算机，更多的是Internet上的站点，比如http-www-itcast-cn就是传智播客的网址"><a href="#URL（英文Uniform-Resource-Locator的缩写）中文译为“统一资源定位符”。URL其实就是Web地址，俗称“网址”。URL可以是“本地磁盘”，也可以是局域网上的某一台计算机，更多的是Internet上的站点，比如http-www-itcast-cn就是传智播客的网址" class="headerlink" title="URL（英文Uniform Resource Locator的缩写）中文译为“统一资源定位符”。URL其实就是Web地址，俗称“网址”。URL可以是“本地磁盘”，也可以是局域网上的某一台计算机，更多的是Internet上的站点，比如http://www.itcast.cn就是传智播客的网址"></a>URL（英文Uniform Resource Locator的缩写）中文译为“统一资源定位符”。URL其实就是Web地址，俗称“网址”。URL可以是“本地磁盘”，也可以是局域网上的某一台计算机，更多的是Internet上的站点，比如<a href="http://www.itcast.cn就是传智播客的网址/">http://www.itcast.cn就是传智播客的网址</a></h5><h5 id="DNS-（英文Domain-Name-System的缩写）是域名解析系统。在Internet上域名与IP地址之间是一一对应的，域名（例如传智播客的域名www-itcast-cn）虽然便于人们记忆，但计算机只认识IP地址，将好记的域名转换成IP的过程被称为域名解析。DNS就是进行域名解析的系统。"><a href="#DNS-（英文Domain-Name-System的缩写）是域名解析系统。在Internet上域名与IP地址之间是一一对应的，域名（例如传智播客的域名www-itcast-cn）虽然便于人们记忆，但计算机只认识IP地址，将好记的域名转换成IP的过程被称为域名解析。DNS就是进行域名解析的系统。" class="headerlink" title="DNS （英文Domain Name System的缩写）是域名解析系统。在Internet上域名与IP地址之间是一一对应的，域名（例如传智播客的域名www.itcast.cn）虽然便于人们记忆，但计算机只认识IP地址，将好记的域名转换成IP的过程被称为域名解析。DNS就是进行域名解析的系统。"></a>DNS （英文Domain Name System的缩写）是域名解析系统。在Internet上域名与IP地址之间是一一对应的，域名（例如传智播客的域名<a href="http://www.itcast.cn)虽然便于人们记忆,但计算机只认识ip地址,将好记的域名转换成ip的过程被称为域名解析.dns就是进行域名解析的系统./">www.itcast.cn）虽然便于人们记忆，但计算机只认识IP地址，将好记的域名转换成IP的过程被称为域名解析。DNS就是进行域名解析的系统。</a></h5><h5 id="HTTP-英文Hypertext-transfer-protocol的缩写-中文译为超文本传输协议。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则。HTTP是非常可靠的协议，它具有强大的自检能力，所有用户请求的文件到达客户端时，一定是准确无误的。"><a href="#HTTP-英文Hypertext-transfer-protocol的缩写-中文译为超文本传输协议。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则。HTTP是非常可靠的协议，它具有强大的自检能力，所有用户请求的文件到达客户端时，一定是准确无误的。" class="headerlink" title="HTTP (英文Hypertext transfer protocol的缩写) 中文译为超文本传输协议。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则。HTTP是非常可靠的协议，它具有强大的自检能力，所有用户请求的文件到达客户端时，一定是准确无误的。"></a>HTTP (英文Hypertext transfer protocol的缩写) 中文译为超文本传输协议。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则。HTTP是非常可靠的协议，它具有强大的自检能力，所有用户请求的文件到达客户端时，一定是准确无误的。</h5><h5 id="Web本意是蜘蛛网和网的意思。对于普通用户来说，Web仅仅只是一种环境——互联网的使用环境、氛围、内容等。而对于网站设计、制作者来说，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页。"><a href="#Web本意是蜘蛛网和网的意思。对于普通用户来说，Web仅仅只是一种环境——互联网的使用环境、氛围、内容等。而对于网站设计、制作者来说，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页。" class="headerlink" title="Web本意是蜘蛛网和网的意思。对于普通用户来说，Web仅仅只是一种环境——互联网的使用环境、氛围、内容等。而对于网站设计、制作者来说，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页。"></a>Web本意是蜘蛛网和网的意思。对于普通用户来说，Web仅仅只是一种环境——互联网的使用环境、氛围、内容等。而对于网站设计、制作者来说，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页。</h5><h5 id="W3C（英文World-Wide-Web-Consortium的缩写）中文译为“万维网联盟”。万维网联盟是国际最著名的标准化组织。W3C最重要的工作是发展Web规范，自1994年成立以来，已经发布了200多项影响深远的Web技术标准及实施指南，如超文本标记语言（HTML）、可扩展标记语言（XML）等。这些规范有效地促进了Web技术的兼容，对互联网的发展和应用起到了基础性和根本性的支撑作用。"><a href="#W3C（英文World-Wide-Web-Consortium的缩写）中文译为“万维网联盟”。万维网联盟是国际最著名的标准化组织。W3C最重要的工作是发展Web规范，自1994年成立以来，已经发布了200多项影响深远的Web技术标准及实施指南，如超文本标记语言（HTML）、可扩展标记语言（XML）等。这些规范有效地促进了Web技术的兼容，对互联网的发展和应用起到了基础性和根本性的支撑作用。" class="headerlink" title="W3C（英文World Wide Web Consortium的缩写）中文译为“万维网联盟”。万维网联盟是国际最著名的标准化组织。W3C最重要的工作是发展Web规范，自1994年成立以来，已经发布了200多项影响深远的Web技术标准及实施指南，如超文本标记语言（HTML）、可扩展标记语言（XML）等。这些规范有效地促进了Web技术的兼容，对互联网的发展和应用起到了基础性和根本性的支撑作用。"></a>W3C（英文World Wide Web Consortium的缩写）中文译为“万维网联盟”。万维网联盟是国际最著名的标准化组织。W3C最重要的工作是发展Web规范，自1994年成立以来，已经发布了200多项影响深远的Web技术标准及实施指南，如超文本标记语言（HTML）、可扩展标记语言（XML）等。这些规范有效地促进了Web技术的兼容，对互联网的发展和应用起到了基础性和根本性的支撑作用。</h5><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="四、了解web标准"><a href="#四、了解web标准" class="headerlink" title="四、了解web标准"></a>四、了解web标准</h3><h5 id="（1）展示PPT对“Web标准”制定的原因及背景进行讲解。"><a href="#（1）展示PPT对“Web标准”制定的原因及背景进行讲解。" class="headerlink" title="（1）展示PPT对“Web标准”制定的原因及背景进行讲解。"></a>（1）展示PPT对“Web标准”制定的原因及背景进行讲解。</h5><h5 id="（2）Web标准并不是某一个标准，而是一系列标准的集合，主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。分别对Web标准的“结构标准”、“表现标准”及“行为标准”进行详细讲解，并分别举例说明。"><a href="#（2）Web标准并不是某一个标准，而是一系列标准的集合，主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。分别对Web标准的“结构标准”、“表现标准”及“行为标准”进行详细讲解，并分别举例说明。" class="headerlink" title="（2）Web标准并不是某一个标准，而是一系列标准的集合，主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。分别对Web标准的“结构标准”、“表现标准”及“行为标准”进行详细讲解，并分别举例说明。"></a>（2）Web标准并不是某一个标准，而是一系列标准的集合，主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。分别对Web标准的“结构标准”、“表现标准”及“行为标准”进行详细讲解，并分别举例说明。</h5><h4 id="结构标准"><a href="#结构标准" class="headerlink" title="结构标准"></a>结构标准</h4><h5 id="结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分，具体区别如下："><a href="#结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分，具体区别如下：" class="headerlink" title="结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分，具体区别如下："></a>结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分，具体区别如下：</h5><h5 id="XML（英文The-Extensible-Markup-Language-的缩写）是一种可扩展标记语言。XML最初的目的是为了弥补HTML的不足，它具有强大的扩展性，可用于数据的转换和描述。"><a href="#XML（英文The-Extensible-Markup-Language-的缩写）是一种可扩展标记语言。XML最初的目的是为了弥补HTML的不足，它具有强大的扩展性，可用于数据的转换和描述。" class="headerlink" title="XML（英文The Extensible Markup Language 的缩写）是一种可扩展标记语言。XML最初的目的是为了弥补HTML的不足，它具有强大的扩展性，可用于数据的转换和描述。"></a>XML（英文The Extensible Markup Language 的缩写）是一种可扩展标记语言。XML最初的目的是为了弥补HTML的不足，它具有强大的扩展性，可用于数据的转换和描述。</h5><h5 id="XHTML（英文The-Extensible-HyperText-Markup-Language的缩写）是可扩展超文本标识语言。XHTML是基于XML的标识语言，是在HTML4-0的基础上，用XML的规则对其进行扩展建立起来的，它实现了HTML向XML的过渡。"><a href="#XHTML（英文The-Extensible-HyperText-Markup-Language的缩写）是可扩展超文本标识语言。XHTML是基于XML的标识语言，是在HTML4-0的基础上，用XML的规则对其进行扩展建立起来的，它实现了HTML向XML的过渡。" class="headerlink" title="XHTML（英文The Extensible HyperText Markup Language的缩写）是可扩展超文本标识语言。XHTML是基于XML的标识语言，是在HTML4.0的基础上，用XML的规则对其进行扩展建立起来的，它实现了HTML向XML的过渡。"></a>XHTML（英文The Extensible HyperText Markup Language的缩写）是可扩展超文本标识语言。XHTML是基于XML的标识语言，是在HTML4.0的基础上，用XML的规则对其进行扩展建立起来的，它实现了HTML向XML的过渡。</h5><h4 id="表现标准"><a href="#表现标准" class="headerlink" title="表现标准"></a>表现标准</h4><h5 id="表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS，具体介绍如下："><a href="#表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS，具体介绍如下：" class="headerlink" title="表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS，具体介绍如下："></a>表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS，具体介绍如下：</h5><h5 id="CSS（英文Cascading-Style-Sheet的缩写）是层叠样式表。CSS标准建立的目的是以CSS为基础进行网页布局，控制网页的表现。CSS布局与XHTML结构语言相结合，可以实现表现与结构的分离，使网站的访问及维护更加容易。"><a href="#CSS（英文Cascading-Style-Sheet的缩写）是层叠样式表。CSS标准建立的目的是以CSS为基础进行网页布局，控制网页的表现。CSS布局与XHTML结构语言相结合，可以实现表现与结构的分离，使网站的访问及维护更加容易。" class="headerlink" title="CSS（英文Cascading Style Sheet的缩写）是层叠样式表。CSS标准建立的目的是以CSS为基础进行网页布局，控制网页的表现。CSS布局与XHTML结构语言相结合，可以实现表现与结构的分离，使网站的访问及维护更加容易。"></a>CSS（英文Cascading Style Sheet的缩写）是层叠样式表。CSS标准建立的目的是以CSS为基础进行网页布局，控制网页的表现。CSS布局与XHTML结构语言相结合，可以实现表现与结构的分离，使网站的访问及维护更加容易。</h5><h4 id="行为标准"><a href="#行为标准" class="headerlink" title="行为标准"></a>行为标准</h4><h5 id="行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。具体区别如下："><a href="#行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。具体区别如下：" class="headerlink" title="行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。具体区别如下："></a>行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。具体区别如下：</h5><h5 id="DOM（英文Document-Object-Model的缩写）是文档对象模型。W3C-文档对象模型-（DOM）-是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。"><a href="#DOM（英文Document-Object-Model的缩写）是文档对象模型。W3C-文档对象模型-（DOM）-是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。" class="headerlink" title="DOM（英文Document Object Model的缩写）是文档对象模型。W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。"></a>DOM（英文Document Object Model的缩写）是文档对象模型。W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</h5><h5 id="ECMAScript是ECMA（英文European-Computer-Manufacturers-Association的缩写）国际以JavaScript为基础制定的标准脚本语言。JavaScript是一种基于对象和事件驱动，并具有相对安全性的客户端脚本语言，广泛用于Web开发，常用来给HTML网页添加动态功能，比如响应用户的各种操作。"><a href="#ECMAScript是ECMA（英文European-Computer-Manufacturers-Association的缩写）国际以JavaScript为基础制定的标准脚本语言。JavaScript是一种基于对象和事件驱动，并具有相对安全性的客户端脚本语言，广泛用于Web开发，常用来给HTML网页添加动态功能，比如响应用户的各种操作。" class="headerlink" title="ECMAScript是ECMA（英文European Computer Manufacturers Association的缩写）国际以JavaScript为基础制定的标准脚本语言。JavaScript是一种基于对象和事件驱动，并具有相对安全性的客户端脚本语言，广泛用于Web开发，常用来给HTML网页添加动态功能，比如响应用户的各种操作。"></a>ECMAScript是ECMA（英文European Computer Manufacturers Association的缩写）国际以JavaScript为基础制定的标准脚本语言。JavaScript是一种基于对象和事件驱动，并具有相对安全性的客户端脚本语言，广泛用于Web开发，常用来给HTML网页添加动态功能，比如响应用户的各种操作。</h5><h4 id="五、HTML简介"><a href="#五、HTML简介" class="headerlink" title="五、HTML简介"></a>五、HTML简介</h4><h5 id="（1）展示PPT对“HTML语言”的概念及作用进行简单介绍。"><a href="#（1）展示PPT对“HTML语言”的概念及作用进行简单介绍。" class="headerlink" title="（1）展示PPT对“HTML语言”的概念及作用进行简单介绍。"></a>（1）展示PPT对“HTML语言”的概念及作用进行简单介绍。</h5><h5 id="HTML（英文Hyper-Text-Markup-Language的缩写）中文译为“超文本标记语言”，主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。HTML提供了许多标记，如段落标记、标题标记、超链接标记、图片标记等，网页中需要定义什么内容，就用相应的HTML标记描述即可。"><a href="#HTML（英文Hyper-Text-Markup-Language的缩写）中文译为“超文本标记语言”，主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。HTML提供了许多标记，如段落标记、标题标记、超链接标记、图片标记等，网页中需要定义什么内容，就用相应的HTML标记描述即可。" class="headerlink" title="HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标记语言”，主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。HTML提供了许多标记，如段落标记、标题标记、超链接标记、图片标记等，网页中需要定义什么内容，就用相应的HTML标记描述即可。"></a>HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标记语言”，主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。HTML提供了许多标记，如段落标记、标题标记、超链接标记、图片标记等，网页中需要定义什么内容，就用相应的HTML标记描述即可。</h5><h5 id="HTML之所以称为超文本标记语言，不仅是因为它通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”点。通过超链接将网站与网页以及各种网页元素链接起来，构成了丰富多彩的Web页面。"><a href="#HTML之所以称为超文本标记语言，不仅是因为它通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”点。通过超链接将网站与网页以及各种网页元素链接起来，构成了丰富多彩的Web页面。" class="headerlink" title="HTML之所以称为超文本标记语言，不仅是因为它通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”点。通过超链接将网站与网页以及各种网页元素链接起来，构成了丰富多彩的Web页面。"></a>HTML之所以称为超文本标记语言，不仅是因为它通过标记描述网页内容，同时也由于文本中包含了所谓的“超级链接”点。通过超链接将网站与网页以及各种网页元素链接起来，构成了丰富多彩的Web页面。</h5><h5 id="（2）通过查看“百度”网页的源代码，分析HTML语言中包含的标记。"><a href="#（2）通过查看“百度”网页的源代码，分析HTML语言中包含的标记。" class="headerlink" title="（2）通过查看“百度”网页的源代码，分析HTML语言中包含的标记。"></a>（2）通过查看“百度”网页的源代码，分析HTML语言中包含的标记。</h5><h5 id="（3）展示PPT对“HTML语言发展的历程”进行讲解，并指出各个版本中HTML标记的变化。HTML语言发展至今，经历了六个版本，这个过程中新增了许多HTML标记，同时也淘汰了一些标记，具体历程如下："><a href="#（3）展示PPT对“HTML语言发展的历程”进行讲解，并指出各个版本中HTML标记的变化。HTML语言发展至今，经历了六个版本，这个过程中新增了许多HTML标记，同时也淘汰了一些标记，具体历程如下：" class="headerlink" title="（3）展示PPT对“HTML语言发展的历程”进行讲解，并指出各个版本中HTML标记的变化。HTML语言发展至今，经历了六个版本，这个过程中新增了许多HTML标记，同时也淘汰了一些标记，具体历程如下："></a>（3）展示PPT对“HTML语言发展的历程”进行讲解，并指出各个版本中HTML标记的变化。HTML语言发展至今，经历了六个版本，这个过程中新增了许多HTML标记，同时也淘汰了一些标记，具体历程如下：</h5><h5 id="超文本标记语言（第一版）——在1993年6月作为互联网工程工作小组（IETF）工作草案发布。"><a href="#超文本标记语言（第一版）——在1993年6月作为互联网工程工作小组（IETF）工作草案发布。" class="headerlink" title="超文本标记语言（第一版）——在1993年6月作为互联网工程工作小组（IETF）工作草案发布。"></a>超文本标记语言（第一版）——在1993年6月作为互联网工程工作小组（IETF）工作草案发布。</h5><h5 id="HTML-2-0——1995年11月作为RFC-1866发布，在RFC-2854于2000年6月发布之后被宣布已经过时。"><a href="#HTML-2-0——1995年11月作为RFC-1866发布，在RFC-2854于2000年6月发布之后被宣布已经过时。" class="headerlink" title="HTML 2.0——1995年11月作为RFC 1866发布，在RFC 2854于2000年6月发布之后被宣布已经过时。"></a>HTML 2.0——1995年11月作为RFC 1866发布，在RFC 2854于2000年6月发布之后被宣布已经过时。</h5><h5 id="HTML-3-2——1997年1月14日，W3C推荐标准。"><a href="#HTML-3-2——1997年1月14日，W3C推荐标准。" class="headerlink" title="HTML 3.2——1997年1月14日，W3C推荐标准。"></a>HTML 3.2——1997年1月14日，W3C推荐标准。</h5><h5 id="HTML-4-0——1997年12月18日，W3C推荐标准。"><a href="#HTML-4-0——1997年12月18日，W3C推荐标准。" class="headerlink" title="HTML 4.0——1997年12月18日，W3C推荐标准。"></a>HTML 4.0——1997年12月18日，W3C推荐标准。</h5><h5 id="HTML-4-01（微小改进）——1999年12月24日，W3C推荐标准。"><a href="#HTML-4-01（微小改进）——1999年12月24日，W3C推荐标准。" class="headerlink" title="HTML 4.01（微小改进）——1999年12月24日，W3C推荐标准。"></a>HTML 4.01（微小改进）——1999年12月24日，W3C推荐标准。</h5><h5 id="HTML-5的第一份正式草案于2008年1月22日公布，2014年10月底定稿。"><a href="#HTML-5的第一份正式草案于2008年1月22日公布，2014年10月底定稿。" class="headerlink" title="HTML 5的第一份正式草案于2008年1月22日公布，2014年10月底定稿。"></a>HTML 5的第一份正式草案于2008年1月22日公布，2014年10月底定稿。</h5><h4 id="六、CSS简介"><a href="#六、CSS简介" class="headerlink" title="六、CSS简介"></a>六、CSS简介</h4><h5 id="（1）展示PPT对“CSS语言”的概念进行简单介绍。"><a href="#（1）展示PPT对“CSS语言”的概念进行简单介绍。" class="headerlink" title="（1）展示PPT对“CSS语言”的概念进行简单介绍。"></a>（1）展示PPT对“CSS语言”的概念进行简单介绍。</h5><h5 id="CSS通常称为CSS样式或样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。"><a href="#CSS通常称为CSS样式或样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。" class="headerlink" title="CSS通常称为CSS样式或样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。"></a>CSS通常称为CSS样式或样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。</h5><h5 id="（2）展示PPT，对CSS语言的作用及发展历程进行讲解，并对CSS控制的网页效果进行展示。"><a href="#（2）展示PPT，对CSS语言的作用及发展历程进行讲解，并对CSS控制的网页效果进行展示。" class="headerlink" title="（2）展示PPT，对CSS语言的作用及发展历程进行讲解，并对CSS控制的网页效果进行展示。"></a>（2）展示PPT，对CSS语言的作用及发展历程进行讲解，并对CSS控制的网页效果进行展示。</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h4 id="七、JavaScript简介"><a href="#七、JavaScript简介" class="headerlink" title="七、JavaScript简介"></a>七、JavaScript简介</h4><h5 id="（1）展示PPT对“JavaScript语言”的概念进行简单介绍。"><a href="#（1）展示PPT对“JavaScript语言”的概念进行简单介绍。" class="headerlink" title="（1）展示PPT对“JavaScript语言”的概念进行简单介绍。"></a>（1）展示PPT对“JavaScript语言”的概念进行简单介绍。</h5><h5 id="JavaScript是Web页面中的一种脚本语言，通过JavaScript可以将静态页面转变成支持用户交互并响应相应事件的动态页面。"><a href="#JavaScript是Web页面中的一种脚本语言，通过JavaScript可以将静态页面转变成支持用户交互并响应相应事件的动态页面。" class="headerlink" title="JavaScript是Web页面中的一种脚本语言，通过JavaScript可以将静态页面转变成支持用户交互并响应相应事件的动态页面。"></a>JavaScript是Web页面中的一种脚本语言，通过JavaScript可以将静态页面转变成支持用户交互并响应相应事件的动态页面。</h5><h5 id="（2）展示PPT，对JavaScript语言的作用及发展历程进行讲解，并对JavaScript控制的网页效果进行展示。"><a href="#（2）展示PPT，对JavaScript语言的作用及发展历程进行讲解，并对JavaScript控制的网页效果进行展示。" class="headerlink" title="（2）展示PPT，对JavaScript语言的作用及发展历程进行讲解，并对JavaScript控制的网页效果进行展示。"></a>（2）展示PPT，对JavaScript语言的作用及发展历程进行讲解，并对JavaScript控制的网页效果进行展示。</h5>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Arrays集合</title>
    <url>/posts/c3c27062.html</url>
    <content><![CDATA[<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul>
<li><h5 id="数组的工具类包名-java-util-Arrays"><a href="#数组的工具类包名-java-util-Arrays" class="headerlink" title="数组的工具类包名 java.util.Arrays"></a>数组的工具类包名 java.util.Arrays</h5></li>
<li><h5 id="由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。"><a href="#由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。" class="headerlink" title="由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。"></a>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</h5></li>
<li><h5 id="查看JDK帮助文档"><a href="#查看JDK帮助文档" class="headerlink" title="查看JDK帮助文档"></a>查看JDK帮助文档</h5></li>
<li><h5 id="Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意是”不用”而不是“不能”）"><a href="#Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意是”不用”而不是“不能”）" class="headerlink" title="Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意是”不用”而不是“不能”）"></a>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意是”不用”而不是“不能”）</h5></li>
<li><h4 id="具有以下常用供能："><a href="#具有以下常用供能：" class="headerlink" title="具有以下常用供能："></a>具有以下常用供能：</h4><ul>
<li><h5 id="给数组赋值：通过fill方法。"><a href="#给数组赋值：通过fill方法。" class="headerlink" title="给数组赋值：通过fill方法。"></a>给数组赋值：通过fill方法。</h5></li>
<li><h5 id="给数组排序：通过sort方法，按升序。"><a href="#给数组排序：通过sort方法，按升序。" class="headerlink" title="给数组排序：通过sort方法，按升序。"></a>给数组排序：通过sort方法，按升序。</h5></li>
<li><h5 id="比较数组：通过equals-方法比较数组中元素值是否相等。"><a href="#比较数组：通过equals-方法比较数组中元素值是否相等。" class="headerlink" title="比较数组：通过equals 方法比较数组中元素值是否相等。"></a>比较数组：通过equals 方法比较数组中元素值是否相等。</h5></li>
<li><h5 id="查找数组元素：通过binarySearch方法能对排序号的数组进行二分查找法操作。"><a href="#查找数组元素：通过binarySearch方法能对排序号的数组进行二分查找法操作。" class="headerlink" title="查找数组元素：通过binarySearch方法能对排序号的数组进行二分查找法操作。"></a>查找数组元素：通过binarySearch方法能对排序号的数组进行二分查找法操作。</h5></li>
</ul>
</li>
</ul>
<h4 id="打印数组元素："><a href="#打印数组元素：" class="headerlink" title="打印数组元素："></a>打印数组元素：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] array ;<span class="comment">//定义一个数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];<span class="comment">//创建了一个数组，这里面可以存放10个int类型的数字</span></span><br><span class="line">    <span class="comment">//给数组元素赋值</span></span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        array[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">        array[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">        array[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">        array[<span class="number">6</span>]=<span class="number">7</span>;</span><br><span class="line">        array[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">        array[<span class="number">8</span>]=<span class="number">9</span>;</span><br><span class="line">        array[<span class="number">9</span>]=<span class="number">10</span>;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<h4 id="集合类数组排序"><a href="#集合类数组排序" class="headerlink" title="集合类数组排序"></a>集合类数组排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] array ;<span class="comment">//定义一个数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">5</span>];<span class="comment">//创建了一个数组，这里面可以存放10个int类型的数字</span></span><br><span class="line">    <span class="comment">//给数组元素赋值</span></span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        array[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">        array[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line"> Arrays.sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] array ;<span class="comment">//定义一个数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];<span class="comment">//创建了一个数组，这里面可以存放10个int类型的数字</span></span><br><span class="line">    <span class="comment">//给数组元素赋值</span></span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">9</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">8</span>;</span><br><span class="line">        array[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">        array[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">        array[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">        array[<span class="number">6</span>]=<span class="number">3</span>;</span><br><span class="line">        array[<span class="number">7</span>]=<span class="number">6</span>;</span><br><span class="line">        array[<span class="number">8</span>]=<span class="number">7</span>;</span><br><span class="line">        array[<span class="number">9</span>]=<span class="number">0</span>;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="comment">//给数组 二到第四个元素填充0</span></span><br><span class="line">        Arrays.fill(array,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>file类</title>
    <url>/posts/70b5696.html</url>
    <content><![CDATA[<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul>
<li><p><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </p>
</li>
<li><p><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</p>
</li>
<li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </p>
</li>
<li><p>构造举例，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileIs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 文件?:<span class="literal">false</span></span><br><span class="line">d:\aaa 目录?:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul>
<li><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p>
</li>
<li><p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug的使用</title>
    <url>/posts/3f0598a9.html</url>
    <content><![CDATA[<h3 id="Debug的使用-："><a href="#Debug的使用-：" class="headerlink" title="Debug的使用 ："></a>Debug的使用 ：</h3><h4 id="在IDEa或者在eclipse中"><a href="#在IDEa或者在eclipse中" class="headerlink" title="在IDEa或者在eclipse中,"></a>在IDEa或者在eclipse中,</h4><h4 id="1-先点击要检查的代码前面，出现红点或蓝点表示标记成功"><a href="#1-先点击要检查的代码前面，出现红点或蓝点表示标记成功" class="headerlink" title="1.先点击要检查的代码前面，出现红点或蓝点表示标记成功,"></a>1.先点击要检查的代码前面，出现红点或蓝点表示标记成功,</h4><h4 id="2-然后找到选项栏运行图标旁边的-”Debug“"><a href="#2-然后找到选项栏运行图标旁边的-”Debug“" class="headerlink" title="2.然后找到选项栏运行图标旁边的 ”Debug“"></a>2.然后找到选项栏运行图标旁边的 ”Debug“</h4><h4 id="3-点击之后下方窗口会出现控制栏-就可以调试或者一步一步点击下一步看代码运行状态和代码执行内容"><a href="#3-点击之后下方窗口会出现控制栏-就可以调试或者一步一步点击下一步看代码运行状态和代码执行内容" class="headerlink" title="3.点击之后下方窗口会出现控制栏,就可以调试或者一步一步点击下一步看代码运行状态和代码执行内容"></a>3.点击之后下方窗口会出现控制栏,就可以调试或者一步一步点击下一步看代码运行状态和代码执行内容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印五行三角形  5行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">5</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span> ; j&lt;i;j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/posts/6331d382.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 数据库连接池

2. Spring JDBC : JDBC Template
</code></pre>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。
        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。

2. 好处：
    1. 节约资源
    2. 用户访问高效

3. 实现：
    1. 标准接口：DataSource   javax.sql包下的
        1. 方法：
            * 获取连接：getConnection()
            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接

    2. 一般我们不去实现它，有数据库厂商来实现
        1. C3P0：数据库连接池技术
        2. Druid：数据库连接池实现技术，由阿里巴巴提供的


4. C3P0：数据库连接池技术
    * 步骤：
        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
            * 不要忘记导入数据库驱动jar包
        2. 定义配置文件：
            * 名称： c3p0.properties 或者 c3p0-config.xml
            * 路径：直接将文件放在src目录下即可。

        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
        4. 获取连接： getConnection
    * 代码：
         //1.创建数据库连接池对象
        DataSource ds  = new ComboPooledDataSource();
        //2. 获取连接对象
        Connection conn = ds.getConnection();
5. Druid：数据库连接池实现技术，由阿里巴巴提供的
    1. 步骤：
        1. 导入jar包 druid-1.0.9.jar
        2. 定义配置文件：
            * 是properties形式的
            * 可以叫任意名称，可以放在任意目录下
        3. 加载配置文件。Properties
        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
        5. 获取连接：getConnection
    * 代码：
         //3.加载配置文件
        Properties pro = new Properties();
        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        pro.load(is);
        //4.获取连接池对象
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn = ds.getConnection();
    2. 定义工具类
        1. 定义一个类 JDBCUtils
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法：通过数据库连接池获取连接
            2. 释放资源
            3. 获取连接池的方法


    * 代码：
        public class JDBCUtils &#123;

            //1.定义成员变量 DataSource
            private static DataSource ds ;
        
            static&#123;
                try &#123;
                    //1.加载配置文件
                    Properties pro = new Properties();
                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
                    //2.获取DataSource
                    ds = DruidDataSourceFactory.createDataSource(pro);
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        
            /**
             * 获取连接
             */
            public static Connection getConnection() throws SQLException &#123;
                return ds.getConnection();
            &#125;
        
            /**
             * 释放资源
             */
            public static void close(Statement stmt,Connection conn)&#123;
               /* if(stmt != null)&#123;
                    try &#123;
                        stmt.close();
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
        
                if(conn != null)&#123;
                    try &#123;
                        conn.close();//归还连接
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;*/
        
               close(null,stmt,conn);
            &#125;
</code></pre>
<p>​			<br>​			    public static void close(ResultSet rs , Statement stmt, Connection conn){</p>
<p>​			<br>​			        if(rs !&#x3D; null){<br>​			            try {<br>​			                rs.close();<br>​			            } catch (SQLException e) {<br>​			                e.printStackTrace();<br>​			            }<br>​			        }</p>
<p>​			<br>​			        if(stmt !&#x3D; null){<br>​			            try {<br>​			                stmt.close();<br>​			            } catch (SQLException e) {<br>​			                e.printStackTrace();<br>​			            }<br>​			        }<br>​			<br>                    if(conn !&#x3D; null){<br>                        try {<br>                            conn.close();&#x2F;&#x2F;归还连接<br>                        } catch (SQLException e) {<br>                            e.printStackTrace();<br>                        }<br>                    }<br>                }</p>
<pre><code>            /**
             * 获取连接池方法
             */
        
            public static DataSource getDataSource()&#123;
                return  ds;
            &#125;
        
        &#125;
</code></pre>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发
* 步骤：
    1. 导入jar包
    2. 创建JdbcTemplate对象。依赖于数据源DataSource
        * JdbcTemplate template = new JdbcTemplate(ds);

    3. 调用JdbcTemplate的方法来完成CRUD的操作
        * update():执行DML语句。增、删、改语句
        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
            * 注意：这个方法查询的结果集长度只能是1
        * queryForList():查询结果将结果集封装为list集合
            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
        * query():查询结果，将结果封装为JavaBean对象
            * query的参数：RowMapper
                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)
        * queryForObject：查询结果，将结果封装为对象
            * 一般用于聚合函数的查询

    4. 练习：
        * 需求：
            1. 修改1号数据的 salary 为 10000
            2. 添加一条记录
            3. 删除刚才添加的记录
            4. 查询id为1的记录，将其封装为Map集合
            5. 查询所有记录，将其封装为List
            6. 查询所有记录，将其封装为Emp对象的List集合
            7. 查询总记录数

        * 代码：
            
            import cn.itcast.domain.Emp;
            import cn.itcast.utils.JDBCUtils;
            import org.junit.Test;
            import org.springframework.jdbc.core.BeanPropertyRowMapper;
            import org.springframework.jdbc.core.JdbcTemplate;
            import org.springframework.jdbc.core.RowMapper;
            
            import java.sql.Date;
            import java.sql.ResultSet;
            import java.sql.SQLException;
            import java.util.List;
            import java.util.Map;
            
            public class JdbcTemplateDemo2 &#123;
            
                //Junit单元测试，可以让方法独立执行
</code></pre>
<p>​				<br>​				    &#x2F;&#x2F;1. 获取JDBCTemplate对象<br>​				    private JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());<br>​				    &#x2F;**<br>​				     * 1. 修改1号数据的 salary 为 10000<br>​				     *&#x2F;<br>​				    @Test<br>​				    public void test1(){<br>​				<br>                        &#x2F;&#x2F;2. 定义sql<br>                        String sql &#x3D; “update emp set salary &#x3D; 10000 where id &#x3D; 1001”;<br>                        &#x2F;&#x2F;3. 执行sql<br>                        int count &#x3D; template.update(sql);<br>                        System.out.println(count);<br>                    }</p>
<pre><code>                /**
                 * 2. 添加一条记录
                 */
                @Test
                public void test2()&#123;
                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;
                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);
                    System.out.println(count);
            
                &#125;
            
                /**
                 * 3.删除刚才添加的记录
                 */
                @Test
                public void test3()&#123;
                    String sql = &quot;delete from emp where id = ?&quot;;
                    int count = template.update(sql, 1015);
                    System.out.println(count);
                &#125;
            
                /**
                 * 4.查询id为1001的记录，将其封装为Map集合
                 * 注意：这个方法查询的结果集长度只能是1
                 */
                @Test
                public void test4()&#123;
                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;
                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
                    System.out.println(map);
                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;
            
                &#125;
            
                /**
                 * 5. 查询所有记录，将其封装为List
                 */
                @Test
                public void test5()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);
            
                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;
                        System.out.println(stringObjectMap);
                    &#125;
                &#125;
            
                /**
                 * 6. 查询所有记录，将其封装为Emp对象的List集合
                 */
            
                @Test
                public void test6()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;
            
                        @Override
                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;
                            Emp emp = new Emp();
                            int id = rs.getInt(&quot;id&quot;);
                            String ename = rs.getString(&quot;ename&quot;);
                            int job_id = rs.getInt(&quot;job_id&quot;);
                            int mgr = rs.getInt(&quot;mgr&quot;);
                            Date joindate = rs.getDate(&quot;joindate&quot;);
                            double salary = rs.getDouble(&quot;salary&quot;);
                            double bonus = rs.getDouble(&quot;bonus&quot;);
                            int dept_id = rs.getInt(&quot;dept_id&quot;);
            
                            emp.setId(id);
                            emp.setEname(ename);
                            emp.setJob_id(job_id);
                            emp.setMgr(mgr);
                            emp.setJoindate(joindate);
                            emp.setSalary(salary);
                            emp.setBonus(bonus);
                            emp.setDept_id(dept_id);
            
                            return emp;
                        &#125;
                    &#125;);
</code></pre>
<p>​				<br>​				        for (Emp emp : list) {<br>​				            System.out.println(emp);<br>​				        }<br>​				    }<br>​				<br>                    &#x2F;**<br>                     * 6. 查询所有记录，将其封装为Emp对象的List集合<br>                     *&#x2F;</p>
<pre><code>                @Test
                public void test6_2()&#123;
                    String sql = &quot;select * from emp&quot;;
                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
                    for (Emp emp : list) &#123;
                        System.out.println(emp);
                    &#125;
                &#125;
            
                /**
                 * 7. 查询总记录数
                 */
            
                @Test
                public void test7()&#123;
                    String sql = &quot;select count(id) from emp&quot;;
                    Long total = template.queryForObject(sql, Long.class);
                    System.out.println(total);
                &#125;
            
            &#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反编译 class 文件</title>
    <url>/posts/81406da.html</url>
    <content><![CDATA[<h3 id="反编译-class-文件"><a href="#反编译-class-文件" class="headerlink" title="反编译 class 文件"></a>反编译 class 文件</h3><p>1.找到项目结构 </p>
<p>project → project compiler output</p>
<p>2.打开输出out文件夹 把要反编译的class文件拖进</p>
<p>3.在idea项目内就可以打开反编译文件了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方 法</title>
    <url>/posts/69244af4.html</url>
    <content><![CDATA[<h3 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//系统的类.对象.方法</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<h4 id="方法是语句的集合，它们在一起执行一个功能。"><a href="#方法是语句的集合，它们在一起执行一个功能。" class="headerlink" title="方法是语句的集合，它们在一起执行一个功能。"></a>方法是语句的集合，它们在一起执行一个功能。</h4><h5 id="1-方法是解决一类问题的步骤的有序组合"><a href="#1-方法是解决一类问题的步骤的有序组合" class="headerlink" title="1.方法是解决一类问题的步骤的有序组合"></a>1.方法是解决一类问题的步骤的有序组合</h5><h5 id="2-方法包含于类或对象中"><a href="#2-方法包含于类或对象中" class="headerlink" title="2.方法包含于类或对象中"></a>2.方法包含于类或对象中</h5><h5 id="3-方法在程序中被创建，在其他地方被引用"><a href="#3-方法在程序中被创建，在其他地方被引用" class="headerlink" title="3.方法在程序中被创建，在其他地方被引用"></a>3.方法在程序中被创建，在其他地方被引用</h5><h4 id="方法的原则"><a href="#方法的原则" class="headerlink" title="方法的原则"></a>方法的原则</h4><h5 id="方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。"><a href="#方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。" class="headerlink" title="方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。"></a>方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。</h5><p>方法的命名：小驼峰 或者大驼峰;</p>
<h3 id="java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法"><a href="#java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法" class="headerlink" title="java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法:"></a>java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法:</h3><h4 id="方法包含一个方法头和一个方法体，下面是一个方法的所有部分："><a href="#方法包含一个方法头和一个方法体，下面是一个方法的所有部分：" class="headerlink" title="方法包含一个方法头和一个方法体，下面是一个方法的所有部分："></a>方法包含一个方法头和一个方法体，下面是一个方法的所有部分：</h4><h5 id="修饰符：修饰符-这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。"><a href="#修饰符：修饰符-这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。" class="headerlink" title="修饰符：修饰符,这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。"></a>修饰符：修饰符,这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。</h5><h5 id="返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下-returnValueType-是关键字-void；"><a href="#返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下-returnValueType-是关键字-void；" class="headerlink" title="返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下,returnValueType 是关键字 void；"></a>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下,returnValueType 是关键字 void；</h5><h5 id="方法名：是方法的实际名称，方法名和参数表共同构成方法签名。"><a href="#方法名：是方法的实际名称，方法名和参数表共同构成方法签名。" class="headerlink" title="方法名：是方法的实际名称，方法名和参数表共同构成方法签名。"></a>方法名：是方法的实际名称，方法名和参数表共同构成方法签名。</h5><h5 id="参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。"><a href="#参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。" class="headerlink" title="参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。"></a>参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</h5><h5 id="形式参数-用来定义作用的-创建方法时用到。"><a href="#形式参数-用来定义作用的-创建方法时用到。" class="headerlink" title="形式参数: 用来定义作用的 创建方法时用到。"></a>形式参数: 用来定义作用的 创建方法时用到。</h5><h5 id="实际参数-实际调用传递过去的参数"><a href="#实际参数-实际调用传递过去的参数" class="headerlink" title="实际参数:实际调用传递过去的参数"></a>实际参数:实际调用传递过去的参数</h5><h5 id="方法体-方法下包含的代码实现功能"><a href="#方法体-方法下包含的代码实现功能" class="headerlink" title="方法体:方法下包含的代码实现功能"></a>方法体:方法下包含的代码实现功能</h5><h5 id="return-返回值-方法有传参一定要有返回值。他也是一种终止语句。"><a href="#return-返回值-方法有传参一定要有返回值。他也是一种终止语句。" class="headerlink" title="return : 返回值 方法有传参一定要有返回值。他也是一种终止语句。"></a>return : 返回值 方法有传参一定要有返回值。他也是一种终止语句。</h5><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="调用方法：对象名-方法名-实参列表"><a href="#调用方法：对象名-方法名-实参列表" class="headerlink" title="调用方法：对象名.方法名(实参列表)"></a>调用方法：对象名.方法名(实参列表)</h4><h5 id="Java方法支持两种调用方法的方式，根据方法是否返回值来选择。"><a href="#Java方法支持两种调用方法的方式，根据方法是否返回值来选择。" class="headerlink" title="Java方法支持两种调用方法的方式，根据方法是否返回值来选择。"></a>Java方法支持两种调用方法的方式，根据方法是否返回值来选择。</h5><h5 id="当方法返回一个值的时候，方法调用通常被当作一个值。例如"><a href="#当方法返回一个值的时候，方法调用通常被当作一个值。例如" class="headerlink" title="当方法返回一个值的时候，方法调用通常被当作一个值。例如:"></a>当方法返回一个值的时候，方法调用通常被当作一个值。例如:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">larger</span> <span class="operator">=</span> max(<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h5 id="如果方法返回值是void，方法调用一定是一条语句。"><a href="#如果方法返回值是void，方法调用一定是一条语句。" class="headerlink" title="如果方法返回值是void，方法调用一定是一条语句。"></a>如果方法返回值是void，方法调用一定是一条语句。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello,&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>“一个命令就像一个房间。“在 Java 编程语言中，命令不能单独存在。它是函数的一部分（在 Java 语言中，‘函数’也称为‘方法’）。方法是类的一分。换句话说，类被划分为多个方法，而方法被划分为多个命令。”</p>
<p>因此，类就是一个公寓楼，函数&#x2F;方法是一个公寓，而命令是一个房间。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方 法</title>
    <url>/posts/69244af4.html</url>
    <content><![CDATA[<h3 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//系统的类.对象.方法</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<h4 id="方法是语句的集合，它们在一起执行一个功能。"><a href="#方法是语句的集合，它们在一起执行一个功能。" class="headerlink" title="方法是语句的集合，它们在一起执行一个功能。"></a>方法是语句的集合，它们在一起执行一个功能。</h4><h5 id="1-方法是解决一类问题的步骤的有序组合"><a href="#1-方法是解决一类问题的步骤的有序组合" class="headerlink" title="1.方法是解决一类问题的步骤的有序组合"></a>1.方法是解决一类问题的步骤的有序组合</h5><h5 id="2-方法包含于类或对象中"><a href="#2-方法包含于类或对象中" class="headerlink" title="2.方法包含于类或对象中"></a>2.方法包含于类或对象中</h5><h5 id="3-方法在程序中被创建，在其他地方被引用"><a href="#3-方法在程序中被创建，在其他地方被引用" class="headerlink" title="3.方法在程序中被创建，在其他地方被引用"></a>3.方法在程序中被创建，在其他地方被引用</h5><h4 id="方法的原则"><a href="#方法的原则" class="headerlink" title="方法的原则"></a>方法的原则</h4><h5 id="方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。"><a href="#方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。" class="headerlink" title="方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。"></a>方法的本意是功能块，就是实现某个功能的语句块的集合，我们在设计方法的时候，最好保证方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。</h5><p>方法的命名：小驼峰 或者大驼峰;</p>
<h3 id="java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法"><a href="#java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法" class="headerlink" title="java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法:"></a>java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法:</h3><h4 id="方法包含一个方法头和一个方法体，下面是一个方法的所有部分："><a href="#方法包含一个方法头和一个方法体，下面是一个方法的所有部分：" class="headerlink" title="方法包含一个方法头和一个方法体，下面是一个方法的所有部分："></a>方法包含一个方法头和一个方法体，下面是一个方法的所有部分：</h4><h5 id="修饰符：修饰符-这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。"><a href="#修饰符：修饰符-这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。" class="headerlink" title="修饰符：修饰符,这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。"></a>修饰符：修饰符,这是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型。</h5><h5 id="返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下-returnValueType-是关键字-void；"><a href="#返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下-returnValueType-是关键字-void；" class="headerlink" title="返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下,returnValueType 是关键字 void；"></a>返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下,returnValueType 是关键字 void；</h5><h5 id="方法名：是方法的实际名称，方法名和参数表共同构成方法签名。"><a href="#方法名：是方法的实际名称，方法名和参数表共同构成方法签名。" class="headerlink" title="方法名：是方法的实际名称，方法名和参数表共同构成方法签名。"></a>方法名：是方法的实际名称，方法名和参数表共同构成方法签名。</h5><h5 id="参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。"><a href="#参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。" class="headerlink" title="参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。"></a>参数类型：参数像是一个占位符，当方法被调用时，传递值给参数。这个值称之为实参或者变量。参数列表是之方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</h5><h5 id="形式参数-用来定义作用的-创建方法时用到。"><a href="#形式参数-用来定义作用的-创建方法时用到。" class="headerlink" title="形式参数: 用来定义作用的 创建方法时用到。"></a>形式参数: 用来定义作用的 创建方法时用到。</h5><h5 id="实际参数-实际调用传递过去的参数"><a href="#实际参数-实际调用传递过去的参数" class="headerlink" title="实际参数:实际调用传递过去的参数"></a>实际参数:实际调用传递过去的参数</h5><h5 id="方法体-方法下包含的代码实现功能"><a href="#方法体-方法下包含的代码实现功能" class="headerlink" title="方法体:方法下包含的代码实现功能"></a>方法体:方法下包含的代码实现功能</h5><h5 id="return-返回值-方法有传参一定要有返回值。他也是一种终止语句。"><a href="#return-返回值-方法有传参一定要有返回值。他也是一种终止语句。" class="headerlink" title="return : 返回值 方法有传参一定要有返回值。他也是一种终止语句。"></a>return : 返回值 方法有传参一定要有返回值。他也是一种终止语句。</h5><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="调用方法：对象名-方法名-实参列表"><a href="#调用方法：对象名-方法名-实参列表" class="headerlink" title="调用方法：对象名.方法名(实参列表)"></a>调用方法：对象名.方法名(实参列表)</h4><h5 id="Java方法支持两种调用方法的方式，根据方法是否返回值来选择。"><a href="#Java方法支持两种调用方法的方式，根据方法是否返回值来选择。" class="headerlink" title="Java方法支持两种调用方法的方式，根据方法是否返回值来选择。"></a>Java方法支持两种调用方法的方式，根据方法是否返回值来选择。</h5><h5 id="当方法返回一个值的时候，方法调用通常被当作一个值。例如"><a href="#当方法返回一个值的时候，方法调用通常被当作一个值。例如" class="headerlink" title="当方法返回一个值的时候，方法调用通常被当作一个值。例如:"></a>当方法返回一个值的时候，方法调用通常被当作一个值。例如:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">larger</span> <span class="operator">=</span> max(<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h5 id="如果方法返回值是void，方法调用一定是一条语句。"><a href="#如果方法返回值是void，方法调用一定是一条语句。" class="headerlink" title="如果方法返回值是void，方法调用一定是一条语句。"></a>如果方法返回值是void，方法调用一定是一条语句。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello,&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>“一个命令就像一个房间。“在 Java 编程语言中，命令不能单独存在。它是函数的一部分（在 Java 语言中，‘函数’也称为‘方法’）。方法是类的一分。换句话说，类被划分为多个方法，而方法被划分为多个命令。”</p>
<p>因此，类就是一个公寓楼，函数&#x2F;方法是一个公寓，而命令是一个房间。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit、反射、注解</title>
    <url>/posts/61344af4.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. Junit单元测试
2. 反射
3. 注解
</code></pre>
<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><pre><code>* 测试分类：
    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
    2. 白盒测试：需要写代码的。关注程序具体的执行流程。

* Junit使用：白盒测试
    * 步骤：
        1. 定义一个测试类(测试用例)
            * 建议：
                * 测试类名：被测试的类名Test		CalculatorTest
                * 包名：xxx.xxx.xx.test		cn.itcast.test

        2. 定义测试方法：可以独立运行
            * 建议：
                * 方法名：test测试的方法名		testAdd()  
                * 返回值：void
                * 参数列表：空参

        3. 给方法加@Test
        4. 导入junit依赖环境

    * 判定结果：
        * 红色：失败
        * 绿色：成功
        * 一般我们会使用断言操作来处理结果
            * Assert.assertEquals(期望的结果,运算的结果);

    * 补充：
        * @Before:
            * 修饰的方法会在测试方法之前被自动执行
        * @After:
            * 修饰的方法会在测试方法执行之后自动被执行
</code></pre>
<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
    * 好处：
        1. 可以在程序运行过程中，操作这些对象。
        2. 可以解耦，提高程序的可扩展性。


* 获取Class对象的方式：
    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象
        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
    2. 类名.class：通过类名的属性class获取
        * 多用于参数的传递
    3. 对象.getClass()：getClass()方法在Object类中定义着。
        * 多用于对象的获取字节码的方式

    * 结论：
        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。


* Class对象功能：
    * 获取功能：
        1. 获取成员变量们
            * Field[] getFields() ：获取所有public修饰的成员变量
            * Field getField(String name)   获取指定名称的 public修饰的成员变量

            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
            * Field getDeclaredField(String name)  
        2. 获取构造方法们
            * Constructor&lt;?&gt;[] getConstructors()  
            * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  

            * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)  
            * Constructor&lt;?&gt;[] getDeclaredConstructors()  
        3. 获取成员方法们：
            * Method[] getMethods()  
            * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  

            * Method[] getDeclaredMethods()  
            * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)  

        4. 获取全类名	
            * String getName()  


* Field：成员变量
    * 操作：
        1. 设置值
            * void set(Object obj, Object value)  
        2. 获取值
            * get(Object obj) 

        3. 忽略访问权限修饰符的安全检查
            * setAccessible(true):暴力反射



* Constructor:构造方法
    * 创建对象：
        * T newInstance(Object... initargs)  

        * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


* Method：方法对象
    * 执行方法：
        * Object invoke(Object obj, Object... args)  

    * 获取方法名称：
        * String getName:获取方法名


* 案例：
    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法
        * 实现：
            1. 配置文件
            2. 反射
        * 步骤：
            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
            2. 在程序中加载读取配置文件
            3. 使用反射技术来加载类文件进内存
            4. 创建对象
            5. 执行方法
</code></pre>
<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><pre><code>* 概念：说明程序的。给计算机看的
* 注释：用文字描述程序的。给程序员看的

* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
* 概念描述：
    * JDK1.5之后的新特性
    * 说明程序的
    * 使用注解：@注解名称
</code></pre>
<p>​	</p>
<pre><code>* 作用分类：
    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】


* JDK中预定义的一些注解
    * @Override	：检测被该注解标注的方法是否是继承自父类(接口)的
    * @Deprecated：该注解标注的内容，表示已过时
    * @SuppressWarnings：压制警告
        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)

* 自定义注解
    * 格式：
        元注解
        public @interface 注解名称&#123;
            属性列表;
        &#125;

    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口
        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;

    * 属性：接口中的抽象方法
        * 要求：
            1. 属性的返回值类型有下列取值
                * 基本数据类型
                * String
                * 枚举
                * 注解
                * 以上类型的数组

            2. 定义了属性，在使用时需要给属性赋值
                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略
    
    * 元注解：用于描述注解的注解
        * @Target：描述注解能够作用的位置
            * ElementType取值：
                * TYPE：可以作用于类上
                * METHOD：可以作用于方法上
                * FIELD：可以作用于成员变量上
        * @Retention：描述注解被保留的阶段
            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
        * @Documented：描述注解是否被抽取到api文档中
        * @Inherited：描述注解是否被子类继承


* 在程序使用(解析)注解：获取注解中定义的属性值
    1. 获取注解定义的位置的对象  （Class，Method,Field）
    2. 获取指定的注解
        * getAnnotation(Class)
        //其实就是在内存中生成了一个该注解接口的子类实现对象

                public class ProImpl implements Pro&#123;
                    public String className()&#123;
                        return &quot;cn.itcast.annotation.Demo1&quot;;
                    &#125;
                    public String methodName()&#123;
                        return &quot;show&quot;;
                    &#125;
                &#125;
    3. 调用注解中的抽象方法获取配置的属性值


* 案例：简单的测试框架
* 小结：
    1. 以后大多数时候，我们会使用注解，而不是自定义注解
    2. 注解给谁用？
        1. 编译器
        2. 给解析程序用
    3. 注解不是程序的一部分，可以理解为注解就是一个标签
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/posts/bbcf5ff7.html</url>
    <content><![CDATA[<h1 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312347767.png"></p>
<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​	做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​	只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="comment">// 匿名内部类</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312347771.png"></p>
<p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312347788.png"></p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LambdaRunnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03ThreadInitParam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04ThreadNameless</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Comparator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       		<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07ComparatorLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          	<span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08InvokeCalc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line">      	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础笔记</title>
    <url>/posts/e5d60199.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol>
<li><p>数据库的基本概念</p>
</li>
<li><p>MySQL数据库软件</p>
<ol>
<li>安装</li>
<li>卸载</li>
<li>配置</li>
</ol>
</li>
<li><p>SQL</p>
</li>
</ol>
<h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB
2. 什么数据库？
    * 用于存储和管理数据的仓库。

3. 数据库的特点：
    1. 持久化存储数据的。其实数据库就是一个文件系统
    2. 方便存储和管理数据
    3. 使用了统一的方式操作数据库 -- SQL
</code></pre>
<p>​	</p>
<pre><code>4. 常见的数据库软件
    * 参见《MySQL基础.pdf》
</code></pre>
<h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装
    * 参见《MySQL基础.pdf》
2. 卸载
    1. 去mysql的安装目录找到my.ini文件
        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
    2. 卸载MySQL
    3. 删除C:/ProgramData目录下的MySQL文件夹。
    
3. 配置
    * MySQL服务启动
        1. 手动。
        2. cmd--&gt; services.msc 打开服务的窗口
        3. 使用管理员打开cmd
            * net start mysql : 启动mysql的服务
            * net stop mysql:关闭mysql服务
    * MySQL登录
        1. mysql -uroot -p密码
        2. mysql -hip -uroot -p连接目标的密码
        3. mysql --host=ip --user=root --password=连接目标的密码
    * MySQL退出
        1. exit
        2. quit

    * MySQL目录结构
        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;
            * 配置文件 my.ini
        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
            * 几个概念
                * 数据库：文件夹
                * 表：文件
                * 数据：数据
</code></pre>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？
    Structured Query Language：结构化查询语言
    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。
    
2.SQL通用语法
    1. SQL 语句可以单行或多行书写，以分号结尾。
    2. 可使用空格和缩进来增强语句的可读性。
    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
    4. 3 种注释
        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
        * 多行注释: /* 注释 */
    
3. SQL分类
    1) DDL(Data Definition Language)数据定义语言
        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
    2) DML(Data Manipulation Language)数据操作语言
        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
    3) DQL(Data Query Language)数据查询语言
        用来查询数据库中表的记录(数据)。关键字：select, where 等
    4) DCL(Data Control Language)数据控制语言(了解)
        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等
</code></pre>
<h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD
    1. C(Create):创建
        * 创建数据库：
            * create database 数据库名称;
        * 创建数据库，判断不存在，再创建：
            * create database if not exists 数据库名称;
        * 创建数据库，并指定字符集
            * create database 数据库名称 character set 字符集名;

        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
            * create database if not exists db4 character set gbk;
    2. R(Retrieve)：查询
        * 查询所有数据库的名称:
            * show databases;
        * 查询某个数据库的字符集:查询某个数据库的创建语句
            * show create database 数据库名称;
    3. U(Update):修改
        * 修改数据库的字符集
            * alter database 数据库名称 character set 字符集名称;
    4. D(Delete):删除
        * 删除数据库
            * drop database 数据库名称;
        * 判断数据库存在，存在再删除
            * drop database if exists 数据库名称;
    5. 使用数据库
        * 查询当前正在使用的数据库名称
            * select database();
        * 使用数据库
            * use 数据库名称;


2. 操作表
    1. C(Create):创建
        1. 语法：
            create table 表名(
                列名1 数据类型1,
                列名2 数据类型2,
                ....
                列名n 数据类型n
            );
            * 注意：最后一列，不需要加逗号（,）
            * 数据库类型：
                1. int：整数类型
                    * age int,
                2. double:小数类型
                    * score double(5,2)
                3. date:日期，只包含年月日，yyyy-MM-dd
                4. datetime:日期，包含年月日时分秒	 yyyy-MM-dd HH:mm:ss
                5. timestamp:时间错类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss	
                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值

                6. varchar：字符串
                    * name varchar(20):姓名最大20个字符
                    * zhangsan 8个字符  张三 2个字符


        * 创建表
            create table student(
                id int,
                name varchar(32),
                age int ,
                score double(4,1),
                birthday date,
                insert_time timestamp
            );
        * 复制表：
            * create table 表名 like 被复制的表名;	  	
    2. R(Retrieve)：查询
        * 查询某个数据库中所有的表名称
            * show tables;
        * 查询表结构
            * desc 表名;
    3. U(Update):修改
        1. 修改表名
            alter table 表名 rename to 新的表名;
        2. 修改表的字符集
            alter table 表名 character set 字符集名称;
        3. 添加一列
            alter table 表名 add 列名 数据类型;
        4. 修改列名称 类型
            alter table 表名 change 列名 新列别 新数据类型;
            alter table 表名 modify 列名 新数据类型;
        5. 删除列
            alter table 表名 drop 列名;
    4. D(Delete):删除
        * drop table 表名;
        * drop table  if exists 表名 ;
</code></pre>
<ul>
<li>客户端图形化工具：SQLYog</li>
</ul>
<h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：
    * 语法：
        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
    * 注意：
        1. 列名和值要一一对应。
        2. 如果表名后，不定义列名，则默认给所有列添加值
            insert into 表名 values(值1,值2,...值n);
        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
2. 删除数据：
    * 语法：
        * delete from 表名 [where 条件]
    * 注意：
        1. 如果不加条件，则删除表中所有记录。
        2. 如果要删除所有记录
            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
3. 修改数据：
    * 语法：
        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

    * 注意：
        1. 如果不加任何条件，则会将表中所有记录全部修改。
</code></pre>
<h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;

1. 语法：
    select
        字段列表
    from
        表名列表
    where
        条件列表
    group by
        分组字段
    having
        分组之后的条件
    order by
        排序
    limit
        分页限定


2. 基础查询
    1. 多个字段的查询
        select 字段名1，字段名2... from 表名；
        * 注意：
            * 如果查询所有字段，则可以使用*来替代字段列表。
    2. 去除重复：
        * distinct
    3. 计算列
        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
            * 表达式1：哪个字段需要判断是否为null
            * 如果该字段为null后的替换值。
    4. 起别名：
        * as：as也可以省略


3. 条件查询
    1. where子句后跟条件
    2. 运算符
        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;
        * BETWEEN...AND  
        * IN( 集合) 
        * LIKE：模糊查询
            * 占位符：
                * _:单个任意字符
                * %：多个任意字符
        * IS NULL  
        * and  或 &amp;&amp;
        * or  或 || 
        * not  或 !
        
            -- 查询年龄大于20岁

            SELECT * FROM student WHERE age &gt; 20;
            
            SELECT * FROM student WHERE age &gt;= 20;
            
            -- 查询年龄等于20岁
            SELECT * FROM student WHERE age = 20;
            
            -- 查询年龄不等于20岁
            SELECT * FROM student WHERE age != 20;
            SELECT * FROM student WHERE age &lt;&gt; 20;
            
            -- 查询年龄大于等于20 小于等于30
            
            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;
            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;
            SELECT * FROM student WHERE age BETWEEN 20 AND 30;
            
            -- 查询年龄22岁，18岁，25岁的信息
            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25
            SELECT * FROM student WHERE age IN (22,18,25);
            
            -- 查询英语成绩为null
            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断
            
            SELECT * FROM student WHERE english IS NULL;
            
            -- 查询英语成绩不为null
            SELECT * FROM student WHERE english  IS NOT NULL;



            -- 查询姓马的有哪些？ like
            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;
            -- 查询姓名第二个字是化的人
            
            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;
            
            -- 查询姓名是3个字的人
            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;
</code></pre>
<p>​				</p>
<pre><code>            -- 查询姓名中包含德的人
            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;
</code></pre>
<p>​	</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL多表查询和事务</title>
    <url>/posts/983a747a.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 多表查询

2. 事务

3. DCL
</code></pre>
<h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：
    select
        列名列表
    from
        表名列表
    where....
* 准备sql
    # 创建部门表
    CREATE TABLE dept(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(20)
    );
    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);
    # 创建员工表
    CREATE TABLE emp (
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(10),
        gender CHAR(1), -- 性别
        salary DOUBLE, -- 工资
        join_date DATE, -- 入职日期
        dept_id INT,
        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
    );
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);
* 笛卡尔积：
    * 有两个集合A,B .取这两个集合的所有组成情况。
    * 要完成多表查询，需要消除无用的数据
* 多表查询的分类：
    1. 内连接查询：
        1. 隐式内连接：使用where条件消除无用数据
            * 例子：
            -- 查询所有员工信息和对应的部门信息

            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;
            
            -- 查询员工表的名称，性别。部门表的名称
            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;
            
            SELECT 
                t1.name, -- 员工表的姓名
                t1.gender,-- 员工表的性别
                t2.name -- 部门表的名称
            FROM
                emp t1,
                dept t2
            WHERE 
                t1.`dept_id` = t2.`id`;
</code></pre>
<p>​	</p>
<pre><code>        2. 显式内连接：
            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
            * 例如：
                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	
                * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	

        3. 内连接查询：
            1. 从哪些表中查询数据
            2. 条件是什么
            3. 查询哪些字段
    2. 外链接查询：
        1. 左外连接：
            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
            * 查询的是左表所有数据以及其交集部分。
            * 例子：
                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
                SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
        2. 右外连接：
            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；
            * 查询的是右表所有数据以及其交集部分。
            * 例子：
                SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;
    3. 子查询：
        * 概念：查询中嵌套查询，称嵌套查询为子查询。
            -- 查询工资最高的员工信息
            -- 1 查询最高的工资是多少 9000
            SELECT MAX(salary) FROM emp;
            
            -- 2 查询员工信息，并且工资等于9000的
            SELECT * FROM emp WHERE emp.`salary` = 9000;
            
            -- 一条sql就完成这个操作。子查询
            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);

        * 子查询不同情况
            1. 子查询的结果是单行单列的：
                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =
                * 
                -- 查询员工工资小于平均工资的人
                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);
            2. 子查询的结果是多行单列的：
                * 子查询可以作为条件，使用运算符in来判断
                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息
                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;
                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
                -- 子查询
                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);

            3. 子查询的结果是多行多列的：
                * 子查询可以作为一张虚拟表参与查询
                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
                -- 子查询
                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2
                WHERE t1.id = t2.dept_id;
                
                -- 普通内连接
                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;

    * 多表查询练习

            -- 部门表
            CREATE TABLE dept (
              id INT PRIMARY KEY PRIMARY KEY, -- 部门id
              dname VARCHAR(50), -- 部门名称
              loc VARCHAR(50) -- 部门所在地
            );
            
            -- 添加4个部门
            INSERT INTO dept(id,dname,loc) VALUES 
            (10,&#39;教研部&#39;,&#39;北京&#39;),
            (20,&#39;学工部&#39;,&#39;上海&#39;),
            (30,&#39;销售部&#39;,&#39;广州&#39;),
            (40,&#39;财务部&#39;,&#39;深圳&#39;);
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 职务表，职务名称，职务描述
            CREATE TABLE job (
              id INT PRIMARY KEY,
              jname VARCHAR(20),
              description VARCHAR(50)
            );
            
            -- 添加4个职务
            INSERT INTO job (id, jname, description) VALUES
            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),
            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),
            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),
            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 员工表
            CREATE TABLE emp (
              id INT PRIMARY KEY, -- 员工id
              ename VARCHAR(50), -- 员工姓名
              job_id INT, -- 职务id
              mgr INT , -- 上级领导
              joindate DATE, -- 入职日期
              salary DECIMAL(7,2), -- 工资
              bonus DECIMAL(7,2), -- 奖金
              dept_id INT, -- 所在部门编号
              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
            );
            
            -- 添加员工
            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
            (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),
            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),
            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),
            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),
            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),
            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),
            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),
            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),
            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),
            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),
            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),
            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),
            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),
            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 工资等级表
            CREATE TABLE salarygrade (
              grade INT PRIMARY KEY,   -- 级别
              losalary INT,  -- 最低工资
              hisalary INT -- 最高工资
            );
            
            -- 添加5个工资等级
            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
            (1,7000,12000),
            (2,12010,14000),
            (3,14010,20000),
            (4,20010,30000),
            (5,30010,99990);
            
            -- 需求：
            
            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
            /*
                分析：
                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表
                    2.查询条件 emp.job_id = job.id
            
            */
            SELECT 
                t1.`id`, -- 员工编号
                t1.`ename`, -- 员工姓名
                t1.`salary`,-- 工资
                t2.`jname`, -- 职务名称
                t2.`description` -- 职务描述
            FROM 
                emp t1, job t2
            WHERE 
                t1.`job_id` = t2.`id`;
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
            /*
                分析：
                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept
                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id
            */
            
            SELECT 
                t1.`id`, -- 员工编号
                t1.`ename`, -- 员工姓名
                t1.`salary`,-- 工资
                t2.`jname`, -- 职务名称
                t2.`description`, -- 职务描述
                t3.`dname`, -- 部门名称
                t3.`loc` -- 部门位置
            FROM 
                emp t1, job t2,dept t3
            WHERE 
                t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;
               
            -- 3.查询员工姓名，工资，工资等级
            /*
                分析：
                    1.员工姓名，工资 emp  工资等级 salarygrade
                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary
                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
            */
            SELECT 
                t1.ename ,
                t1.`salary`,
                t2.*
            FROM emp t1, salarygrade t2
            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
            /*
                分析：
                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade
                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
                        
            */
            SELECT 
                t1.`ename`,
                t1.`salary`,
                t2.`jname`,
                t2.`description`,
                t3.`dname`,
                t3.`loc`,
                t4.`grade`
            FROM 
                emp t1,job t2,dept t3,salarygrade t4
            WHERE 
                t1.`job_id` = t2.`id` 
                AND t1.`dept_id` = t3.`id`
                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;
</code></pre>
<p>​				<br>​				</p>
<pre><code>            -- 5.查询出部门编号、部门名称、部门位置、部门人数
            
            /*
                分析：
                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表
                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)
                    3.使用子查询将第2步的查询结果和dept表进行关联查询
                    
            */
            SELECT 
                t1.`id`,t1.`dname`,t1.`loc` , t2.total
            FROM 
                dept t1,
                (SELECT
                    dept_id,COUNT(id) total
                FROM 
                    emp
                GROUP BY dept_id) t2
            WHERE t1.`id` = t2.dept_id;
</code></pre>
<p>​				</p>
<pre><code>            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
            
            /*
                分析：
                    1.姓名 emp， 直接上级的姓名 emp
                        * emp表的id 和 mgr 是自关联
                    2.条件 emp.id = emp.mgr
                    3.查询左表的所有数据，和 交集数据
                        * 使用左外连接查询
                
            */
            /*
            select
                t1.ename,
                t1.mgr,
                t2.`id`,
                t2.ename
            from emp t1, emp t2
            where t1.mgr = t2.`id`;
            
            */
            
            SELECT 
                t1.ename,
                t1.mgr,
                t2.`id`,
                t2.`ename`
            FROM emp t1
            LEFT JOIN emp t2
            ON t1.`mgr` = t2.`id`;
</code></pre>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍
    1. 概念：
        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
        
    2. 操作：
        1. 开启事务： start transaction;
        2. 回滚：rollback;
        3. 提交：commit;
    3. 例子：
        CREATE TABLE account (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(10),
            balance DOUBLE
        );
        -- 添加数据
        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);
</code></pre>
<p>​			</p>
<pre><code>        SELECT * FROM account;
        UPDATE account SET balance = 1000;
        -- 张三给李四转账 500 元
        
        -- 0. 开启事务
        START TRANSACTION;
        -- 1. 张三账户 -500
        
        UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;
        -- 2. 李四账户 +500
        -- 出错了...
        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;
        
        -- 发现执行没有问题，提交事务
        COMMIT;
        
        -- 发现出问题了，回滚事务
        ROLLBACK;
    4. MySQL数据库中事务默认自动提交
        
        * 事务提交的两种方式：
            * 自动提交：
                * mysql就是自动提交的
                * 一条DML(增删改)语句会自动提交一次事务。
            * 手动提交：
                * Oracle 数据库默认是手动提交事务
                * 需要先开启事务，再提交
        * 修改事务的默认提交方式：
            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
            * 修改默认提交方式： set @@autocommit = 0;


2. 事务的四大特征：
    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
    3. 隔离性：多个事务之间。相互独立。
    4. 一致性：事务操作前后，数据总量不变
3. 事务的隔离级别（了解）
    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
    * 存在问题：
        1. 脏读：一个事务，读取到另一个事务中没有提交的数据
        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
    * 隔离级别：
        1. read uncommitted：读未提交
            * 产生的问题：脏读、不可重复读、幻读
        2. read committed：读已提交 （Oracle）
            * 产生的问题：不可重复读、幻读
        3. repeatable read：可重复读 （MySQL默认）
            * 产生的问题：幻读
        4. serializable：串行化
            * 可以解决所有的问题

        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
        * 数据库查询隔离级别：
            * select @@tx_isolation;
        * 数据库设置隔离级别：
            * set global transaction isolation level  级别字符串;

    * 演示：
        set global transaction isolation level read uncommitted;
        start transaction;
        -- 转账操作
        update account set balance = balance - 500 where id = 1;
        update account set balance = balance + 500 where id = 2;
</code></pre>
<h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：
    1. DDL：操作数据库和表
    2. DML：增删改表中数据
    3. DQL：查询表中数据
    4. DCL：管理用户，授权

* DBA：数据库管理员

* DCL：管理用户，授权
    1. 管理用户
        1. 添加用户：
            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
        2. 删除用户：
            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;
        3. 修改用户密码：
            
            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;
            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;
            
            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);
            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);

            * mysql中忘记了root用户的密码？
                1. cmd -- &gt; net stop mysql 停止mysql服务
                    * 需要管理员运行该cmd

                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                4. use mysql;
                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
                6. 关闭两个窗口
                7. 打开任务管理器，手动结束mysqld.exe 的进程
                8. 启动mysql服务
                9. 使用新密码登录。
        4. 查询用户：
            -- 1. 切换到mysql数据库
            USE myql;
            -- 2. 查询user表
            SELECT * FROM USER;
            
            * 通配符： % 表示可以在任意主机使用用户登录数据库

    2. 权限管理：
        1. 查询权限：
            -- 查询权限
            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;

        2. 授予权限：
            -- 授予权限
            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;
            -- 给张三用户授予所有权限，在任意数据库任意表上
            
            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;
        3. 撤销权限：
            -- 撤销权限：
            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;
            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL约束笔记</title>
    <url>/posts/973b63a3.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. DQL:查询语句
    1. 排序查询
    2. 聚合函数
    3. 分组查询
    4. 分页查询

2. 约束
3. 多表之间的关系
4. 范式
5. 数据库的备份和还原
</code></pre>
<h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询
    * 语法：order by 子句
        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...

    * 排序方式：
        * ASC：升序，默认的。
        * DESC：降序。

    * 注意：
        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。


2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。
    1. count：计算个数
        1. 一般选择非空的列：主键
        2. count(*)
    2. max：计算最大值
    3. min：计算最小值
    4. sum：计算和
    5. avg：计算平均值


    * 注意：聚合函数的计算，排除null值。
        解决方案：
            1. 选择不包含非空的列进行计算
            2. IFNULL函数

3. 分组查询:
    1. 语法：group by 分组字段；
    2. 注意：
        1. 分组之后查询的字段：分组字段、聚合函数
        2. where 和 having 的区别？
            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

        -- 按照性别分组。分别查询男、女同学的平均分

        SELECT sex , AVG(math) FROM student GROUP BY sex;
        
        -- 按照性别分组。分别查询男、女同学的平均分,人数
        
        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;
        
        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;
        
        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;
        
        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;
</code></pre>
<p>​			</p>
<pre><code>4. 分页查询
    1. 语法：limit 开始的索引,每页查询的条数;
    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
        -- 每页显示3条记录 

        SELECT * FROM student LIMIT 0,3; -- 第1页
        
        SELECT * FROM student LIMIT 3,3; -- 第2页
        
        SELECT * FROM student LIMIT 6,3; -- 第3页

    3. limit 是一个MySQL&quot;方言&quot;
</code></pre>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。	
* 分类：
    1. 主键约束：primary key
    2. 非空约束：not null
    3. 唯一约束：unique
    4. 外键约束：foreign key

* 非空约束：not null，某一列的值不能为null
    1. 创建表时添加约束
        CREATE TABLE stu(
            id INT,
            NAME VARCHAR(20) NOT NULL -- name为非空
        );
    2. 创建表完后，添加非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;

    3. 删除name的非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20);

* 唯一约束：unique，某一列的值不能重复
    1. 注意：
        * 唯一约束可以有NULL值，但是只能有一条记录为null
    2. 在创建表时，添加唯一约束
        CREATE TABLE stu(
            id INT,
            phone_number VARCHAR(20) UNIQUE -- 手机号
        );
    3. 删除唯一约束
        ALTER TABLE stu DROP INDEX phone_number;
    4. 在表创建完后，添加唯一约束
        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;

* 主键约束：primary key。
    1. 注意：
        1. 含义：非空且唯一
        2. 一张表只能有一个字段为主键
        3. 主键就是表中记录的唯一标识

    2. 在创建表时，添加主键约束
        create table stu(
            id int primary key,-- 给id添加主键约束
            name varchar(20)
        );

    3. 删除主键
        -- 错误 alter table stu modify id int ;
        ALTER TABLE stu DROP PRIMARY KEY;

    4. 创建完表后，添加主键
        ALTER TABLE stu MODIFY id INT PRIMARY KEY;

    5. 自动增长：
        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长

        2. 在创建表时，添加主键约束，并且完成主键自增长
        create table stu(
            id int primary key auto_increment,-- 给id添加主键约束
            name varchar(20)
        );
</code></pre>
<p>​			</p>
<pre><code>        3. 删除自动增长
        ALTER TABLE stu MODIFY id INT;
        4. 添加自动增长
        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;


* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。
    1. 在创建表时，可以添加外键
        * 语法：
            create table 表名(
                ....
                外键列
                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
            );

    2. 删除外键
        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;

    3. 创建表之后，添加外键
        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);
</code></pre>
<p>​		</p>
<pre><code>    4. 级联操作
        1. 添加级联操作
            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
                    FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;
        2. 分类：
            1. 级联更新：ON UPDATE CASCADE 
            2. 级联删除：ON DELETE CASCADE 
</code></pre>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系
    1. 分类：
        1. 一对一(了解)：
            * 如：人和身份证
            * 分析：一个人只有一个身份证，一个身份证只能对应一个人
        2. 一对多(多对一)：
            * 如：部门和员工
            * 分析：一个部门有多个员工，一个员工只能对应一个部门
        3. 多对多：
            * 如：学生和课程
            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
    2. 实现关系：
        1. 一对多(多对一)：
            * 如：部门和员工
            * 实现方式：在多的一方建立外键，指向一的一方的主键。
        2. 多对多：
            * 如：学生和课程
            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键
        3. 一对一(了解)：
            * 如：人和身份证
            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。

    3. 案例
        -- 创建旅游线路分类表 tab_category
        -- cid 旅游线路分类主键，自动增长
        -- cname 旅游线路分类名称非空，唯一，字符串 100
        CREATE TABLE tab_category (
            cid INT PRIMARY KEY AUTO_INCREMENT,
            cname VARCHAR(100) NOT NULL UNIQUE
        );
        
        -- 创建旅游线路表 tab_route
        /*
        rid 旅游线路主键，自动增长
        rname 旅游线路名称非空，唯一，字符串 100
        price 价格
        rdate 上架时间，日期类型
        cid 外键，所属分类
        */
        CREATE TABLE tab_route(
            rid INT PRIMARY KEY AUTO_INCREMENT,
            rname VARCHAR(100) NOT NULL UNIQUE,
            price DOUBLE,
            rdate DATE,
            cid INT,
            FOREIGN KEY (cid) REFERENCES tab_category(cid)
        );
        
        /*创建用户表 tab_user
        uid 用户主键，自增长
        username 用户名长度 100，唯一，非空
        password 密码长度 30，非空
        name 真实姓名长度 100
        birthday 生日
        sex 性别，定长字符串 1
        telephone 手机号，字符串 11
        email 邮箱，字符串长度 100
        */
        CREATE TABLE tab_user (
            uid INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(100) UNIQUE NOT NULL,
            PASSWORD VARCHAR(30) NOT NULL,
            NAME VARCHAR(100),
            birthday DATE,
            sex CHAR(1) DEFAULT &#39;男&#39;,
            telephone VARCHAR(11),
            email VARCHAR(100)
        );
        
        /*
        创建收藏表 tab_favorite
        rid 旅游线路 id，外键
        date 收藏时间
        uid 用户 id，外键
        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
        */
        CREATE TABLE tab_favorite (
            rid INT, -- 线路id
            DATE DATETIME,
            uid INT, -- 用户id
            -- 创建复合主键
            PRIMARY KEY(rid,uid), -- 联合主键
            FOREIGN KEY (rid) REFERENCES tab_route(rid),
            FOREIGN KEY(uid) REFERENCES tab_user(uid)
        );
</code></pre>
<p>​		</p>
<pre><code>2. 数据库设计的范式
    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求

        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

    * 分类：
        1. 第一范式（1NF）：每一列都是不可分割的原子数据项
        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）
            * 几个概念：
                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数
                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
                    例如：（学号，课程名称） --&gt; 分数
                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
                    例如：（学号，课程名称） -- &gt; 姓名
                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
                    例如：学号--&gt;系名，系名--&gt;系主任
                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
                    例如：该表中码为：（学号，课程名称）
                    * 主属性：码属性组中的所有属性
                    * 非主属性：除过码属性组的属性
                    
        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
</code></pre>
<h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：
    * 语法：
        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径
        * 还原：
            1. 登录数据库
            2. 创建数据库
            3. 使用数据库
            4. 执行文件。source 文件路径
2. 图形化工具：
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Scanner对象</title>
    <url>/posts/e2abe5ec.html</url>
    <content><![CDATA[<h3 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h3><h4 id="是实现人机交互的工具类，通过Scanner类来获取用户的输入。"><a href="#是实现人机交互的工具类，通过Scanner类来获取用户的输入。" class="headerlink" title="是实现人机交互的工具类，通过Scanner类来获取用户的输入。"></a>是实现人机交互的工具类，通过Scanner类来获取用户的输入。</h4><h4 id="基本的语法："><a href="#基本的语法：" class="headerlink" title="基本的语法："></a>基本的语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个扫描器对象，用于接收键盘数据</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br></pre></td></tr></table></figure>

<h4 id="通过Scanner类的next-与nextLine-方法获取输入的字符串，在读取前我们一般需要使用-hasNext-与hasNextLine-来判断是否还有输入的数据"><a href="#通过Scanner类的next-与nextLine-方法获取输入的字符串，在读取前我们一般需要使用-hasNext-与hasNextLine-来判断是否还有输入的数据" class="headerlink" title="通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()来判断是否还有输入的数据"></a>通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()来判断是否还有输入的数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断用户有没有输入字符</span></span><br><span class="line"><span class="keyword">if</span>(Scanner.hasNext())&#123;</span><br><span class="line"><span class="comment">//使用next方式接收</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Scanner.next();</span><br><span class="line">System.out.println(<span class="string">&quot;输出的内容为&quot;</span>+str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//凡是属于IO流的泪如果不关闭会一直占用资源，要养成好习惯用完就关掉</span></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure>

<h5 id="next"><a href="#next" class="headerlink" title="next():"></a>next():</h5><h5 id="1-一定要读取到有效字符后才可以结束输入。"><a href="#1-一定要读取到有效字符后才可以结束输入。" class="headerlink" title="1. 一定要读取到有效字符后才可以结束输入。"></a>1. 一定要读取到有效字符后才可以结束输入。</h5><h5 id="2-对输入的有效字符之前遇到的空白，next-方法会自动将其去掉。"><a href="#2-对输入的有效字符之前遇到的空白，next-方法会自动将其去掉。" class="headerlink" title="2. 对输入的有效字符之前遇到的空白，next()方法会自动将其去掉。"></a>2. 对输入的有效字符之前遇到的空白，next()方法会自动将其去掉。</h5><h5 id="3-只要有输入有小字符后才将其后面输入的空白作为分隔符或者结束符。"><a href="#3-只要有输入有小字符后才将其后面输入的空白作为分隔符或者结束符。" class="headerlink" title="3. 只要有输入有小字符后才将其后面输入的空白作为分隔符或者结束符。"></a>3. 只要有输入有小字符后才将其后面输入的空白作为分隔符或者结束符。</h5><h5 id="4-next-不能得到带有空格的字符串。"><a href="#4-next-不能得到带有空格的字符串。" class="headerlink" title="4. next()不能得到带有空格的字符串。"></a>4. next()不能得到带有空格的字符串。</h5><h4 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine();"></a>nextLine();</h4><h5 id="1-以回车位结束符，也就是说nextLine-方法返回的是输入回车之前的所有字符。"><a href="#1-以回车位结束符，也就是说nextLine-方法返回的是输入回车之前的所有字符。" class="headerlink" title="1. 以回车位结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。"></a>1. 以回车位结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。</h5><h5 id="2-可以获得空白"><a href="#2-可以获得空白" class="headerlink" title="2. 可以获得空白"></a>2. 可以获得空白</h5>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>static的详情</title>
    <url>/posts/a6c6c4c.html</url>
    <content><![CDATA[<h3 id="Static静态"><a href="#Static静态" class="headerlink" title="Static静态"></a>Static静态</h3><h4 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h4><h5 id="import-static-java-lang-Math-random"><a href="#import-static-java-lang-Math-random" class="headerlink" title="import static java.lang.Math.random;"></a>import static java.lang.Math.random;</h5><h5 id="private-static-int-age-静态的变量"><a href="#private-static-int-age-静态的变量" class="headerlink" title="private static int age; &#x2F;&#x2F;静态的变量"></a>private static int age; &#x2F;&#x2F;静态的变量</h5><h5 id="private-double-score-非静态的变量"><a href="#private-double-score-非静态的变量" class="headerlink" title="private double score&#x2F;&#x2F; 非静态的变量"></a>private double score&#x2F;&#x2F; 非静态的变量</h5><h4 id="匿名代码块"><a href="#匿名代码块" class="headerlink" title="匿名代码块"></a>匿名代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//代码块（匿名代码块）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流</title>
    <url>/posts/69413af4.html</url>
    <content><![CDATA[<p><strong>day13【Stream流、方法引用】</strong> </p>
<p><strong>主要内容</strong> </p>
<p>Stream流 </p>
<p>方法引用 </p>
<p><strong>第一章</strong> <strong>Stream流</strong> </p>
<p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带 来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。 </p>
<p><strong>1.1</strong> <strong>引言</strong> </p>
<p><strong>传统集合的多步遍历代码</strong> </p>
<p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元 素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ForEach</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。 </p>
<p><strong>循环遍历的弊端</strong> </p>
<p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行 </p>
<p>了对比说明。现在，我们仔细体会一下上例代码，可以发现： </p>
<p>for循环的语法就是“<strong>怎么做</strong>” </p>
<p>for循环的循环体才是“<strong>做什么</strong>” </p>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。 </p>
<p>试想一下，如果希望对集合中的元素进行筛选过滤： </p>
<ol>
<li><p>将集合A根据条件一过滤为<strong>子集B</strong>； </p>
</li>
<li><p>然后再根据条件二过滤为<strong>子集C</strong>。</p>
</li>
</ol>
<p>那怎么办？在Java 8之前的做法可能为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02NormalFilter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">	List&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">					zhangList.add(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	List&lt;String&gt; shortList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">				shortList.add(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">for</span> (String name : shortList) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码中含有三个循环，每一个作用不同： </p>
<ol>
<li><p>首先筛选所有姓张的人； </p>
</li>
<li><p>然后筛选名字有三个字的人； </p>
</li>
<li><p>最后进行对结果进行打印输出。</p>
</li>
</ol>
<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。 </p>
<p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？ </p>
<p><strong>Stream的更优写法</strong> </p>
<p>下面来看一下借助Java 8的Stream API，什么才叫优雅： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03StreamFilter</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">				list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">				list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">				list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">				list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">				list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">				list.stream()</span><br><span class="line">			.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">			.filter(s ‐&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">			.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码 </p>
<p>中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 </p>
<p><strong>1.2</strong> <strong>流式思想概述</strong> </p>
<p><strong>注意：请暂时忘记对传统IO流的固有印象！</strong> </p>
<p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112131742105.jpg" alt="img"></p>
<p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤 </p>
<p>方案，然后再按照方案去执行它。 </p>
<p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模 </p>
<p>型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字 </p>
<p>3是最终结果。 </p>
<p>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count </p>
<p>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 </p>
<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 </p>
<p>元素（或其地址值）。 </p>
<p>Stream（流）是一个来自数据源的元素队列 </p>
<p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 </p>
<p><strong>数据源</strong> 流的来源。 可以是集合，数组 等。 </p>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征： </p>
<p><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（flfluent </p>
<p>style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 </p>
<p><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 </p>
<p>代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 </p>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 </p>
<p>果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以 </p>
<p>像链条一样排列，变成一个管道。 </p>
<p><strong>1.3</strong> <strong>获取流</strong> </p>
<p>java.util.stream.Stream<T> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） </p>
<p>获取一个流非常简单，有以下几种常用的方式： </p>
<p>所有的 Collection 集合都可以通过 stream 默认方法获取流； </p>
<p>Stream 接口的静态方法 of 可以获取数组对应的流。 </p>
<p><strong>根据Collection获取流</strong> </p>
<p>首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04GetStream</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream(); </span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream2 = set.stream(); </span><br><span class="line"></span><br><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream3 = vector.stream(); &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据Map获取流</strong> </p>
<p>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 </p>
<p>需要分key、value或entry等情况： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05GetStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">	Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">	Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>根据数组获取流</strong> </p>
<p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06GetStream</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			String[] array = &#123; <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张一元&quot;</span> &#125;;</span><br><span class="line">		Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。 </p>
<p><strong>1.4</strong> <strong>常用方法</strong> </p>
<p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p>
<p><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </p>
<p><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。 </p>
<p>备注：本小节之外的更多方法，请自行参考API文档。 </p>
<p><strong>逐一处理：forEach</strong> </p>
<p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>

<p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 </p>
<p><strong>复习Consumer接口</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。 Consumer接口中包含抽象方法<span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure>

<p><strong>基本使用：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamForEach</span> &#123; </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">			Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>); </span><br><span class="line">	stream.forEach(name‐&gt; System.out.println(name)); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过滤：fifilter</strong> </p>
<p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>

<p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 </p>
<p><strong>复习Predicate接口</strong> </p>
<p>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>

<p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 </p>
<p>将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。 </p>
<p><strong>基本使用</strong> </p>
<p>Stream流中的 filter 方法基本使用的代码如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07StreamFilter</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = original.filter(s‐&gt;s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 </p>
<p><strong>映射：map</strong> </p>
<p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream <span class="title function_">map</span><span class="params">(Function mapper)</span>;</span><br></pre></td></tr></table></figure>

<p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<p><strong>复习Function接口</strong> </p>
<p>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>; </span><br></pre></td></tr></table></figure>

<p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 </p>
<p><strong>基本使用</strong></p>
<p>Stream流中的 map 方法基本使用的代码如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08StreamMap</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;18&quot;</span>); </span><br><span class="line">		Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str)); &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。 </p>
<p><strong>统计个数：count</strong> </p>
<p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09StreamCount</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">	Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>); </span><br><span class="line">	Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)); </span><br><span class="line">		System.out.println(result.count()); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取用前几个：limit</strong> </p>
<p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>; </span><br></pre></td></tr></table></figure>

<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamLimit</span> &#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>); </span><br><span class="line"></span><br><span class="line">		Stream&lt;String&gt; result = original.limit(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">		System.out.println(result.count()); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳过前几个：skip</strong> </p>
<p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamSkip</span> &#123; </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">			Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>); </span><br><span class="line">			Stream&lt;String&gt; result = original.skip(<span class="number">2</span>); </span><br><span class="line">		System.out.println(result.count()); <span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合:concat</strong> </p>
<p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure>

<p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 </p>
<p>该方法的基本使用代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>); </span><br><span class="line">		Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>); </span><br><span class="line">Stream&lt;String&gt; result = Stream.concat(streamA, streamB); </span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.5</strong> <strong>练习：集合元素处理（传统方式）</strong> </p>
<p><strong>题目</strong></p>
<p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）<strong>依次</strong>进行以 </p>
<p>下若干操作步骤： </p>
<ol>
<li><p>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 </p>
</li>
<li><p>第一个队伍筛选之后只要前3个人；存储到一个新集合中。 </p>
</li>
<li><p>第二个队伍只要姓张的成员姓名；存储到一个新集合中。 </p>
</li>
<li><p>第二个队伍筛选之后不要前2个人；存储到一个新集合中。 </p>
</li>
<li><p>将两个队伍合并为一个队伍；存储到一个新集合中。 </p>
</li>
<li><p>根据姓名创建 Person 对象；存储到一个新集合中。 </p>
</li>
<li><p>打印整个队伍的Person对象信息。</p>
</li>
</ol>
<p>两个队伍（集合）的代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoArrayListNames</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//第一支队伍 </span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;迪丽热巴&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;宋远桥&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;苏星河&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;石破天&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;石中玉&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;老子&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;庄子&quot;</span>); </span><br><span class="line"></span><br><span class="line">one.add(<span class="string">&quot;洪七公&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二支队伍 </span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;古力娜扎&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;张无忌&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;赵丽颖&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;张三丰&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;尼古拉斯赵四&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;张天爱&quot;</span>); </span><br><span class="line"></span><br><span class="line">two.add(<span class="string">&quot;张二狗&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// .... </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>而 Person 类的代码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>既然使用传统的for循环写法，那么： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoArrayListNames</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">List&lt;String&gt; oneA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line"><span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">oneA.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">List&lt;String&gt; oneB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">oneB.add(oneA.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">List&lt;String&gt; twoA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line"><span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">twoA.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">List&lt;String&gt; twoB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; twoA.size(); i++) &#123;</span><br><span class="line">twoB.add(twoA.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">List&lt;String&gt; totalNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">totalNames.addAll(oneB);</span><br><span class="line">totalNames.addAll(twoB);</span><br><span class="line"><span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">List&lt;Person&gt; totalPersonList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : totalNames) &#123;</span><br><span class="line">totalPersonList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoArrayListNames</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">List&lt;String&gt; oneA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line"><span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">oneA.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">List&lt;String&gt; oneB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">oneB.add(oneA.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">List&lt;String&gt; twoA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line"><span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">twoA.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">List&lt;String&gt; twoB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; twoA.size(); i++) &#123;</span><br><span class="line">twoB.add(twoA.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">List&lt;String&gt; totalNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">totalNames.addAll(oneB);</span><br><span class="line">totalNames.addAll(twoB);</span><br><span class="line"><span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">List&lt;Person&gt; totalPersonList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : totalNames) &#123;</span><br><span class="line">totalPersonList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;宋远桥&#x27;</span>&#125; </span><br><span class="line">Person&#123;name=<span class="string">&#x27;苏星河&#x27;</span>&#125; </span><br><span class="line">Person&#123;name=<span class="string">&#x27;石破天&#x27;</span>&#125; </span><br><span class="line">Person&#123;name=<span class="string">&#x27;张天爱&#x27;</span>&#125; </span><br><span class="line">Person&#123;name=<span class="string">&#x27;张二狗&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.6</strong> <strong>练习：集合元素处理（Stream方式）</strong> </p>
<p><strong>题目</strong></p>
<p>将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， Person 类的定义也不 </p>
<p>变。</p>
<p><strong>解答</strong></p>
<p>等效的Stream流式处理代码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStreamNames</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line"><span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line"><span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line"><span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line"><span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果完全一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;宋远桥&#x27;</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;苏星河&#x27;</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;石破天&#x27;</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张天爱&#x27;</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张二狗&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第二章 方法引用</strong> </p>
<p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 </p>
<p>一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ </p>
<p><strong>2.1</strong> <strong>冗余的Lambda场景</strong> </p>
<p>来看一个简单的函数式接口以应用Lambda表达式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda 来使用它的代码很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01PrintSimple</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">printString(s ‐&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 printString 方法只管调用 Printable 接口的 print 方法，而并不管 print 方法的具体实现逻辑会将字符串打印到什么地方去。而 main 方法通过Lambda表达式指定了函数式接口 Printable 的具体操作方案为：<strong>拿到 String（类型可推导，所以可省略）数据后，在控制台中输出它</strong>。 </p>
<p><strong>2.2</strong> <strong>问题分析</strong> </p>
<p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 System.out 对象中的 println(String) 方法。既然Lambda希望做的事情就是调用 println(String) 方法，那何必自己手动调 用呢？ </p>
<p><strong>2.3</strong> <strong>用方法引用改进代码</strong> </p>
<p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02PrintRef</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span> &#123;</span><br><span class="line">data.print(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">printString(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意其中的双冒号 :: 写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。 </p>
<p><strong>2.4</strong> <strong>方法引用符</strong> </p>
<p>双冒号 :: 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方 法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 </p>
<p><strong>语义分析</strong> </p>
<p>例如上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效： </p>
<p>Lambda表达式写法： s -&gt; System.out.println(s); </p>
<p>方法引用写法： System.out::println </p>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。 </p>
<p>第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。 </p>
<p>注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常 </p>
<p><strong>推导与省略</strong> </p>
<p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrintableInteger</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> str)</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03PrintOverload</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInteger</span><span class="params">(PrintableInteger data)</span> &#123; </span><br><span class="line"></span><br><span class="line">data.print(<span class="number">1024</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">printInteger(System.out::println); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次方法引用将会自动匹配到 println(int) 的重载形式。 </p>
<p><strong>2.5</strong> <strong>通过对象名引用成员方法</strong> </p>
<p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefObject</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUpperCase</span><span class="params">(String str)</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(str.toUpperCase()); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口仍然定义为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了 MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04MethodRef</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">lambda.print(<span class="string">&quot;Hello&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">MethodRefObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRefObject</span>(); </span><br><span class="line"></span><br><span class="line">printString(obj::printUpperCase); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.6</strong> <strong>通过类名称引用静态方法</strong> </p>
<p>由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calcable</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种写法是使用Lambda表达式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Lambda</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(lambda.calc(num)); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">method(‐<span class="number">10</span>, n ‐&gt; Math.abs(n)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用方法引用的更好写法是： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06MethodRef</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> num, Calcable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(lambda.calc(num)); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">method(‐<span class="number">10</span>, Math::abs); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的： </p>
<p>Lambda表达式： n -&gt; Math.abs(n) </p>
<p>方法引用： Math::abs </p>
<p><strong>2.7</strong> <strong>通过super引用成员方法</strong> </p>
<p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greetable</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是父类 Human 的内容： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Hello!&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是子类 Man 的内容，其中使用了Lambda的写法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法method,参数传递Greetable接口 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123; </span><br><span class="line"></span><br><span class="line">g.greet(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用method方法,使用Lambda表达式 </span></span><br><span class="line"></span><br><span class="line">method(()‐&gt;&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Human对象,调用sayHello方法 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Human</span>().sayHello(); </span><br><span class="line"></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//简化Lambda </span></span><br><span class="line"></span><br><span class="line">method(()‐&gt;<span class="keyword">new</span> <span class="title class_">Human</span>().sayHello()); </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用super关键字代替父类对象 </span></span><br><span class="line"></span><br><span class="line">method(()‐&gt;<span class="built_in">super</span>.sayHello()); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman ： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;大家好,我是Man!&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法method,参数传递Greetable接口 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Greetable g)</span>&#123; </span><br><span class="line"></span><br><span class="line">g.greet(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123; </span><br><span class="line"></span><br><span class="line">method(<span class="built_in">super</span>::sayHello); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的： </p>
<p>Lambda表达式： () -&gt; super.sayHello() </p>
<p>方法引用： super::sayHello </p>
<p><strong>2.8</strong> <strong>通过this引用成员方法</strong> </p>
<p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“<strong>this::成员方法</strong>”的格式来使用方 </p>
<p>法引用。首先是简单的函数式接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Richable</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面是一个丈夫 Husband 类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">lambda.buy(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">marry(() ‐&gt; System.out.println(<span class="string">&quot;买套房子&quot;</span>)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。 </p>
<p>但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;买套房子&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">lambda.buy(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">marry(() ‐&gt; <span class="built_in">this</span>.buyHouse()); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;买套房子&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Richable lambda)</span> &#123; </span><br><span class="line"></span><br><span class="line">lambda.buy(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beHappy</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">marry(<span class="built_in">this</span>::buyHouse); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的： </p>
<p>Lambda表达式： () -&gt; this.buyHouse() </p>
<p>方法引用： this::buyHouse </p>
<p><strong>2.9</strong> <strong>类的构造器引用</strong> </p>
<p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单 </p>
<p>的 Person 类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是用来创建 Person 对象的函数式接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonBuilder</span> &#123; </span><br><span class="line"></span><br><span class="line">Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用这个函数式接口，可以通过Lambda表达式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09Lambda</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(builder.buildPerson(name).getName()); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">printName(<span class="string">&quot;赵丽颖&quot;</span>, name ‐&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过构造器引用，有更好的写法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10ConstructorRef</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder builder)</span> &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(builder.buildPerson(name).getName()); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line">printName(<span class="string">&quot;赵丽颖&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的： </p>
<p>Lambda表达式： name -&gt; new Person(name) </p>
<p>方法引用： Person::new </p>
<p><strong>2.10</strong> <strong>数组的构造器引用</strong> </p>
<p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， </p>
<p>需要一个函数式接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArrayBuilder</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] buildArray(<span class="type">int</span> length); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用该接口的时候，可以通过Lambda表达式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11ArrayInitRef</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder.buildArray(length); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] array = initArray(<span class="number">10</span>, length ‐&gt; <span class="keyword">new</span> <span class="title class_">int</span>[length]); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是更好的写法是使用数组的构造器引用： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12ArrayInitRef</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] initArray(<span class="type">int</span> length, ArrayBuilder builder) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder.buildArray(length); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] array = initArray(<span class="number">10</span>, <span class="type">int</span>[]::<span class="keyword">new</span>); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在这个例子中，下面两种写法是等效的： </p>
<p>Lambda表达式： length -&gt; new int[length] </p>
<p>方法引用： int[]::new</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方 法</title>
    <url>/posts/69244af4.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet&amp;&amp;Tomcat</title>
    <url>/posts/2683a04f.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web相关概念回顾
2. web服务器软件：Tomcat
3. Servlet入门学习
</code></pre>
<h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构
    1. C/S：客户端/服务器端
    2. B/S：浏览器/服务器端

2. 资源分类
    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析
        * 如： html,css,JavaScript
    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器
        * 如：servlet/jsp,php,asp....


3. 网络通信三要素
    1. IP：电子设备(计算机)在网络中的唯一标识。
    2. 端口：应用程序在计算机中的唯一标识。 0~65536
    3. 传输协议：规定了数据传输的规则
        1. 基础协议：
            1. tcp:安全协议，三次握手。 速度稍慢
            2. udp：不安全协议。 速度快
</code></pre>
<h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机
* 服务器软件：接收用户的请求，处理请求，做出响应
* web服务器软件：接收用户的请求，处理请求，做出响应。
    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
    * web容器


* 常见的java相关的web服务器软件：
    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。


* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范

* Tomcat：web服务器软件
    1. 下载：http://tomcat.apache.org/
    2. 安装：解压压缩包即可。
        * 注意：安装目录建议不要有中文和空格
    3. 卸载：删除目录就行了
    4. 启动：
        * bin/startup.bat ,双击运行该文件即可
        * 访问：浏览器输入：http://localhost:8080 回车访问自己
                          http://别人的ip:8080 访问别人
        
        * 可能遇到的问题：
            1. 黑窗口一闪而过：
                * 原因： 没有正确配置JAVA_HOME环境变量
                * 解决方案：正确配置JAVA_HOME环境变量

            2. 启动报错：
                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程
                    * netstat -ano
                2. 温柔：修改自身的端口号
                    * conf/server.xml
                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;
                       connectionTimeout=&quot;20000&quot;
                       redirectPort=&quot;8445&quot; /&gt;
                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。
                        * 好处：在访问时，就不用输入端口号
    5. 关闭：
        1. 正常关闭：
            * bin/shutdown.bat
            * ctrl+c
        2. 强制关闭：
            * 点击启动窗口的×
    6. 配置:
        * 部署项目的方式：
            1. 直接将项目放到webapps目录下即可。
                * /hello：项目的访问路径--&gt;虚拟目录
                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。
                    * war包会自动解压缩

            2. 配置conf/server.xml文件
                在&lt;Host&gt;标签体中配置
                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;
                * docBase:项目存放的路径
                * path：虚拟目录

            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写
                &lt;Context docBase=&quot;D:\hello&quot; /&gt;
                * 虚拟目录：xml文件的名称
        
        * 静态项目和动态项目：
            * 目录结构
                * java动态项目的目录结构：
                    -- 项目的根目录
                        -- WEB-INF目录：
                            -- web.xml：web项目的核心配置文件
                            -- classes目录：放置字节码文件的目录
                            -- lib目录：放置依赖的jar包


        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。
</code></pre>
<h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><pre><code>* 概念：运行在服务器端的小程序
    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法。


* 快速入门：
    1. 创建JavaEE项目
    2. 定义一个类，实现Servlet接口
        * public class ServletDemo1 implements Servlet
    3. 实现接口中的抽象方法
    4. 配置Servlet
         在web.xml中配置：
        &lt;!--配置Servlet --&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;
        &lt;/servlet&gt;
    
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

* 执行原理：
    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。
    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名
    4. tomcat会将字节码文件加载进内存，并且创建其对象
    5. 调用其方法

* Servlet中的生命周期方法：
    1. 被创建：执行init方法，只执行一次
        * Servlet什么时候被创建？
            * 默认情况下，第一次被访问时，Servlet被创建
            * 可以配置执行Servlet的创建时机。
                * 在&lt;servlet&gt;标签下配置
                    1. 第一次被访问时，创建
                		* &lt;load-on-startup&gt;的值为负数
                    2. 在服务器启动时，创建
                        * &lt;load-on-startup&gt;的值为0或正整数


        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
            * 多个用户同时访问时，可能存在线程安全问题。
            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

    2. 提供服务：执行service方法，执行多次
        * 每次访问Servlet时，Service方法都会被调用一次。
    3. 被销毁：执行destroy方法，只执行一次
        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁
        * 只有服务器正常关闭时，才会执行destroy方法。
        * destroy方法在Servlet被销毁之前执行，一般用于释放资源

* Servlet3.0：
    * 好处：
        * 支持注解配置。可以不需要web.xml了。

    * 步骤：
        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
        2. 定义一个类，实现Servlet接口
        3. 复写方法
        4. 在类上使用@WebServlet注解，进行配置
            * @WebServlet(&quot;资源路径&quot;)


            @Target(&#123;ElementType.TYPE&#125;)
            @Retention(RetentionPolicy.RUNTIME)
            @Documented
            public @interface WebServlet &#123;
                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;
            
                String[] value() default &#123;&#125;;//代表urlPatterns()属性配置
            
                String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;
            
                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;
            
                WebInitParam[] initParams() default &#123;&#125;;
            
                boolean asyncSupported() default false;
            
                String smallIcon() default &quot;&quot;;
            
                String largeIcon() default &quot;&quot;;
            
                String description() default &quot;&quot;;
            
                String displayName() default &quot;&quot;;
            &#125;
</code></pre>
<h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件
    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;

2. 工作空间项目    和     tomcat部署的web项目
    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源
    * WEB-INF目录下的资源不能被浏览器直接访问。
3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基本概念</title>
    <url>/posts/6b3156dd.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JDBC基本概念
2. 快速入门
3. 对JDBC中各个接口和类详解
</code></pre>
<h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库
    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

2. 快速入门：
    * 步骤：
        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
            2.右键--&gt;Add As Library
        2. 注册驱动
        3. 获取数据库连接对象 Connection
        4. 定义sql
        5. 获取执行sql语句的对象 Statement
        6. 执行sql，接受返回结果
        7. 处理结果
        8. 释放资源

    * 代码实现：
      	//1. 导入驱动jar包
        //2.注册驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //3.获取数据库连接对象
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);
        //4.定义sql语句
        String sql = &quot;update account set balance = 500 where id = 1&quot;;
        //5.获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        //6.执行sql
        int count = stmt.executeUpdate(sql);
        //7.处理结果
        System.out.println(count);
        //8.释放资源
        stmt.close();
        conn.close();

3. 详解各个对象：
    1. DriverManager：驱动管理对象
        * 功能：
            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar
                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
                写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
                 static &#123;
                        try &#123;
                            java.sql.DriverManager.registerDriver(new Driver());
                        &#125; catch (SQLException E) &#123;
                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);
                        &#125;
                    &#125;

                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。
            2. 获取数据库连接：
                * 方法：static Connection getConnection(String url, String user, String password) 
                * 参数：
                    * url：指定连接的路径
                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称
                        * 例子：jdbc:mysql://localhost:3306/db3
                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称
                    * user：用户名
                    * password：密码 
    2. Connection：数据库连接对象
        1. 功能：
            1. 获取执行sql 的对象
                * Statement createStatement()
                * PreparedStatement prepareStatement(String sql)  
            2. 管理事务：
                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
                * 提交事务：commit() 
                * 回滚事务：rollback() 
    3. Statement：执行sql的对象
        1. 执行sql
            1. boolean execute(String sql) ：可以执行任意的sql 了解 
            2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
        2. 练习：
            1. account表 添加一条记录
            2. account表 修改记录
            3. account表 删除一条记录

            代码：
                Statement stmt = null;
                Connection conn = null;
                try &#123;
                    //1. 注册驱动
                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                    //2. 定义sql
                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;
                    //3.获取Connection对象
                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);
                    //4.获取执行sql的对象 Statement
                    stmt = conn.createStatement();
                    //5.执行sql
                    int count = stmt.executeUpdate(sql);//影响的行数
                    //6.处理结果
                    System.out.println(count);
                    if(count &gt; 0)&#123;
                        System.out.println(&quot;添加成功！&quot;);
                    &#125;else&#123;
                        System.out.println(&quot;添加失败！&quot;);
                    &#125;
        
                &#125; catch (ClassNotFoundException e) &#123;
                    e.printStackTrace();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;finally &#123;
                    //stmt.close();
                    //7. 释放资源
                    //避免空指针异常
                    if(stmt != null)&#123;
                        try &#123;
                            stmt.close();
                        &#125; catch (SQLException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
        
                    if(conn != null)&#123;
                        try &#123;
                            conn.close();
                        &#125; catch (SQLException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
                &#125;
            
    4. ResultSet：结果集对象,封装查询结果
        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
        * getXxx(参数):获取数据
            * Xxx：代表数据类型   如： int getInt() ,	String getString()
            * 参数：
                1. int：代表列的编号,从1开始   如： getString(1)
                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)
        
        * 注意：
            * 使用步骤：
                1. 游标向下移动一行
                2. 判断是否有数据
                3. 获取数据

               //循环判断游标是否是最后一行末尾。
                while(rs.next())&#123;
                    //获取数据
                    //6.2 获取数据
                    int id = rs.getInt(1);
                    String name = rs.getString(&quot;name&quot;);
                    double balance = rs.getDouble(3);
    
                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);
                &#125;

        * 练习：
            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
                1. 定义Emp类
                2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;
                3. 实现方法 select * from emp;
                    
    5. PreparedStatement：执行sql的对象
        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a
            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39; 

        2. 解决sql注入问题：使用PreparedStatement对象来解决
        3. 预编译的SQL：参数使用?作为占位符
        4. 步骤：
            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            2. 注册驱动
            3. 获取数据库连接对象 Connection
            4. 定义sql
                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;
            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) 
            6. 给？赋值：
                * 方法： setXxx(参数1,参数2)
                    * 参数1：？的位置编号 从1 开始
                    * 参数2：？的值
            7. 执行sql，接受返回结果，不需要传递sql语句
            8. 处理结果
            9. 释放资源

        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作
            1. 可以防止SQL注入
            2. 效率更高
</code></pre>
<h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写
* 分析：
    1. 注册驱动也抽取
    2. 抽取一个方法获取连接对象
        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。
        * 解决：配置文件
            jdbc.properties
                url=
                user=
                password=


    3. 抽取一个方法释放资源

* 代码实现：
    public class JDBCUtils &#123;
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
     */
    static&#123;
        //读取资源文件，获取值。

        try &#123;
            //1. 创建Properties集合类。
            Properties pro = new Properties();

            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);
            String path = res.getPath();
            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties
            //2. 加载文件
           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));
            pro.load(new FileReader(path));

            //3. 获取数据，赋值
            url = pro.getProperty(&quot;url&quot;);
            user = pro.getProperty(&quot;user&quot;);
            password = pro.getProperty(&quot;password&quot;);
            driver = pro.getProperty(&quot;driver&quot;);
            //4. 注册驱动
            Class.forName(driver);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<p>​	</p>
<pre><code>    /**
     * 获取连接
     * @return 连接对象
     */
    public static Connection getConnection() throws SQLException &#123;

        return DriverManager.getConnection(url, user, password);
    &#125;

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn)&#123;
        if( stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if( conn != null)&#123;
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>​	</p>
<pre><code>    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;
        if( rs != null)&#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if( stmt != null)&#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if( conn != null)&#123;
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

&#125;

* 练习：
    * 需求：
        1. 通过键盘录入用户名和密码
        2. 判断用户是否登录成功
            * select * from user where username = &quot;&quot; and password = &quot;&quot;;
            * 如果这个sql有查询结果，则成功，反之，则失败

    * 步骤：
        1. 创建数据库表 user
            CREATE TABLE USER(
                id INT PRIMARY KEY AUTO_INCREMENT,
                username VARCHAR(32),
                PASSWORD VARCHAR(32)
            
            );

            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);
            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);

        2. 代码实现：
            public class JDBCDemo9 &#123;

                public static void main(String[] args) &#123;
                    //1.键盘录入，接受用户名和密码
                    Scanner sc = new Scanner(System.in);
                    System.out.println(&quot;请输入用户名：&quot;);
                    String username = sc.nextLine();
                    System.out.println(&quot;请输入密码：&quot;);
                    String password = sc.nextLine();
                    //2.调用方法
                    boolean flag = new JDBCDemo9().login(username, password);
                    //3.判断结果，输出不同语句
                    if(flag)&#123;
                        //登录成功
                        System.out.println(&quot;登录成功！&quot;);
                    &#125;else&#123;
                        System.out.println(&quot;用户名或密码错误！&quot;);
                    &#125;
</code></pre>
<p>​				</p>
<pre><code>                &#125;
</code></pre>
<p>​				<br>​				</p>
<pre><code>                /**
                 * 登录方法
                 */
                public boolean login(String username ,String password)&#123;
                    if(username == null || password == null)&#123;
                        return false;
                    &#125;
                    //连接数据库判断是否登录成功
                    Connection conn = null;
                    Statement stmt =  null;
                    ResultSet rs = null;
                    //1.获取连接
                    try &#123;
                        conn =  JDBCUtils.getConnection();
                        //2.定义sql
                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;
                        //3.获取执行sql的对象
                        stmt = conn.createStatement();
                        //4.执行查询
                        rs = stmt.executeQuery(sql);
                        //5.判断
                       /* if(rs.next())&#123;//如果有下一行，则返回true
                            return true;
                        &#125;else&#123;
                            return false;
                        &#125;*/
                       return rs.next();//如果有下一行，则返回true
            
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;finally &#123;
                        JDBCUtils.close(rs,stmt,conn);
                    &#125;
</code></pre>
<p>​				</p>
<pre><code>                    return false;
                &#125;
            &#125;
</code></pre>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。
2. 操作：
    1. 开启事务
    2. 提交事务
    3. 回滚事务
3. 使用Connection对象来管理事务
    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
        * 在执行sql之前开启事务
    * 提交事务：commit() 
        * 当所有sql都执行完提交事务
    * 回滚事务：rollback() 
        * 在catch中回滚事务

4. 代码：
    public class JDBCDemo10 &#123;

        public static void main(String[] args) &#123;
            Connection conn = null;
            PreparedStatement pstmt1 = null;
            PreparedStatement pstmt2 = null;
    
            try &#123;
                //1.获取连接
                conn = JDBCUtils.getConnection();
                //开启事务
                conn.setAutoCommit(false);
    
                //2.定义sql
                //2.1 张三 - 500
                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;
                //2.2 李四 + 500
                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;
                //3.获取执行sql对象
                pstmt1 = conn.prepareStatement(sql1);
                pstmt2 = conn.prepareStatement(sql2);
                //4. 设置参数
                pstmt1.setDouble(1,500);
                pstmt1.setInt(2,1);
    
                pstmt2.setDouble(1,500);
                pstmt2.setInt(2,2);
                //5.执行sql
                pstmt1.executeUpdate();
                // 手动制造异常
                int i = 3/0;
    
                pstmt2.executeUpdate();
                //提交事务
                conn.commit();
            &#125; catch (Exception e) &#123;
                //事务回滚
                try &#123;
                    if(conn != null) &#123;
                        conn.rollback();
                    &#125;
                &#125; catch (SQLException e1) &#123;
                    e1.printStackTrace();
                &#125;
                e.printStackTrace();
            &#125;finally &#123;
                JDBCUtils.close(pstmt1,conn);
                JDBCUtils.close(pstmt2,null);
            &#125;
</code></pre>
<p>​		</p>
<pre><code>        &#125;
    
    &#125;
</code></pre>
<p>​			</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分析堆、栈、方法区</title>
    <url>/posts/5d966776.html</url>
    <content><![CDATA[<h3 id="Java内存分析："><a href="#Java内存分析：" class="headerlink" title="Java内存分析："></a>Java内存分析：</h3><h4 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h4><ul>
<li><h5 id="凡是new的东西都存储与堆里面-例如对象和数组"><a href="#凡是new的东西都存储与堆里面-例如对象和数组" class="headerlink" title="凡是new的东西都存储与堆里面 例如对象和数组"></a>凡是new的东西都存储与堆里面 例如对象和数组</h5></li>
<li><h5 id="可以被所有的线程共享不会存放别的对象引用"><a href="#可以被所有的线程共享不会存放别的对象引用" class="headerlink" title="可以被所有的线程共享不会存放别的对象引用"></a>可以被所有的线程共享不会存放别的对象引用</h5></li>
</ul>
<h4 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h4><ul>
<li><h5 id="存放基本变量类型-会包含这个基本类型的数据数值"><a href="#存放基本变量类型-会包含这个基本类型的数据数值" class="headerlink" title="存放基本变量类型(会包含这个基本类型的数据数值)"></a>存放基本变量类型(会包含这个基本类型的数据数值)</h5></li>
<li><h5 id="引用对象的变量-会存放这个引用在堆里面的具体地址"><a href="#引用对象的变量-会存放这个引用在堆里面的具体地址" class="headerlink" title="引用对象的变量(会存放这个引用在堆里面的具体地址)"></a>引用对象的变量(会存放这个引用在堆里面的具体地址)</h5></li>
</ul>
<h4 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h4><ul>
<li><h5 id="可以被所有的线程共享"><a href="#可以被所有的线程共享" class="headerlink" title="可以被所有的线程共享"></a>可以被所有的线程共享</h5></li>
<li><h5 id="包含了所有的Class和static变量"><a href="#包含了所有的Class和static变量" class="headerlink" title="包含了所有的Class和static变量"></a>包含了所有的Class和static变量</h5></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关键字以及数据类型(扩展)</title>
    <url>/posts/1f3c832.html</url>
    <content><![CDATA[<h1 id="关键字以及数据类型-扩展"><a href="#关键字以及数据类型-扩展" class="headerlink" title="关键字以及数据类型(扩展)"></a>关键字以及数据类型(扩展)</h1><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><table>
<thead>
<tr>
<th>abstract</th>
<th>assert</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>catch</td>
<td>char</td>
<td>class</td>
<td>const</td>
</tr>
<tr>
<td>continue</td>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
</tr>
<tr>
<td>enum</td>
<td>extends</td>
<td>final</td>
<td>finally</td>
<td>float</td>
</tr>
<tr>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
<td>import</td>
</tr>
<tr>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
<td>long</td>
<td>native</td>
</tr>
<tr>
<td>new</td>
<td>package</td>
<td>private</td>
<td>protected</td>
<td>public</td>
</tr>
<tr>
<td>return</td>
<td>strictfp</td>
<td>short</td>
<td>static</td>
<td>super</td>
</tr>
<tr>
<td>switch</td>
<td>synchronized</td>
<td>this</td>
<td>throw</td>
<td>throws</td>
</tr>
<tr>
<td>transient</td>
<td>try</td>
<td>void</td>
<td>volatile</td>
<td>while</td>
</tr>
</tbody></table>
<h3 id="JAVA的数据类型分为两大类"><a href="#JAVA的数据类型分为两大类" class="headerlink" title="JAVA的数据类型分为两大类"></a>JAVA的数据类型分为两大类</h3><pre><code>#### 基本类型 (primitive type)
</code></pre>
<h4 id="引用类型-reference-type"><a href="#引用类型-reference-type" class="headerlink" title="引用类型(reference type)"></a>引用类型(reference type)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">							基本数据类型(primitive type)</span><br><span class="line">		数值类型														boolean类型</span><br><span class="line">byte 占用一个字节范围:-128 - 127									占用一位其值只有true和false两个</span><br><span class="line">short 占两个字节范围:-32768 - 32767									   浮点类型</span><br><span class="line">int	  占四个字节范围 -2147483648 - 2147483647							folat 占用四个字节</span><br><span class="line">long 占八个字节范围: -9223372036854775808 - 9223372036854775807		double 占用八个字节</span><br><span class="line">		字符类型</span><br><span class="line">char占两个字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">					引用数据类型(Reference Type)</span><br><span class="line">类						接口						数组</span><br></pre></td></tr></table></figure>



<h3 id="标识符注意点"><a href="#标识符注意点" class="headerlink" title="标识符注意点"></a>标识符注意点</h3><ul>
<li><p>​	所有点标识符都应该以字母 (A-Z或者a-z)，美元符($)、或者下划线(_)开始</p>
</li>
<li><p>首字符之后可以是字母(A-Z或则a-z),美元符($)、或者下划线(_)或者数字的任何字符组合</p>
</li>
<li><p>不能使用关键字作为变量名或者方法名。</p>
</li>
<li><p>标识符是大小写敏感的。</p>
</li>
<li><p>合法标识符举例: age、$salary、_value 、__1 _value</p>
</li>
<li><p>非法标识符举例：123abc 、-salary 、#abc</p>
</li>
<li><p>可以使用中文命名,但是不推荐使用。</p>
</li>
</ul>
<h3 id="强类型语言"><a href="#强类型语言" class="headerlink" title="强类型语言"></a>强类型语言</h3><h4 id="要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用"><a href="#要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用" class="headerlink" title="要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用"></a>要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</h4><h3 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h3><h4 id="位-bit-是计算机-内部数据-存储的最小单位-，11001100是以个八位二进制的数。"><a href="#位-bit-是计算机-内部数据-存储的最小单位-，11001100是以个八位二进制的数。" class="headerlink" title="位(bit):是计算机 内部数据 存储的最小单位 ，11001100是以个八位二进制的数。"></a>位(bit):是计算机 内部数据 存储的最小单位 ，11001100是以个八位二进制的数。</h4><h4 id="字节-byte-：是计算机中-数据处理的基本单位，习惯上用大写B来表示。"><a href="#字节-byte-：是计算机中-数据处理的基本单位，习惯上用大写B来表示。" class="headerlink" title="字节(byte)：是计算机中 数据处理的基本单位，习惯上用大写B来表示。"></a>字节(byte)：是计算机中 数据处理的基本单位，习惯上用大写B来表示。</h4><h4 id="1B-byte-字节-8bit-位"><a href="#1B-byte-字节-8bit-位" class="headerlink" title="1B(byte,字节) &#x3D; 8bit(位)"></a>1B(byte,字节) &#x3D; 8bit(位)</h4><h4 id="字符：是指计算机中使用的字母，数字，子和符号。"><a href="#字符：是指计算机中使用的字母，数字，子和符号。" class="headerlink" title="字符：是指计算机中使用的字母，数字，子和符号。"></a>字符：是指计算机中使用的字母，数字，子和符号。</h4><h3 id="拓展知识："><a href="#拓展知识：" class="headerlink" title="拓展知识："></a>拓展知识：</h3><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><p>​	二进制		 0b</p>
<p>​	八进制		0</p>
<p>​	十六进制 	0x</p>
<h4 id="浮点数拓展"><a href="#浮点数拓展" class="headerlink" title="浮点数拓展"></a>浮点数拓展</h4><p>BigDecimal 数学工具类</p>
<p>&#x2F;&#x2F; float  在数字上表现 大约 接近但不等于</p>
<p>&#x2F;&#x2F;double </p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>&#x2F;&#x2F;   \t 制表符</p>
<p>&#x2F;&#x2F; \换行</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/posts/9bc01b38.html</url>
    <content><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类就是在一个类内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。"><a href="#内部类就是在一个类内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。" class="headerlink" title="内部类就是在一个类内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。"></a>内部类就是在一个类内部在定义一个类，比如，A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。</h4><ul>
<li><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5></li>
<li><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5></li>
<li><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5></li>
<li><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5></li>
</ul>
<h5 id="在一个类里面在写一个类就是内部类"><a href="#在一个类里面在写一个类就是内部类" class="headerlink" title="在一个类里面在写一个类就是内部类"></a>在一个类里面在写一个类就是内部类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outers</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">inter</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intse</span><span class="params">()</span>&#123;</span><br><span class="line"> 		 System.out.println(<span class="string">&quot;内部类方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">inter</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">intse</span><span class="params">()</span>&#123;</span><br><span class="line"> 		 System.out.println(<span class="string">&quot;静态内部类方法&quot;</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//局部内部类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.opp.demo11.Outers;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">            <span class="type">Outers</span> <span class="variable">outers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outers</span>();</span><br><span class="line">            <span class="comment">//通过外部类实例化内部类</span></span><br><span class="line">          Outers.<span class="type">inter</span> <span class="variable">inter</span> <span class="operator">=</span> Outers.<span class="keyword">new</span> <span class="title class_">Inter</span>();</span><br><span class="line">            inter.in();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一个java文件中只能有多个 class，但是可以有一个public class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类,没有名字初始化类，不用将实例保存到变量中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Apple</span>().eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式接口</title>
    <url>/posts/69144af4.html</url>
    <content><![CDATA[<h4 id="day12【函数式接口】"><a href="#day12【函数式接口】" class="headerlink" title="day12【函数式接口】"></a>day12【函数式接口】</h4><h5 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h5><ul>
<li><h6 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h6></li>
<li><h6 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h6></li>
<li><h6 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h6></li>
</ul>
<h4 id="第一章-函数式接口"><a href="#第一章-函数式接口" class="headerlink" title="第一章 函数式接口"></a>第一章 函数式接口</h4><h5 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h5><h5 id="函数式接口在Java中是指：有且仅有一个抽象方法的接口。"><a href="#函数式接口在Java中是指：有且仅有一个抽象方法的接口。" class="headerlink" title="函数式接口在Java中是指：有且仅有一个抽象方法的接口。"></a>函数式接口在Java中是指：有且仅有一个抽象方法的接口。</h5><h5 id="函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可-以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。"><a href="#函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可-以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。" class="headerlink" title="函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。"></a>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</h5><h6 id="备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实-底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部-类的“语法糖”，但是二者在原理上是不同的。-1-2-格式-只要确保接口中有且仅有一个抽象方法即可："><a href="#备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实-底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部-类的“语法糖”，但是二者在原理上是不同的。-1-2-格式-只要确保接口中有且仅有一个抽象方法即可：" class="headerlink" title="备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。 1.2 格式 只要确保接口中有且仅有一个抽象方法即可："></a>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。 1.2 格式 只要确保接口中有且仅有一个抽象方法即可：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line"><span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="由于接口当中抽象方法的-public-abstract-是可以省略的，所以定义一个函数式接口很简单："><a href="#由于接口当中抽象方法的-public-abstract-是可以省略的，所以定义一个函数式接口很简单：" class="headerlink" title="由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单："></a>由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3-FunctionalInterface注解"><a href="#1-3-FunctionalInterface注解" class="headerlink" title="1.3 @FunctionalInterface注解"></a>1.3 @FunctionalInterface注解</h4><h5 id="与-Override-注解的作用类似，Java-8中专门为函数式接口引入了一个新的注解：-FunctionalInterface-。该注-解可用于一个接口的定义上："><a href="#与-Override-注解的作用类似，Java-8中专门为函数式接口引入了一个新的注解：-FunctionalInterface-。该注-解可用于一个接口的定义上：" class="headerlink" title="与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注 解可用于一个接口的定义上："></a>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注 解可用于一个接口的定义上：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要<strong>注意</strong>的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<h5 id="1-4-自定义函数式接口"><a href="#1-4-自定义函数式接口" class="headerlink" title="1.4 自定义函数式接口"></a><strong>1.4</strong> <strong>自定义函数式接口</strong></h5><h6 id="对于刚刚定义好的-MyFunctionalInterface-函数式接口，典型使用场景就是作为方法的参数"><a href="#对于刚刚定义好的-MyFunctionalInterface-函数式接口，典型使用场景就是作为方法的参数" class="headerlink" title="对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数"></a>对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09FunctionalInterface</span> &#123;</span><br><span class="line"><span class="comment">// 使用自定义的函数式接口作为方法参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> &#123; inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 调用使用函数式接口的方法</span></span><br><span class="line">doSomething(() ‐&gt; System.out.println(<span class="string">&quot;Lambda执行啦！&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二章 函数式编程</strong> </p>
<p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。 </p>
<p>下面我们做一个初探。</p>
<p><strong>2.1 Lambda</strong>的延迟执行</p>
<p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 </p>
<p>作为解决方案，提升性能。</p>
<p><strong>性能浪费的日志案例</strong> </p>
<p>注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 </p>
<p>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, String msg)</span> &#123; <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>; <span class="type">String</span> <span class="variable">msgC</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"></span><br><span class="line">log(<span class="number">1</span>, msgA + msgB + msgC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 </p>
<blockquote>
<p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字 符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。 </p>
</blockquote>
<h5 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a><strong>体验Lambda</strong>的更优写法</h5><p>使用Lambda必然需要一个函数式接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageBuilder</span> &#123; String <span class="title function_">buildMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对 log 方法进行改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LoggerLambda</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, MessageBuilder builder)</span> &#123; <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(builder.buildMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">msgC</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"></span><br><span class="line">	log(<span class="number">1</span>, () ‐&gt; msgA + msgB + msgC );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。 </p>
<h5 id="证明Lambda的延迟"><a href="#证明Lambda的延迟" class="headerlink" title="证明Lambda的延迟"></a>证明Lambda的延迟</h5><p>下面的代码可以通过结果进行验证： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03LoggerDelay</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, MessageBuilder builder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">		System.out.println(builder.buildMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">msgC</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"></span><br><span class="line">log(<span class="number">2</span>, ()‐&gt;&#123; System.out.println(<span class="string">&quot;Lambda执行！&quot;</span>); </span><br><span class="line">            <span class="keyword">return</span> msgA + msgB + msgC;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p>
<blockquote>
<p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法 来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>
</blockquote>
<h5 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a><strong>2.2</strong> 使用Lambda作为参数和返回值</h5><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。 </p>
<p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	startThread(() ‐&gt; System.out.println(<span class="string">&quot;线程任务执行！&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays; </span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Comparator</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">newComparator</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> (a, b) ‐&gt; b.length() ‐ a.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    String[] array = &#123; <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abcd&quot;</span> &#125;; System.out.println(Arrays.toString(array));</span><br><span class="line">    Arrays.sort(array, newComparator()); System.out.println(Arrays.toString(array));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中直接return一个Lambda表达式即可。</p>
<h5 id="第三章-常用函数式接口"><a href="#第三章-常用函数式接口" class="headerlink" title="第三章 常用函数式接口"></a><strong>第三章 常用函数式接口</strong></h5><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的几个接口及使用示例。</p>
<p><strong>3.1 Supplier接口</strong></p>
<p>java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对 象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“<strong>对外提供</strong>”一个符合泛型类型的对象数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Supplier</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; function)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> function.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    System.out.println(getString(() ‐&gt; msgA + msgB));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2</strong> <strong>练习：求数组元素最大值</strong> </p>
<p><strong>题目</strong></p>
<p>使用 Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型请使用 </p>
<p>java.lang.Integer 类。 </p>
<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Test</span> &#123;</span><br><span class="line">	<span class="comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sup.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">333</span>,<span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getMax方法,参数传递Lambda </span></span><br><span class="line">	 <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> getMax(()‐&gt;&#123;</span><br><span class="line"><span class="comment">//计算数组的最大值</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123; <span class="keyword">if</span>(i&gt;max)&#123;</span><br><span class="line">		max = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;);</span><br><span class="line">		System.out.println(maxNum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3 Consumer接口</strong></p>
<p>java.util.function.Consumer<T> 接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据， </p>
<p>其数据类型由泛型决定。 </p>
<p><strong>抽象方法：accept</strong> </p>
<p>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。基本使用如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09Consumer</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumeString</span><span class="params">(Consumer&lt;String&gt; function)</span> &#123; 						function.accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            consumeString(s‐&gt;System.out.println(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，更好的写法是使用方法引用。 </p>
<p><strong>默认方法：andThen</strong> </p>
<p>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。下面是JDK的源代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123; 							Objects.requireNonNull(after);</span><br><span class="line">	<span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); </span><br><span class="line">                    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 </p>
<p>NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。 </p>
</blockquote>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组 </p>
<p>合的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10ConsumerAndThen</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumeString</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> 	&#123; </span><br><span class="line">        one.andThen(two).accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        consumeString(s ‐&gt; System.out.println(s.toUpperCase()),s‐&gt;System.out.println(s.toLowerCase()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的 </p>
<p>组合。 </p>
<p><strong>3.4</strong> <strong>练习：格式化打印信息</strong> </p>
<p><strong>题目</strong></p>
<p>下面的字符串数组当中存有多条信息，请按照格式“ 姓名：XX。性别：XX。 ”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实 例，将两个 Consumer 接口按照顺序“拼接”到一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    String[] array = &#123; <span class="string">&quot;迪丽热巴,女&quot;</span>, <span class="string">&quot;古力娜扎,女&quot;</span>, <span class="string">&quot;马尔扎哈,男&quot;</span> &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			String[] array = &#123; <span class="string">&quot;迪丽热巴,女&quot;</span>, <span class="string">&quot;古力娜扎,女&quot;</span>, <span class="string">&quot;马尔扎哈,男&quot;</span> &#125;;</span><br><span class="line">			printInfo(s ‐&gt; System.out.print(<span class="string">&quot;姓名：&quot;</span> + s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]),s‐&gt; System.out.println(<span class="string">&quot;。性别：&quot;</span> + s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;。&quot;</span>),array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two, String[] array)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">				one.andThen(two).accept(info); <span class="comment">// 姓名：迪丽热巴。性别：女。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.5 Predicate接口</strong> </p>
<p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 </p>
<p>java.util.function.Predicate<T> 接口。 </p>
<p><strong>抽象方法：test</strong> </p>
<p>Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15PredicateTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123; </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">veryLong</span> <span class="operator">=</span> predicate.test(<span class="string">&quot;HelloWorld&quot;</span>); System.out.println(<span class="string">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method(s ‐&gt; s.length() &gt; <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 </p>
<p><strong>默认方法：</strong>and** </p>
<p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 </p>
<p>现“<strong>并且</strong>”的效果时，可以使用default方法 and 。其JDK源码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123; </span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">	<span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16PredicateAnd</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> one.and(two).test(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(s ‐&gt; s.contains(<span class="string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认方法：or</strong> </p>
<p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“<strong>或</strong>”。JDK源码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123; </span><br><span class="line">   	 Objects.requireNonNull(other);</span><br><span class="line">		<span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不 </p>
<p>变：	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16PredicateAnd</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123; <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span>one.or(two).test(<span class="string">&quot;Helloworld&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;字符串符合要求吗：&quot;</span> + isValid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(s ‐&gt; s.contains(<span class="string">&quot;H&quot;</span>), s ‐&gt; s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认方法：negate</strong> </p>
<p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前 </p>
<p>调用 negate 方法，正如 and 和 or 方法一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo17PredicateNegate</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123; <span class="type">boolean</span> <span class="variable">veryLong</span> <span class="operator">=</span>predicate.negate().test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    method(s ‐&gt; s.length() &lt; <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.6</strong> <strong>练习：集合信息筛选</strong> </p>
<p><strong>题目</strong></p>
<p>数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合</p>
<p>ArrayList 中，需要同时满足两个条件： </p>
<ol>
<li><p>必须为女生； </p>
</li>
<li><p>姓名为4个字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] array = &#123; <span class="string">&quot;迪丽热巴,女&quot;</span>, <span class="string">&quot;古力娜扎,女&quot;</span>, <span class="string">&quot;马尔扎哈,男&quot;</span>, <span class="string">&quot;赵丽颖,女&quot;</span> &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	String[] array = &#123; <span class="string">&quot;迪丽热巴,女&quot;</span>, <span class="string">&quot;古力娜扎,女&quot;</span>, <span class="string">&quot;马尔扎哈,男&quot;</span>, <span class="string">&quot;赵丽颖,女&quot;</span> &#125;; </span><br><span class="line">        List&lt;String&gt; list = filter(array,s ‐&gt; <span class="string">&quot;女&quot;</span>.equals(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]),s ‐&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() ==<span class="number">4</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">filter</span><span class="params">(String[] array, Predicate&lt;String&gt; one,Predicate&lt;String&gt; two)</span> &#123; 					List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">			<span class="keyword">if</span> (one.and(two).test(info)) &#123;</span><br><span class="line">                list.add(info);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.7 Function接口</strong> </p>
<p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件， </p>
<p>后者称为后置条件。 </p>
<p><strong>抽象方法：apply</strong> </p>
<p>Function 接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。 </p>
<p>使用的场景例如：将 String 类型转换为 Integer 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11FunctionApply</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String, Integer&gt; function)</span> &#123; </span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> function.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">				System.out.println(num + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">            	method(s ‐&gt; Integer.parseInt(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，最好是通过方法引用的写法。 </p>
<p><strong>默认方法：andThen</strong> </p>
<p>Function 接口中有一个默认的 andThen 方法，用来进行组合操作。JDK源代码如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123; 										Objects.requireNonNull(after);</span><br><span class="line">		<span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12FunctionAndThen</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> one.andThen(two).apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">		System.out.println(num + <span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            method(str‐&gt;Integer.parseInt(str)+<span class="number">10</span>, i ‐&gt; i *= <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 </p>
<p>起。</p>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。 </p>
<p><strong>3.8</strong> <strong>练习：自定义函数模型拼接</strong> </p>
<p><strong>题目</strong></p>
<p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为： </p>
<p>String str &#x3D; “赵丽颖,20”; </p>
<ol>
<li><p>将字符串截取数字年龄部分，得到字符串； </p>
</li>
<li><p>将上一步的字符串转换成为int类型的数字； </p>
</li>
<li><p>将上一步的int数字累加100，得到结果int数字。</p>
</li>
</ol>
<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFunction</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;赵丽颖,20&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> getAgeNum(str, s ‐&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>],s ‐&gt;Integer.parseInt(s), n ‐&gt; n += <span class="number">100</span>);</span><br><span class="line">			System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAgeNum</span><span class="params">(String str, Function&lt;String, String&gt; one,Function&lt;String, Integer&gt; two, Function&lt;Integer, Integer&gt; three)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> one.andThen(two).andThen(three).apply(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>变量是什么</title>
    <url>/posts/94320cfe.html</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量是什么：就是可以变换的量！"><a href="#变量是什么：就是可以变换的量！" class="headerlink" title="变量是什么：就是可以变换的量！"></a>变量是什么：就是可以变换的量！</h2><h3 id="java-是一种强类型语言，每个变量都必须声明其类型。"><a href="#java-是一种强类型语言，每个变量都必须声明其类型。" class="headerlink" title="java 是一种强类型语言，每个变量都必须声明其类型。"></a>java 是一种强类型语言，每个变量都必须声明其类型。</h3><h3 id="java是程序中最基本的存储单元，其要素包括包括变量名，变量类型和作用域。"><a href="#java是程序中最基本的存储单元，其要素包括包括变量名，变量类型和作用域。" class="headerlink" title="java是程序中最基本的存储单元，其要素包括包括变量名，变量类型和作用域。"></a>java是程序中最基本的存储单元，其要素包括包括变量名，变量类型和作用域。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type varName  [=value]  [&#123;,varName[=value]&#125;];    </span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h2><h3 id="1-每个变量都有类型，类型可以是基本类型，也可以是引用类型。"><a href="#1-每个变量都有类型，类型可以是基本类型，也可以是引用类型。" class="headerlink" title="1.每个变量都有类型，类型可以是基本类型，也可以是引用类型。"></a>1.每个变量都有类型，类型可以是基本类型，也可以是引用类型。</h3><h3 id="2-变量名必须是合法的标识符。"><a href="#2-变量名必须是合法的标识符。" class="headerlink" title="2.变量名必须是合法的标识符。"></a>2.变量名必须是合法的标识符。</h3><h3 id="3-变量声明是一条完整的语句，因此每一个声明都必须以分号结束"><a href="#3-变量声明是一条完整的语句，因此每一个声明都必须以分号结束" class="headerlink" title="3.变量声明是一条完整的语句，因此每一个声明都必须以分号结束"></a>3.变量声明是一条完整的语句，因此每一个声明都必须以分号结束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//类变量 static</span><br><span class="line"></span><br><span class="line">​	static double salary =2500;</span><br><span class="line"></span><br><span class="line">   //属性:变量</span><br><span class="line"></span><br><span class="line">​	//实例变量：从属于对象；如果不自行初始化，这个类型的默认值  0  0.0；</span><br><span class="line"></span><br><span class="line">​	//布尔值： 默认是false</span><br><span class="line"></span><br><span class="line">​	//除了基本类型，其余的默认值都是null；</span><br><span class="line"></span><br><span class="line">​	String  name;</span><br><span class="line"></span><br><span class="line">​		int  age;</span><br></pre></td></tr></table></figure>



<h3 id="1-局部变量-是在方法里的-必须声明以及初始化值。"><a href="#1-局部变量-是在方法里的-必须声明以及初始化值。" class="headerlink" title="1. 局部变量:是在方法里的,必须声明以及初始化值。"></a>1. 局部变量:是在方法里的,必须声明以及初始化值。</h3><h3 id="2-实例变量：从属于对象中；如果不初始化，会给一个默认值，如-int-0；double-0-0；boolean默认值是false；其他除了基本数据类型-其余默认值为-null；"><a href="#2-实例变量：从属于对象中；如果不初始化，会给一个默认值，如-int-0；double-0-0；boolean默认值是false；其他除了基本数据类型-其余默认值为-null；" class="headerlink" title="2.实例变量：从属于对象中；如果不初始化，会给一个默认值，如 int &#x3D; 0；double &#x3D;0.0；boolean默认值是false；其他除了基本数据类型 其余默认值为 null；"></a>2.实例变量：从属于对象中；如果不初始化，会给一个默认值，如 int &#x3D; 0；double &#x3D;0.0；boolean默认值是false；其他除了基本数据类型 其余默认值为 null；</h3><h3 id="3-类变量：static-从属于类中"><a href="#3-类变量：static-从属于类中" class="headerlink" title="3. 类变量：static 从属于类中"></a>3. 类变量：static 从属于类中</h3><h4 id="类变量-格式："><a href="#类变量-格式：" class="headerlink" title="类变量 格式："></a>类变量 格式：</h4><h5 id="static-变量类型-变量名-值；"><a href="#static-变量类型-变量名-值；" class="headerlink" title="static 变量类型 变量名 &#x3D; 值；"></a>static 变量类型 变量名 &#x3D; 值；</h5><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h4 id="常量-Constant-初始化-initialize-后不能再改变值！它是一个不会变动的值。"><a href="#常量-Constant-初始化-initialize-后不能再改变值！它是一个不会变动的值。" class="headerlink" title="常量(Constant): 初始化(initialize)后不能再改变值！它是一个不会变动的值。"></a>常量(Constant): 初始化(initialize)后不能再改变值！它是一个不会变动的值。</h4><h4 id="所谓常量是可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。"><a href="#所谓常量是可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。" class="headerlink" title="所谓常量是可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。"></a>所谓常量是可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</h4><p>​	<code>final 常量名 = 值；</code>			</p>
<p>​	<code>final double PI =3.14;</code></p>
<h4 id="常量名一般用大写字符。"><a href="#常量名一般用大写字符。" class="headerlink" title="常量名一般用大写字符。"></a>常量名一般用大写字符。</h4><h3 id="常量是一个一次赋值不可改变的值；"><a href="#常量是一个一次赋值不可改变的值；" class="headerlink" title="常量是一个一次赋值不可改变的值；"></a>常量是一个一次赋值不可改变的值；</h3><h3 id="常量的名-一定要大写；"><a href="#常量的名-一定要大写；" class="headerlink" title="常量的名 一定要大写；"></a>常量的名 一定要大写；</h3><h3 id="常量格式：static-static-类型-值；"><a href="#常量格式：static-static-类型-值；" class="headerlink" title="常量格式：static static 类型&#x3D;值；"></a>常量格式：static static 类型&#x3D;值；</h3><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><pre><code>1.所有的变量、方法、类名：见名知意
</code></pre>
<h4 id="2-类成员变量：首字母小写和驼峰原则：monthSalary-除了第一个单词意外，后面的单词首字母大写"><a href="#2-类成员变量：首字母小写和驼峰原则：monthSalary-除了第一个单词意外，后面的单词首字母大写" class="headerlink" title="2.类成员变量：首字母小写和驼峰原则：monthSalary 除了第一个单词意外，后面的单词首字母大写"></a>2.类成员变量：首字母小写和驼峰原则：monthSalary 除了第一个单词意外，后面的单词首字母大写</h4><h4 id="3-局部变量：首字母小写和驼峰原则"><a href="#3-局部变量：首字母小写和驼峰原则" class="headerlink" title="3.局部变量：首字母小写和驼峰原则"></a>3.局部变量：首字母小写和驼峰原则</h4><h4 id="4-常量：大写字母和下划线-MAX-VALUE"><a href="#4-常量：大写字母和下划线-MAX-VALUE" class="headerlink" title="4.常量：大写字母和下划线:MAX_VALUE"></a>4.常量：大写字母和下划线:MAX_VALUE</h4><h4 id="5-类名：首字母大写和驼峰原则：Man，GoodMan"><a href="#5-类名：首字母大写和驼峰原则：Man，GoodMan" class="headerlink" title="5.类名：首字母大写和驼峰原则：Man，GoodMan"></a>5.类名：首字母大写和驼峰原则：Man，GoodMan</h4><h4 id="6-方法名：首字母小写和驼峰原则-：run-runRun"><a href="#6-方法名：首字母小写和驼峰原则-：run-runRun" class="headerlink" title="6. 方法名：首字母小写和驼峰原则 ：run(), runRun()"></a>6. 方法名：首字母小写和驼峰原则 ：run(), runRun()</h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数</title>
    <url>/posts/6963fb18.html</url>
    <content><![CDATA[<h3 id="可变参数-不定项参数"><a href="#可变参数-不定项参数" class="headerlink" title="可变参数(不定项参数)"></a>可变参数(不定项参数)</h3><ul>
<li><h4 id="在jdk-1-5-开始-，java支持传递同类型的可变参数给一个方法"><a href="#在jdk-1-5-开始-，java支持传递同类型的可变参数给一个方法" class="headerlink" title="在jdk 1.5 开始 ，java支持传递同类型的可变参数给一个方法"></a>在jdk 1.5 开始 ，java支持传递同类型的可变参数给一个方法</h4></li>
<li><h4 id="在方法声明中，在指定参数类型后加一个省略号-…-本质就是数组"><a href="#在方法声明中，在指定参数类型后加一个省略号-…-本质就是数组" class="headerlink" title="在方法声明中，在指定参数类型后加一个省略号(…),[  本质就是数组  ]"></a>在方法声明中，在指定参数类型后加一个省略号(…),[  本质就是数组  ]</h4></li>
<li><h4 id="一个方法中只能指定一个可变参数，他必须是方法最后一个参数，任何普通的参数必须在它之前声明。"><a href="#一个方法中只能指定一个可变参数，他必须是方法最后一个参数，任何普通的参数必须在它之前声明。" class="headerlink" title="一个方法中只能指定一个可变参数，他必须是方法最后一个参数，任何普通的参数必须在它之前声明。"></a>一个方法中只能指定一个可变参数，他必须是方法最后一个参数，任何普通的参数必须在它之前声明。</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ClassDemo01</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassDemo01</span>();</span><br><span class="line">    	demo.test();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>... i)</span>&#123;</span><br><span class="line">   		System.out.println(i[<span class="number">0</span>]);  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLassDemo0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            printlnMax(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">45</span>,<span class="number">465</span>,<span class="number">456</span>,<span class="number">465</span>);</span><br><span class="line">            printlnMax(<span class="number">3333</span>,<span class="number">333</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printlnMax</span><span class="params">(<span class="type">double</span> ...nbm)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nbm.length == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据出错&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> nbm[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nbm.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nbm[i]&gt;res)&#123;</span><br><span class="line">                res = nbm[i];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java同步</title>
    <url>/posts/9d32b1d.html</url>
    <content><![CDATA[<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>解决线程安全问题的一种方案：使用同步代码块</p>
<p>​	格式：synchronized(锁对象){</p>
<p>可能会出现线程安全问题的代码(访问共享数据的代码)}</p>
<p>​	注意：</p>
<p>​		1.通过代码块中的锁对象，可以使用任意的对象</p>
<p>​		2.但是必须保证多个线程使用的锁对象是同一个</p>
<p>​		3.锁对象作用：</p>
<p>​				把同步代码块锁住，只让一个线程在同步代码块中执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDesp</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//使用死循环，让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">               <span class="comment">//先判断票是否存在</span></span><br><span class="line">               <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//提高安全问题出现问题的概率，让程序睡眠</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了多少票&quot;</span>+r);</span><br><span class="line">                   r--;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象(lamada表达式方式)</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象</span></span><br><span class="line">        <span class="type">TestDesp</span> <span class="variable">ts</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TestDesp</span>();</span><br><span class="line">        <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        tss.start();</span><br><span class="line">        tss1.start();</span><br><span class="line">        tss2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151930015.png" alt="image-20210915193024885"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151932347.png" alt="image-20210915193234304"></p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>​	使用synchronized修饰的方法就叫做同步方法，保证A线程执行该方法的时候，其他线程只能在方法外等着。</p>
<p>​	格式：</p>
<p>​			</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    可能会出现线程安全的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用步骤：</p>
<p>​		1.把访问了共享数据的代码抽取出来，放到一个方法中</p>
<p>​		2.在方法上添加synchronized修饰符；</p>
<p>​		格式：定义方法的格式</p>
<p>​		修饰符 synchronized  返回值类型  方法名(参数列表){</p>
<p>​			可能会出现线程安全的代码			</p>
<p>​			}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Day002;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDesp</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//设置线程任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用死循环，让卖票操作重复执行</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           plytak();</span><br><span class="line">   	   &#125;</span><br><span class="line">  	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	定义一个同步方法</span></span><br><span class="line"><span class="comment">	同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">	只让一个线程执行</span></span><br><span class="line"><span class="comment">	同步方法的锁对象是谁？</span></span><br><span class="line"><span class="comment">	就是实现类对象new TestDesp()</span></span><br><span class="line"><span class="comment">	也就是this </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plytak</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先判断票是否存在</span></span><br><span class="line">               <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//提高安全问题出现问题的概率，让程序睡眠</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了多少票&quot;</span>+r);</span><br><span class="line">                   r--;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象(lamada表达式方式)</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象</span></span><br><span class="line">        <span class="type">TestDesp</span> <span class="variable">ts</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TestDesp</span>();</span><br><span class="line">        <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        tss.start();</span><br><span class="line">        tss1.start();</span><br><span class="line">        tss2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="静态同步"><a href="#静态同步" class="headerlink" title="静态同步"></a>静态同步</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Day002;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDesp</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//设置线程任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用死循环，让卖票操作重复执行</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           plytak();</span><br><span class="line">   	   &#125;</span><br><span class="line">  	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	静态同步方法的</span></span><br><span class="line"><span class="comment">	锁对象是谁？</span></span><br><span class="line"><span class="comment">	不是this</span></span><br><span class="line"><span class="comment">	this是创建对象后才产生的，静态方法优先于对象。</span></span><br><span class="line"><span class="comment">	就是本类的class属性---class文件对象(反射)</span></span><br><span class="line"><span class="comment">	也就是this </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">plytak</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先判断票是否存在</span></span><br><span class="line">               <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//提高安全问题出现问题的概率，让程序睡眠</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了多少票&quot;</span>+r);</span><br><span class="line">                   r--;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象(lamada表达式方式)</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建Runnable接口对象的实现类对象</span></span><br><span class="line">        <span class="type">TestDesp</span> <span class="variable">ts</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TestDesp</span>();</span><br><span class="line">        <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        tss.start();</span><br><span class="line">        tss1.start();</span><br><span class="line">        tss2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h4><p>解决线程安全问题的第三种方案：使用lock锁</p>
<p>java.util.concurrent.locks.lock锁</p>
<p>Lock 实现提供了比使用synchronized 方法和语句可获得更广泛的锁定操作。</p>
<p>Lock 接口中的方法：</p>
<p>void Lock() 获取锁</p>
<p>void unLock()释放锁</p>
<p>使用步骤：</p>
<p>1.在成员位置创建一个ReentrantLock对象</p>
<p>2.在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取</p>
<p>package Day002;<br>import java.lang.*;</p>
<p>public class TestDesp implements Runnable{<br>    private static int r &#x3D; 100;<br>    Object object &#x3D; new Object();<br>    @Override<br>    &#x2F;&#x2F;设置线程任务<br>    public void run(){<br>        &#x2F;&#x2F;使用死循环，让卖票操作重复执行<br>       while(true){<br>           plytak();<br>          }<br>        }<br>    }<br>    &#x2F;*</p>
<pre><code>静态同步方法的
锁对象是谁？
不是this
this是创建对象后才产生的，静态方法优先于对象。
就是本类的class属性---class文件对象(反射)
也就是this 

*/
public static synchronized void plytak ()&#123;
    //先判断票是否存在
           if(r&gt;0)&#123;
               //提高安全问题出现问题的概率，让程序睡眠
               try &#123;
                   Thread.sleep(10);
                   System.out.println(Thread.currentThread().getName()+&quot;卖出了多少票&quot;+r);
               r--;
               &#125; catch (InterruptedException e) &#123;
                   e.printStackTrace();
               &#125;finally&#123;
               lock.unlock();
               &#125;
               
       &#125;

     &#125;
&#125;
</code></pre>
<p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建Runnable接口对象的实现类对象(lamada表达式方式)</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello word&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建Runnable接口对象的实现类对象</span></span><br><span class="line">    <span class="type">TestDesp</span> <span class="variable">ts</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TestDesp</span>();</span><br><span class="line">    <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">tss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">tss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">tss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ts);</span><br><span class="line">    <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">    tss.start();</span><br><span class="line">    tss1.start();</span><br><span class="line">    tss2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109191904174.png"></p>
<h4 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h4><p>​	线程之间的通信</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemowaitAndNotify</span>()&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个顾客线程(消费者)：告知老板要的包子种类喝数量，调用wait方法，放弃cpu的执行，进入都WAITING状态(无线等待)</span></span><br><span class="line"><span class="comment">	创建一个拉板线程(生产者)：花了五秒做好包子之后，调用notify方法，唤醒顾客吃包子。</span></span><br><span class="line"><span class="comment">	注意：</span></span><br><span class="line"><span class="comment">		顾客喝老板线程必须使用同步代码块包裹起来，保证等待喝唤醒只能有一个在执行，同步使用的锁对象必须保证唯一，只有锁对象才能调用wait喝notify方法</span></span><br><span class="line"><span class="comment">	Obejct类中的方法</span></span><br><span class="line"><span class="comment">void wait()</span></span><br><span class="line"><span class="comment">	在其他线程调用此对象的notify()方法或notifyAll()方法之前，导致当前线程等待。</span></span><br><span class="line"><span class="comment">void notify()</span></span><br><span class="line"><span class="comment">	唤醒在此对象监视器上等待的单个线程。</span></span><br><span class="line"><span class="comment">	会继续执行wait方法之后的代码</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String &#123;&#125; args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建锁对象，保证唯一</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//创建顾客线程，(消费者)</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;老板我要买包子一百个&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子好了开始吃包子&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;老板五秒钟做好了包子。把包子给顾客&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait带参方法"><a href="#wait带参方法" class="headerlink" title="wait带参方法"></a>wait带参方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Day002;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demowiat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建锁对象保证唯一</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//创建顾客线程，(消费者)</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客一 老板我要买包子2百个&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子好了开始吃包子&quot;</span>+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="notifyAll方法"><a href="#notifyAll方法" class="headerlink" title="notifyAll方法"></a>notifyAll方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Day002;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demowiat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建锁对象保证唯一</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//创建顾客线程，(消费者)</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客一 老板我要买包子2百个&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子好了开始吃包子&quot;</span>+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//创建顾客线程，(消费者)</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;顾客二 老板我要买包子一百个&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;包子好了开始吃包子&quot;</span>+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">                &#125;&#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    obj.notifyAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;老板五秒钟做好了包子。把包子给顾客&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行传参</title>
    <url>/posts/4a246c51.html</url>
    <content><![CDATA[<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><h4 id="有时候你希望运行一个程序时候在传递给它消息，这得靠传递命令行参数给main-函数实现。"><a href="#有时候你希望运行一个程序时候在传递给它消息，这得靠传递命令行参数给main-函数实现。" class="headerlink" title="有时候你希望运行一个程序时候在传递给它消息，这得靠传递命令行参数给main()函数实现。"></a>有时候你希望运行一个程序时候在传递给它消息，这得靠传递命令行参数给main()函数实现。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo01</span> &#123;</span><br><span class="line">    <span class="comment">//主方法 mian方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">          <span class="comment">//便利主方法内的数组长度</span></span><br><span class="line">          System.out.println(args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>命令行下执行</p>
<p>javac  包名.类名</p>
<p>java 包名.类名   参数</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/posts/ac4294eb.html</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态的格式："><a href="#多态的格式：" class="headerlink" title="多态的格式："></a>多态的格式：</h2><h3 id="父类名-对象名-new-子类的构造方法-传参"><a href="#父类名-对象名-new-子类的构造方法-传参" class="headerlink" title="父类名  对象名 &#x3D; new 子类的构造方法(传参);"></a>父类名  对象名 &#x3D; new 子类的构造方法(传参);</h3><h3 id="接口名-对象名-new-实现类名"><a href="#接口名-对象名-new-实现类名" class="headerlink" title="接口名  对象名 &#x3D; new  实现类名();"></a>接口名  对象名 &#x3D; new  实现类名();</h3><h2 id="多态创建的对象有什么特点？"><a href="#多态创建的对象有什么特点？" class="headerlink" title="多态创建的对象有什么特点？"></a>多态创建的对象有什么特点？</h2><ul>
<li><h4 id="使用变量：使用的是父类中的变量，调用不了子类中的变量"><a href="#使用变量：使用的是父类中的变量，调用不了子类中的变量" class="headerlink" title="使用变量：使用的是父类中的变量，调用不了子类中的变量"></a>使用变量：使用的是父类中的变量，调用不了子类中的变量</h4></li>
<li><h4 id="调用方法：调用的是子类中重写父类的方法-只有被重写的方法才能被调用到"><a href="#调用方法：调用的是子类中重写父类的方法-只有被重写的方法才能被调用到" class="headerlink" title="调用方法：调用的是子类中重写父类的方法(只有被重写的方法才能被调用到)"></a>调用方法：调用的是子类中重写父类的方法(只有被重写的方法才能被调用到)</h4></li>
</ul>
<p>​	</p>
<h3 id="多态的好处："><a href="#多态的好处：" class="headerlink" title="多态的好处："></a>多态的好处：</h3><h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><ul>
<li><h4 id="子类向父类转换-—–-自动转换"><a href="#子类向父类转换-—–-自动转换" class="headerlink" title="子类向父类转换 —– 自动转换"></a>子类向父类转换 —– 自动转换</h4></li>
<li><h4 id="父类向子类转换-—–-强制转换"><a href="#父类向子类转换-—–-强制转换" class="headerlink" title="父类向子类转换 —– 强制转换"></a>父类向子类转换 —– 强制转换</h4></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/posts/5729df21.html</url>
    <content><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><h5 id="指的是两个或多个事件在同一个时间段内发生。"><a href="#指的是两个或多个事件在同一个时间段内发生。" class="headerlink" title="指的是两个或多个事件在同一个时间段内发生。"></a>指的是两个或多个事件在同一个时间段内发生。</h5><h5 id="并发：交替执行，效率低"><a href="#并发：交替执行，效率低" class="headerlink" title="并发：交替执行，效率低"></a>并发：交替执行，效率低</h5><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><h5 id="指的是两个或多个事件在同一时刻发生-同时发生"><a href="#指的是两个或多个事件在同一时刻发生-同时发生" class="headerlink" title="指的是两个或多个事件在同一时刻发生(同时发生)"></a>指的是两个或多个事件在同一时刻发生(同时发生)</h5><h5 id="并行：同时执行，效率高"><a href="#并行：同时执行，效率高" class="headerlink" title="并行：同时执行，效率高"></a>并行：同时执行，效率高</h5><h4 id="进程：是指一个内存中云心的应用程序，没个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程页是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建运行到消亡的过程。"><a href="#进程：是指一个内存中云心的应用程序，没个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程页是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建运行到消亡的过程。" class="headerlink" title="进程：是指一个内存中云心的应用程序，没个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程页是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建运行到消亡的过程。"></a>进程：是指一个内存中云心的应用程序，没个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程页是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建运行到消亡的过程。</h4><h4 id="线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。"><a href="#线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。" class="headerlink" title="线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。"></a>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</h4><h5 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度:"></a>线程调度:</h5><p>1.分时调度 </p>
<p>​	所有线程轮流使用cpu的使用权，平均分配每个线程占用cpu的时间。</p>
<p>2.抢占式调度</p>
<p>​	优先让优先级高的线程使用cpu，如果线程的优先级相同，那么会随机选择一个(线程随机性)，java使用的为抢占式调度。</p>
<h4 id="主线程："><a href="#主线程：" class="headerlink" title="主线程："></a>主线程：</h4><p>执行主方法(main)的线程</p>
<p>单线程程序：java程序中只有一个线程</p>
<p>执行冲main方法开始，从上到下依次执行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲流、转换流、序列化流</title>
    <url>/posts/a3af51be.html</url>
    <content><![CDATA[<h1 id="【缓冲流、转换流、序列化流】"><a href="#【缓冲流、转换流、序列化流】" class="headerlink" title="【缓冲流、转换流、序列化流】"></a>【缓冲流、转换流、序列化流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>缓冲流</li>
<li>转换流</li>
<li>序列化流</li>
<li>打印流</li>
</ul>
<h1 id="第一章-缓冲流"><a href="#第一章-缓冲流" class="headerlink" title="第一章 缓冲流"></a>第一章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>);</span><br><span class="line">        	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">十几分钟过去了...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">	     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>

<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">		 <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  &#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;程序&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;员&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>

<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二章-转换流"><a href="#第二章-转换流" class="headerlink" title="第二章 转换流"></a>第二章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112042112877.jpg"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？ </p>
<h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));<span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));<span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\out.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">FileName2</span> <span class="operator">=</span> <span class="string">&quot;E:\\out2.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112042112138.jpg"></p>
<h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;      </span><br><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">     	<span class="type">String</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="string">&quot;file_gbk.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="string">&quot;file_utf8.txt&quot;</span>;</span><br><span class="line">		<span class="comment">// 2.创建流对象</span></span><br><span class="line">    	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile));</span><br><span class="line">		<span class="comment">// 3.读写数据</span></span><br><span class="line">    	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-序列化"><a href="#第三章-序列化" class="headerlink" title="第三章 序列化"></a>第三章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112042112146.jpg"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure>

<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">    	<span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializeDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">ois</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="第四章-打印流"><a href="#第四章-打印流" class="headerlink" title="第四章 打印流"></a>第四章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure>

<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字节流、字符流</title>
    <url>/posts/3966ff99.html</url>
    <content><![CDATA[<h1 id="字节流、字符流"><a href="#字节流、字符流" class="headerlink" title="字节流、字符流"></a>字节流、字符流</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>IO流</li>
<li>字节流</li>
<li>字符流</li>
<li>异常处理</li>
<li>Properties</li>
</ul>
<h1 id="第一章-IO概述"><a href="#第一章-IO概述" class="headerlink" title="第一章 IO概述"></a>第一章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p>
<p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。s</p>
<p>是</p>
<p>Java中I&#x2F;O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h2 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h2><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061759911.jpeg"></p>
<h2 id="1-4-顶级父类们"><a href="#1-4-顶级父类们" class="headerlink" title="1.4 顶级父类们"></a>1.4 顶级父类们</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<br /><strong>InputStream</strong></td>
<td align="center">字节输出流<br /><strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<br /><strong>Reader</strong></td>
<td align="center">字符输出流<br /><strong>Writer</strong></td>
</tr>
</tbody></table>
<h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamConstructor</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;黑马程序员&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马程序员</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>，<span class="literal">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p>
<p>以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamConstructor</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061800654.jpeg"></p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8</p>
</li>
<li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</li>
</ol>
</blockquote>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderConstructor</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FRRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑</span><br><span class="line">马</span><br><span class="line">程</span><br><span class="line">序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FRRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员序</span><br></pre></td></tr></table></figure>

<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。</li>
</ul>
<h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">char</span>[] chars = <span class="string">&quot;黑马程序员&quot;</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 黑马程序员</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//黑马程序员</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);	<span class="comment">// 程序</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>，<span class="literal">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">黑马</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleException1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">&#x27;;&#x27;</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleException2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">r1</span> <span class="operator">=</span> resource1;</span><br><span class="line">     <span class="type">Resource</span> <span class="variable">r2</span> <span class="operator">=</span> resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  <span class="type">FileReader</span> <span class="variable">fr</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li>
</ul>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure>

<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>小结回顾</title>
    <url>/posts/68bb2641.html</url>
    <content><![CDATA[<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h4><h5 id="类是一个模板：抽象，-对象是一个具体的实例"><a href="#类是一个模板：抽象，-对象是一个具体的实例" class="headerlink" title="类是一个模板：抽象， 对象是一个具体的实例"></a>类是一个模板：抽象， 对象是一个具体的实例</h5><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h4><h5 id="定义、调用！"><a href="#定义、调用！" class="headerlink" title="定义、调用！"></a>定义、调用！</h5><h4 id="3-对应的引用"><a href="#3-对应的引用" class="headerlink" title="3.对应的引用"></a>3.对应的引用</h4><h5 id="引用类型：-基本类型（四种八类）"><a href="#引用类型：-基本类型（四种八类）" class="headerlink" title="引用类型： 基本类型（四种八类）"></a>引用类型： 基本类型（四种八类）</h5><h5 id="对象是通过引用来操作的：栈-—→-堆"><a href="#对象是通过引用来操作的：栈-—→-堆" class="headerlink" title="对象是通过引用来操作的：栈  —→ 堆"></a>对象是通过引用来操作的：栈  —→ 堆</h5><h4 id="4-属性：字段Field-成员变量"><a href="#4-属性：字段Field-成员变量" class="headerlink" title="4.属性：字段Field 成员变量"></a>4.属性：字段Field 成员变量</h4><h5 id="默认初始化："><a href="#默认初始化：" class="headerlink" title="默认初始化："></a>默认初始化：</h5><h5 id="数字-0-0-0"><a href="#数字-0-0-0" class="headerlink" title="数字: 0  0.0"></a>数字: 0  0.0</h5><h5 id="char-u0000"><a href="#char-u0000" class="headerlink" title="char: u0000"></a>char: u0000</h5><h5 id="boolean-false"><a href="#boolean-false" class="headerlink" title="boolean: false"></a>boolean: false</h5><h5 id="引用：null"><a href="#引用：null" class="headerlink" title="引用：null"></a>引用：null</h5><h5 id="修饰符-属性类型-属性名-属性值"><a href="#修饰符-属性类型-属性名-属性值" class="headerlink" title="修饰符   属性类型  属性名 &#x3D; 属性值"></a>修饰符   属性类型  属性名 &#x3D; 属性值</h5><h4 id="5-对象的创建和使用"><a href="#5-对象的创建和使用" class="headerlink" title="5. 对象的创建和使用"></a>5. 对象的创建和使用</h4><ul>
<li><h5 id="必须使用new-关键字创建对象，构造器-Person-person-new-Person"><a href="#必须使用new-关键字创建对象，构造器-Person-person-new-Person" class="headerlink" title="必须使用new 关键字创建对象，构造器 Person  person &#x3D; new  Person(){}"></a>必须使用new 关键字创建对象，构造器 Person  person &#x3D; new  Person(){}</h5></li>
<li><h5 id="对象的属性-person-name"><a href="#对象的属性-person-name" class="headerlink" title="对象的属性 person.name"></a>对象的属性 person.name</h5></li>
<li><h5 id="对象的方法-person-sleep"><a href="#对象的方法-person-sleep" class="headerlink" title="对象的方法 person.sleep()"></a>对象的方法 person.sleep()</h5></li>
</ul>
<h4 id="6-类："><a href="#6-类：" class="headerlink" title="6.类："></a>6.类：</h4><h5 id="静态的属性属性"><a href="#静态的属性属性" class="headerlink" title="静态的属性		属性"></a>静态的属性		属性</h5><h5 id="动态的行为方法"><a href="#动态的行为方法" class="headerlink" title="动态的行为		方法"></a>动态的行为		方法</h5><h5 id="特性：-封装、继承、多态。"><a href="#特性：-封装、继承、多态。" class="headerlink" title="特性： 封装、继承、多态。"></a>特性： 封装、继承、多态。</h5>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>API和常用类</title>
    <url>/posts/d84486e7.html</url>
    <content><![CDATA[<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h5 id="java-lang-Object类是JAVA语言中，即所有类的父类。所有的子类都实现了Object类中的方法。"><a href="#java-lang-Object类是JAVA语言中，即所有类的父类。所有的子类都实现了Object类中的方法。" class="headerlink" title="java.lang.Object类是JAVA语言中，即所有类的父类。所有的子类都实现了Object类中的方法。"></a>java.lang.Object类是JAVA语言中，即所有类的父类。所有的子类都实现了Object类中的方法。</h5><h5 id="Object-是类层次结构的根-最顶层-类。每个类都是用Object作为超-父-类。"><a href="#Object-是类层次结构的根-最顶层-类。每个类都是用Object作为超-父-类。" class="headerlink" title="Object 是类层次结构的根(最顶层)类。每个类都是用Object作为超(父)类。"></a>Object 是类层次结构的根(最顶层)类。每个类都是用Object作为超(父)类。</h5><h5 id="所有对象-包括数组-都实现这个类的方法。"><a href="#所有对象-包括数组-都实现这个类的方法。" class="headerlink" title="所有对象(包括数组)都实现这个类的方法。"></a>所有对象(包括数组)都实现这个类的方法。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Person类继承了Object类，所以可以使用Object类中的toString方法</span></span><br><span class="line"><span class="comment">        * String toString();返回该对象的字符串表现</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> person.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//直接打印对象名的话就是调用了对象的toSting方法 person= person.toString();</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 看一个类是否重写了toSting方法，直接打印这个类的对象名即可</span></span><br><span class="line"><span class="comment">        * 如果没有重写，那么答应的就是对象的地址值(默认)</span></span><br><span class="line"><span class="comment">        * 如果重写了，那么按照重写的方式打印。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        System.out.println(r);<span class="comment">//java.util.Random没有重写toString方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(sc);<span class="comment">//java.util.Scanner重写了toString方法</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="equals比较"><a href="#equals比较" class="headerlink" title="equals比较"></a>equals比较</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Object类equals方法的源码：</span></span><br><span class="line"><span class="comment">        *   public boolean equals (Object obj)&#123;</span></span><br><span class="line"><span class="comment">        *       return(this == obj);</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * 参数：</span></span><br><span class="line"><span class="comment">        *   Object obj:可以传递任意对象</span></span><br><span class="line"><span class="comment">        * 方法体:</span></span><br><span class="line"><span class="comment">        *    == :比较运算符，返回的就是一个布尔值</span></span><br><span class="line"><span class="comment">        *   基本数据类型：比较的是值</span></span><br><span class="line"><span class="comment">        *   引用数据类型：比较的是两个对象的地址值</span></span><br><span class="line"><span class="comment">        *   this 那个对象调用的方法，方法中的this就是那个对象；</span></span><br><span class="line"><span class="comment">        *   p1调用的equals方法所以this 就是p1</span></span><br><span class="line"><span class="comment">        *   obj 是传递过来的参数 p2</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> p1.equals(p2);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Object类的equals方法默认比较的是两个对象的地址值，没有意义</span></span><br><span class="line"><span class="comment">        * 所以我们需要重写equals方法，比较两个对象的属性值 ，</span></span><br><span class="line"><span class="comment">        * 对象的属性一样就返回true，否则返回false</span></span><br><span class="line"><span class="comment">        *问题：</span></span><br><span class="line"><span class="comment">        *  隐含着一个多态</span></span><br><span class="line"><span class="comment">        *   Object obj = p2 = new Person(&quot;古力娜扎&quot;,“18”)；</span></span><br><span class="line"><span class="comment">        * 多态弊端 ： 无法使用子类特有的内容(属性和方法)</span></span><br><span class="line"><span class="comment">        * 解决： 可以使用向下转型(强转)要吧Object类型转换成 Person</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h4><h5 id="在JdK7-添加了一个Object工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save-空指针安全的-或null-tolerant-容忍空指针的-，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。"><a href="#在JdK7-添加了一个Object工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save-空指针安全的-或null-tolerant-容忍空指针的-，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。" class="headerlink" title="在JdK7  添加了一个Object工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant(容忍空指针的)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。"></a>在JdK7  添加了一个Object工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant(容忍空指针的)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</h5><h5 id="null-是不能调用方法的，会抛出空指针异常，-NullPointerException-null"><a href="#null-是不能调用方法的，会抛出空指针异常，-NullPointerException-null" class="headerlink" title="null 是不能调用方法的，会抛出空指针异常，(NullPointerException null)"></a>null 是不能调用方法的，会抛出空指针异常，(NullPointerException null)</h5><h5 id="Object类的equals方法：对两个对象进行比较，防止空指针异常。"><a href="#Object类的equals方法：对两个对象进行比较，防止空指针异常。" class="headerlink" title="Object类的equals方法：对两个对象进行比较，防止空指针异常。"></a>Object类的equals方法：对两个对象进行比较，防止空指针异常。</h5><h5 id="在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下："><a href="#在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：" class="headerlink" title="在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下："></a>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span><span class="comment">//:判断两个对象是否相等。</span></span><br><span class="line">    <span class="comment">//查看一下jdk自带源码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a!= <span class="literal">null</span>&amp;&amp;a.equals (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="Object类："><a href="#Object类：" class="headerlink" title="Object类："></a>Object类：</h4><h5 id="Obect类是所有类的父类，一个类都会直接或间接的继承自该类中提供的一些常用的方法！"><a href="#Obect类是所有类的父类，一个类都会直接或间接的继承自该类中提供的一些常用的方法！" class="headerlink" title="Obect类是所有类的父类，一个类都会直接或间接的继承自该类中提供的一些常用的方法！"></a>Obect类是所有类的父类，一个类都会直接或间接的继承自该类中提供的一些常用的方法！</h5><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><ul>
<li><h5 id="作用：打印对象的信息"><a href="#作用：打印对象的信息" class="headerlink" title="作用：打印对象的信息"></a>作用：打印对象的信息</h5><ul>
<li><h5 id="重写前：打印的是包名类名-地址值"><a href="#重写前：打印的是包名类名-地址值" class="headerlink" title="重写前：打印的是包名类名@地址值"></a>重写前：打印的是包名类名@地址值</h5></li>
<li><h5 id="重写后：打印的是对象中的属性值"><a href="#重写后：打印的是对象中的属性值" class="headerlink" title="重写后：打印的是对象中的属性值"></a>重写后：打印的是对象中的属性值</h5></li>
</ul>
</li>
</ul>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><ul>
<li><h5 id="作用：比较两个对象的信息"><a href="#作用：比较两个对象的信息" class="headerlink" title="作用：比较两个对象的信息"></a>作用：比较两个对象的信息</h5><ul>
<li><h5 id="重写前：比较的是对象的地址值"><a href="#重写前：比较的是对象的地址值" class="headerlink" title="重写前：比较的是对象的地址值"></a>重写前：比较的是对象的地址值</h5></li>
<li><h5 id="重写后：比较的是对象的属性值"><a href="#重写后：比较的是对象的属性值" class="headerlink" title="重写后：比较的是对象的属性值"></a>重写后：比较的是对象的属性值</h5></li>
</ul>
</li>
</ul>
<h4 id="Objects类-1"><a href="#Objects类-1" class="headerlink" title="Objects类"></a>Objects类</h4><ol>
<li><h5 id="equals-方法-1"><a href="#equals-方法-1" class="headerlink" title="equals()方法"></a>equals()方法</h5><ul>
<li><h5 id="作用：比较两个对象是否相同，但是它添加了一些健壮性的判断！"><a href="#作用：比较两个对象是否相同，但是它添加了一些健壮性的判断！" class="headerlink" title="作用：比较两个对象是否相同，但是它添加了一些健壮性的判断！"></a>作用：比较两个对象是否相同，但是它添加了一些健壮性的判断！</h5></li>
</ul>
</li>
</ol>
<h4 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h4><h5 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h5><h6 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h6><ul>
<li><h5 id="java-util-Date-表示日期和时间的类"><a href="#java-util-Date-表示日期和时间的类" class="headerlink" title="java.util.Date :表示日期和时间的类"></a>java.util.Date :表示日期和时间的类</h5></li>
<li><h5 id="类-Date-表示特定的瞬间，精确到毫秒。"><a href="#类-Date-表示特定的瞬间，精确到毫秒。" class="headerlink" title="类 Date 表示特定的瞬间，精确到毫秒。"></a>类 Date 表示特定的瞬间，精确到毫秒。</h5></li>
<li><h5 id="毫秒-千分之一秒-1000毫秒-1秒"><a href="#毫秒-千分之一秒-1000毫秒-1秒" class="headerlink" title="毫秒:千分之一秒 1000毫秒 &#x3D; 1秒"></a>毫秒:千分之一秒 1000毫秒 &#x3D; 1秒</h5></li>
<li><h5 id="特定的瞬间：一个时间点，一刹那瞬间"><a href="#特定的瞬间：一个时间点，一刹那瞬间" class="headerlink" title="特定的瞬间：一个时间点，一刹那瞬间"></a>特定的瞬间：一个时间点，一刹那瞬间</h5></li>
<li><h5 id="毫秒的作用：可以对事件和日期进行计算"><a href="#毫秒的作用：可以对事件和日期进行计算" class="headerlink" title="毫秒的作用：可以对事件和日期进行计算"></a>毫秒的作用：可以对事件和日期进行计算</h5></li>
<li><h5 id="2099-01-3到2088-01-01-中间一共有多少天"><a href="#2099-01-3到2088-01-01-中间一共有多少天" class="headerlink" title="2099-01-3到2088-01-01 中间一共有多少天"></a>2099-01-3到2088-01-01 中间一共有多少天</h5></li>
<li><h5 id="可以日期转换成毫秒进行计算，计算完毕，在把毫秒转换成日期"><a href="#可以日期转换成毫秒进行计算，计算完毕，在把毫秒转换成日期" class="headerlink" title="可以日期转换成毫秒进行计算，计算完毕，在把毫秒转换成日期"></a>可以日期转换成毫秒进行计算，计算完毕，在把毫秒转换成日期</h5></li>
<li><h5 id="把日期转换为毫秒："><a href="#把日期转换为毫秒：" class="headerlink" title="把日期转换为毫秒："></a>把日期转换为毫秒：</h5></li>
<li><pre><code>  ##### 当前日期: 2088-01-01
</code></pre>
</li>
<li><pre><code>  ##### 时间原点(0毫秒)：1970年1月1日00：00：00
</code></pre>
</li>
<li><pre><code>  ##### 就是计算当前日期到时间原点之间一共经历了多少毫秒
</code></pre>
</li>
<li><h5 id="注意事项：中国属于东八区，会把时间增加8小时"><a href="#注意事项：中国属于东八区，会把时间增加8小时" class="headerlink" title="注意事项：中国属于东八区，会把时间增加8小时"></a>注意事项：中国属于东八区，会把时间增加8小时</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.util.Date :表示日期和时间的类</span></span><br><span class="line"><span class="comment">*   类 Date 表示特定的瞬间，精确到毫秒。</span></span><br><span class="line"><span class="comment">*   毫秒:千分之一秒 1000毫秒 = 1秒</span></span><br><span class="line"><span class="comment">*   特定的瞬间：一个时间点，一刹那瞬间</span></span><br><span class="line"><span class="comment">*   毫秒的作用：可以对事件和日期进行计算</span></span><br><span class="line"><span class="comment">*   2099-01-3到2088-01-01 中间一共有多少天</span></span><br><span class="line"><span class="comment">*   可以日期转换成毫秒进行计算，计算完毕，在把毫秒转换成日期</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   把日期转换为毫秒：</span></span><br><span class="line"><span class="comment">*       当前日期: 2088-01-01</span></span><br><span class="line"><span class="comment">*       时间原点(0毫秒)：1970年1月1日00：00：00</span></span><br><span class="line"><span class="comment">*       就是计算当前日期到时间原点之间一共经历了多少毫秒</span></span><br><span class="line"><span class="comment">* 注意事项：中国属于东八区，会把时间增加8小时</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dete类的成员方法以及常用方法"><a href="#Dete类的成员方法以及常用方法" class="headerlink" title="Dete类的成员方法以及常用方法"></a>Dete类的成员方法以及常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]  args)</span> &#123;</span><br><span class="line">        demo1();</span><br><span class="line">        demo10();</span><br><span class="line">        demo02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Date类的成员方法</span></span><br><span class="line"><span class="comment">    * long getTime()把日期转换为毫秒(相当于System.currentTimeMillis())</span></span><br><span class="line"><span class="comment">        返回自 1970年 1 月 1日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</span></span><br><span class="line"><span class="comment">    * * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">        System.out.println(time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Date类带参数的构造方法</span></span><br><span class="line"><span class="comment">    Date(long date)：传递毫秒值，把毫秒转换为Date日期</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>);</span><br><span class="line">        System.out.println(d1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Date 类的空参数构造方法：</span></span><br><span class="line"><span class="comment">    *   Date()获取的就是当前系统的日期和时间。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><h5 id="java-text-DateFormat：是日期-时间格式化子类的抽象类"><a href="#java-text-DateFormat：是日期-时间格式化子类的抽象类" class="headerlink" title="java.text.DateFormat：是日期&#x2F;时间格式化子类的抽象类"></a>java.text.DateFormat：是日期&#x2F;时间格式化子类的抽象类</h5><h5 id="作用：格式化-也就是日期-→-文本-、解析-文本→日期"><a href="#作用：格式化-也就是日期-→-文本-、解析-文本→日期" class="headerlink" title="作用：格式化(也就是日期 →  文本)、解析(文本→日期)"></a>作用：格式化(也就是日期 →  文本)、解析(文本→日期)</h5><h5 id="成员方法："><a href="#成员方法：" class="headerlink" title="成员方法："></a>成员方法：</h5><h5 id="String-format-Date-date-按照指定的模式，吧Date日期，格式化为符合模式的字符串"><a href="#String-format-Date-date-按照指定的模式，吧Date日期，格式化为符合模式的字符串" class="headerlink" title="String format(Date date)按照指定的模式，吧Date日期，格式化为符合模式的字符串"></a>String format(Date date)按照指定的模式，吧Date日期，格式化为符合模式的字符串</h5><h5 id="Date-parse-String-source-把符合模式的字符串，解析为Date日期"><a href="#Date-parse-String-source-把符合模式的字符串，解析为Date日期" class="headerlink" title="Date parse(String source) 把符合模式的字符串，解析为Date日期"></a>Date parse(String source) 把符合模式的字符串，解析为Date日期</h5><h5 id="DateFormat类是以个抽象类，无法直接创建对象使用，可以使用DateFormat的子类"><a href="#DateFormat类是以个抽象类，无法直接创建对象使用，可以使用DateFormat的子类" class="headerlink" title="DateFormat类是以个抽象类，无法直接创建对象使用，可以使用DateFormat的子类"></a>DateFormat类是以个抽象类，无法直接创建对象使用，可以使用DateFormat的子类</h5><h5 id="java-text-SimpleFormat-String-pattern-用给定的模式和默认语言环境的日期格式符号构造-SimpleDateFormat。"><a href="#java-text-SimpleFormat-String-pattern-用给定的模式和默认语言环境的日期格式符号构造-SimpleDateFormat。" class="headerlink" title="java.text.SimpleFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。"></a>java.text.SimpleFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。</h5><h5 id="参数：String-pattern：传送指定的模式"><a href="#参数：String-pattern：传送指定的模式" class="headerlink" title="参数：String pattern：传送指定的模式"></a>参数：String pattern：传送指定的模式</h5><h5 id="模式：区分大小写"><a href="#模式：区分大小写" class="headerlink" title="模式：区分大小写"></a>模式：区分大小写</h5><ul>
<li><h5 id="y-年"><a href="#y-年" class="headerlink" title="y    年"></a>y    年</h5></li>
<li><h5 id="M-月"><a href="#M-月" class="headerlink" title="M  月"></a>M  月</h5></li>
<li><h5 id="d-日"><a href="#d-日" class="headerlink" title="d   日"></a>d   日</h5></li>
<li><h5 id="H-时"><a href="#H-时" class="headerlink" title="H   时"></a>H   时</h5></li>
<li><h5 id="m-分"><a href="#m-分" class="headerlink" title="m  分"></a>m  分</h5></li>
<li><h5 id="s-秒"><a href="#s-秒" class="headerlink" title="s   秒"></a>s   秒</h5></li>
</ul>
<h5 id="写对应的模式，会把模式替换为对应的日期和时间"><a href="#写对应的模式，会把模式替换为对应的日期和时间" class="headerlink" title="写对应的模式，会把模式替换为对应的日期和时间"></a>写对应的模式，会把模式替换为对应的日期和时间</h5><h5 id="“yyyy-MM–dd-HH-mm-ss”"><a href="#“yyyy-MM–dd-HH-mm-ss”" class="headerlink" title="“yyyy-MM–dd HH:mm:ss”"></a>“yyyy-MM–dd HH:mm:ss”</h5><h5 id="“yyyy年MM月dd日-HH时mm分ss秒”"><a href="#“yyyy年MM月dd日-HH时mm分ss秒”" class="headerlink" title="“yyyy年MM月dd日 HH时mm分ss秒”"></a>“yyyy年MM月dd日 HH时mm分ss秒”</h5><h5 id="注意-模式中的字母不能更改，连接模式的符号可以改变"><a href="#注意-模式中的字母不能更改，连接模式的符号可以改变" class="headerlink" title="注意:模式中的字母不能更改，连接模式的符号可以改变"></a>注意:模式中的字母不能更改，连接模式的符号可以改变</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用DateFormat类中的方法parse，把文本解析为日期</span></span><br><span class="line"><span class="comment">     * Date parse(String source)把符合模式的字符串，解析为Date日期</span></span><br><span class="line"><span class="comment">     * 使用步骤：</span></span><br><span class="line"><span class="comment">     *      1.创建SimpleDateFormat对象，构造方法中传递的指定模式</span></span><br><span class="line"><span class="comment">     *      2.调用SimpleDateFormat对象中的方法parse。把符合构造方法中模式的字符串，解析为Date日期</span></span><br><span class="line"><span class="comment">     *  注意:public Date parse(String source) throws ParseException</span></span><br><span class="line"><span class="comment">     * parse方法声明了一个异常叫ParseException解析异常</span></span><br><span class="line"><span class="comment">     * 如果字符串和构造方法中的模式不一样，那么程序就会抛出异常</span></span><br><span class="line"><span class="comment">     * 调用一个抛出了异常的方法，就必须处理这个异常，要么throws 继续声明抛出这个异常，要么try...catch自己处理这个异常</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo02</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-06-09 20:07:20&quot;</span>);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用DateFormat类中的方法format，把日期格式化为文本</span></span><br><span class="line"><span class="comment">    * String format(Date date)按照指定的模式，把Date日期，格式化为符合模式的字符串</span></span><br><span class="line"><span class="comment">    * 使用步骤：</span></span><br><span class="line"><span class="comment">    *   1.创建SimpleDateFormat对象，构造方法中传递指定的模式</span></span><br><span class="line"><span class="comment">    *   2.调用SimoleDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串(文本)</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建SimpleDateFormat对象，构造方法中传递指定的模式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 练习：</span></span><br><span class="line"><span class="comment">*   请使用日期时间相关的API，计算出一个人已经出生了多少天。</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">*   1.首先使用Scanner类中的方法next，获取出生日期</span></span><br><span class="line"><span class="comment">*   2. 使用DateFormat类中的方法paser，把字符串的出生日期解析为Date格式</span></span><br><span class="line"><span class="comment">*   3.把Date格式的出生日期转换为毫秒值</span></span><br><span class="line"><span class="comment">*   4.获取当前的日期，转换为毫秒值</span></span><br><span class="line"><span class="comment">*   5.使用当前日期的毫秒值-出生日期的毫秒值</span></span><br><span class="line"><span class="comment">*   6.把毫秒值的差值转换为天数(s/1000/60/60/24)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoDate11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">//使用Scanner类中的方法next，获取出生日期</span></span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入出生日期 格式为 yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">birthdayDateString</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">//使用DateFromat类中的方法paser，把字符串的出生日期解析为：Date格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthday</span> <span class="operator">=</span> sdf.parse(birthdayDateString);</span><br><span class="line">        <span class="comment">//3.把Date格式的出生日期转换为毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">birthdayTime</span> <span class="operator">=</span> birthday.getTime();</span><br><span class="line">        <span class="comment">//4.获取当前的日期，转换为毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">todayTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 5.使用当前日期的毫秒值-出生日期的毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> todayTime - birthdayTime;</span><br><span class="line">        <span class="comment">// 6.把毫秒值的差值转换为天数(s/1000/60/60/24)</span></span><br><span class="line">        System.out.println(time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="日历类："><a href="#日历类：" class="headerlink" title="日历类："></a>日历类：</h3><h4 id="java-util-Calendar类-日历类"><a href="#java-util-Calendar类-日历类" class="headerlink" title="java.util.Calendar类:日历类"></a>java.util.Calendar类:日历类</h4><h4 id="Calendar类是一个抽象类，里面提供了很多操作日历字段的方法-YEAR、MONTH、DAY-OF-MONTH、HOUR"><a href="#Calendar类是一个抽象类，里面提供了很多操作日历字段的方法-YEAR、MONTH、DAY-OF-MONTH、HOUR" class="headerlink" title="Calendar类是一个抽象类，里面提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR )"></a>Calendar类是一个抽象类，里面提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR )</h4><h4 id="Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance-，该方法返回了Calendar类的子类对象"><a href="#Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance-，该方法返回了Calendar类的子类对象" class="headerlink" title="Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，该方法返回了Calendar类的子类对象"></a>Calendar类无法直接创建对象使用，里面有一个静态方法叫做getInstance()，该方法返回了Calendar类的子类对象</h4><h4 id="static-Calendar-getInstance-使用默认时区和语言环境获得一个日历。"><a href="#static-Calendar-getInstance-使用默认时区和语言环境获得一个日历。" class="headerlink" title="static Calendar getInstance()使用默认时区和语言环境获得一个日历。"></a>static Calendar getInstance()使用默认时区和语言环境获得一个日历。</h4><p>​	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01Calendar</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">           <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//多态</span></span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类的成员方法"><a href="#Calendar类的成员方法" class="headerlink" title="Calendar类的成员方法:"></a>Calendar类的成员方法:</h3><ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get&#x2F;set方法"></a>get&#x2F;set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="currentTimeMillis方法"><a href="#currentTimeMillis方法" class="headerlink" title="currentTimeMillis方法"></a>currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arraycopy方法"><a href="#arraycopy方法" class="headerlink" title="arraycopy方法"></a>arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11SystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] src = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><h2 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p>如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StringBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder2</span> <span class="operator">=</span> builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="literal">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder类-1"><a href="#StringBuilder类-1" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><h2 id="字符串拼接问题-1"><a href="#字符串拼接问题-1" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p><img src="G:\BaiduNetdiskDownlo\02-Java语进阶\day01_Object类、常用API\课件资料\课件资料\就业班-day01-Object类、常用API\img\String拼接问题.bmp"></p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="StringBuilder概述-1"><a href="#StringBuilder概述-1" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="G:\BaiduNetdiskDownlo\02-Java语进阶\day01_Object类、常用API\课件资料\课件资料\就业班-day01-Object类、常用API\img\06-StringBuilder的原理.png" alt="06-StringBuilder的原理"></p>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法-1"><a href="#append方法-1" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StringBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder2</span> <span class="operator">=</span> builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="literal">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法-1"><a href="#toString方法-1" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>

<h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo18WrapperParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
<h1 id="【Collection、泛型】"><a href="#【Collection、泛型】" class="headerlink" title="【Collection、泛型】"></a>【Collection、泛型】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li>
<li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li>
<li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li>
<li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li>
<li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li>
<li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li>
<li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li>
<li><input disabled="" type="checkbox"> 能够理解泛型上下限</li>
<li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li>
</ul>
<h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="G:\BaiduNetdiskDownlo\02-Java语进阶\day02_Collection、泛型\课件资料\img\Collection集合体系图.png"></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="G:\BaiduNetdiskDownlo\02-Java语进阶\day02_Collection、泛型\课件资料\img\迭代器原理图.bmp"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBForDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;String&gt;&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;Integer&gt; &#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;MVP&gt; &#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMVP</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> MVP <span class="title function_">getMVP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClassDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">mvp</span> <span class="operator">=</span> my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         <span class="type">Integer</span> <span class="variable">mvp2</span> <span class="operator">=</span> my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span> &#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; MVP <span class="title function_">show2</span><span class="params">(MVP mvp)</span> &#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MyGenericMethod</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyGenericMethod</span>();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">getE</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp1</span> <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;String&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String e)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> <span class="title class_">MyImp2</span>&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list &#x3D; new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合综合案例"><a href="#集合综合案例" class="headerlink" title="集合综合案例"></a>集合综合案例</h1><h2 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">&quot;♥&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♣&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">&quot;小☺&quot;</span>);</span><br><span class="line">        pokerBox.add(<span class="string">&quot;大☠&quot;</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;田伯光：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;绿竹翁：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常的详解</title>
    <url>/posts/7792860f.html</url>
    <content><![CDATA[<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><h4 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h4><ul>
<li><h5 id="实际工作中，遇到的情况不可能是非常完美的。比如说：你写的某个模块，用户输入不一定符合你的要求，你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或者硬盘满了，等问题。"><a href="#实际工作中，遇到的情况不可能是非常完美的。比如说：你写的某个模块，用户输入不一定符合你的要求，你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或者硬盘满了，等问题。" class="headerlink" title="实际工作中，遇到的情况不可能是非常完美的。比如说：你写的某个模块，用户输入不一定符合你的要求，你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或者硬盘满了，等问题。"></a>实际工作中，遇到的情况不可能是非常完美的。比如说：你写的某个模块，用户输入不一定符合你的要求，你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序在跑着，内存或者硬盘满了，等问题。</h5></li>
<li><h5 id="软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。"><a href="#软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。" class="headerlink" title="软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。"></a>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。</h5></li>
<li><h5 id="异常指程序运行中出现的不期而至的各种状况：如文件找不到、网络连接失败、非法参数等。"><a href="#异常指程序运行中出现的不期而至的各种状况：如文件找不到、网络连接失败、非法参数等。" class="headerlink" title="异常指程序运行中出现的不期而至的各种状况：如文件找不到、网络连接失败、非法参数等。"></a>异常指程序运行中出现的不期而至的各种状况：如文件找不到、网络连接失败、非法参数等。</h5></li>
<li><h5 id="异常发生在程序运行期间，它影响了正常的程序执行流程。"><a href="#异常发生在程序运行期间，它影响了正常的程序执行流程。" class="headerlink" title="异常发生在程序运行期间，它影响了正常的程序执行流程。"></a>异常发生在程序运行期间，它影响了正常的程序执行流程。</h5></li>
</ul>
<h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><h4 id="要理解Java异常处理是如何工作的，需要掌握下列三种类型的异常："><a href="#要理解Java异常处理是如何工作的，需要掌握下列三种类型的异常：" class="headerlink" title="要理解Java异常处理是如何工作的，需要掌握下列三种类型的异常："></a>要理解Java异常处理是如何工作的，需要掌握下列三种类型的异常：</h4><ul>
<li><h5 id="检查性异常：最具有代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。"><a href="#检查性异常：最具有代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。" class="headerlink" title="检查性异常：最具有代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。"></a>检查性异常：最具有代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</h5></li>
<li><h5 id="运行时异常-运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。"><a href="#运行时异常-运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。" class="headerlink" title="运行时异常: 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。"></a>运行时异常: 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</h5></li>
<li><h5 id="错误ERROR：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到的。"><a href="#错误ERROR：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到的。" class="headerlink" title="错误ERROR：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到的。"></a>错误ERROR：错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</h5></li>
</ul>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><ul>
<li><h5 id="Java把异常当作对象来处理，并定义一个基类java-lang-Throwable作为所有异常的超类-祖宗类-。"><a href="#Java把异常当作对象来处理，并定义一个基类java-lang-Throwable作为所有异常的超类-祖宗类-。" class="headerlink" title="Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类(祖宗类)。"></a>Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类(祖宗类)。</h5></li>
<li><h5 id="在Java-API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。"><a href="#在Java-API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。" class="headerlink" title="在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。"></a>在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。</h5><p><img src="https://img-blog.csdnimg.cn/20210601200510879.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM2MDI2,size_16,color_FFFFFF,t_70#pic_center" alt="异常的所有分类"></p>
</li>
</ul>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul>
<li><h5 id="Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。"><a href="#Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。" class="headerlink" title="Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。"></a>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</h5></li>
<li><h5 id="Java虚拟机运行错误-Virtual-MachineError-，当Jvm不在有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机-JVM-一般会选择线程终止："><a href="#Java虚拟机运行错误-Virtual-MachineError-，当Jvm不在有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机-JVM-一般会选择线程终止：" class="headerlink" title="Java虚拟机运行错误(Virtual MachineError) ，当Jvm不在有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM) 一般会选择线程终止："></a>Java虚拟机运行错误(Virtual MachineError) ，当Jvm不在有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM) 一般会选择线程终止：</h5></li>
<li><h5 id="还有发生在虚拟机试图执行应用时，如类定义错误-NoClassDefFoundError-、链接错误-LinkageError-，这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。"><a href="#还有发生在虚拟机试图执行应用时，如类定义错误-NoClassDefFoundError-、链接错误-LinkageError-，这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。" class="headerlink" title="还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError)、链接错误(LinkageError)，这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。"></a>还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError)、链接错误(LinkageError)，这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</h5></li>
</ul>
<h3 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h3><h4 id="分为两种：运行时异常，非运行时异常"><a href="#分为两种：运行时异常，非运行时异常" class="headerlink" title="分为两种：运行时异常，非运行时异常"></a>分为两种：运行时异常，非运行时异常</h4><ul>
<li><h4 id="在Exception分支中有一个重要的子类RuntimeException-运行时异常"><a href="#在Exception分支中有一个重要的子类RuntimeException-运行时异常" class="headerlink" title="在Exception分支中有一个重要的子类RuntimeException(运行时异常)"></a>在Exception分支中有一个重要的子类RuntimeException(运行时异常)</h4><ul>
<li><h5 id="ArraylndexOutOfBoundsException-数组下标越界"><a href="#ArraylndexOutOfBoundsException-数组下标越界" class="headerlink" title="ArraylndexOutOfBoundsException(数组下标越界)"></a>ArraylndexOutOfBoundsException(数组下标越界)</h5></li>
<li><h5 id="NullPointerException-空指针异常"><a href="#NullPointerException-空指针异常" class="headerlink" title="NullPointerException(空指针异常)"></a>NullPointerException(空指针异常)</h5></li>
<li><h5 id="ArithmeticException-算术异常"><a href="#ArithmeticException-算术异常" class="headerlink" title="ArithmeticException(算术异常)"></a>ArithmeticException(算术异常)</h5></li>
<li><h5 id="MissingResourceExoception-丢失资源"><a href="#MissingResourceExoception-丢失资源" class="headerlink" title="MissingResourceExoception(丢失资源)"></a>MissingResourceExoception(丢失资源)</h5></li>
<li><h5 id="ClassNotFoundException-找不到类-等异常，这些异常时不检查异常，程序中可以选择捕获处理，也可以不处理。"><a href="#ClassNotFoundException-找不到类-等异常，这些异常时不检查异常，程序中可以选择捕获处理，也可以不处理。" class="headerlink" title="ClassNotFoundException(找不到类)等异常，这些异常时不检查异常，程序中可以选择捕获处理，也可以不处理。"></a>ClassNotFoundException(找不到类)等异常，这些异常时不检查异常，程序中可以选择捕获处理，也可以不处理。</h5></li>
<li><h5 id="这些异常一般是又程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；"><a href="#这些异常一般是又程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；" class="headerlink" title="这些异常一般是又程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；"></a>这些异常一般是又程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；</h5></li>
<li><h5 id="Error和Exception的区别："><a href="#Error和Exception的区别：" class="headerlink" title="Error和Exception的区别："></a>Error和Exception的区别：</h5><ul>
<li><h6 id="Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机，-jvm-一般会选择终止线程；"><a href="#Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机，-jvm-一般会选择终止线程；" class="headerlink" title="Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机，(jvm)一般会选择终止线程；"></a>Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机，(jvm)一般会选择终止线程；</h6></li>
<li><h6 id="Exception通常情况下是可以被程序处理的，而且在程序中应该尽可能的去处理这些异常。"><a href="#Exception通常情况下是可以被程序处理的，而且在程序中应该尽可能的去处理这些异常。" class="headerlink" title="Exception通常情况下是可以被程序处理的，而且在程序中应该尽可能的去处理这些异常。"></a>Exception通常情况下是可以被程序处理的，而且在程序中应该尽可能的去处理这些异常。</h6></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ul>
<li><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4></li>
<li><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4></li>
<li><h4 id="异常处理的五个关键字"><a href="#异常处理的五个关键字" class="headerlink" title="异常处理的五个关键字"></a>异常处理的五个关键字</h4><ul>
<li><h5 id="try、catch、finally、throw、throws"><a href="#try、catch、finally、throw、throws" class="headerlink" title="try、catch、finally、throw、throws"></a>try、catch、finally、throw、throws</h5></li>
</ul>
</li>
</ul>
<h5 id="try-监控区域-尝试着去处理某些异常"><a href="#try-监控区域-尝试着去处理某些异常" class="headerlink" title="try ( 监控区域 )尝试着去处理某些异常"></a>try ( 监控区域 )尝试着去处理某些异常</h5><h5 id="catch-用来捕获异常"><a href="#catch-用来捕获异常" class="headerlink" title="catch 用来捕获异常"></a>catch 用来捕获异常</h5><h5 id="finally-无论异常执不执行都会走的代码块"><a href="#finally-无论异常执不执行都会走的代码块" class="headerlink" title="finally 无论异常执不执行都会走的代码块"></a>finally 无论异常执不执行都会走的代码块</h5><h5 id="throw-抛出异常"><a href="#throw-抛出异常" class="headerlink" title="throw 抛出异常"></a>throw 抛出异常</h5><h5 id="throws-从方法上抛出异常"><a href="#throws-从方法上抛出异常" class="headerlink" title="throws 从方法上抛出异常"></a>throws 从方法上抛出异常</h5><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//监控区域</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;<span class="comment">//捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常，变量B不能为零&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//finally 可以不要， 一般使用时 在关闭 io流 资源关闭时使用、</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">            <span class="comment">// 假设要捕获多个异常： 从小到大 去捕获。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//监控区域</span></span><br><span class="line">           <span class="comment">// new Demo04().a();</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;<span class="comment">//捕获异常 catch（想要捕获的异常类型）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常，变量B不能为零&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Throwable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//finally 可以不要， 一般使用时 在关闭 io流 资源关闭时使用、</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span> <span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span> <span class="params">()</span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="快捷方式-选择要捕获的语句-Ctrl-ALT-t"><a href="#快捷方式-选择要捕获的语句-Ctrl-ALT-t" class="headerlink" title="快捷方式,选择要捕获的语句 Ctrl + ALT +t"></a>快捷方式,选择要捕获的语句 Ctrl + ALT +t</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       System.out.println(a/b);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();<span class="comment">//打印错误栈信息</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断抛出异常"><a href="#判断抛出异常" class="headerlink" title="判断抛出异常"></a>判断抛出异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">            <span class="comment">// 假设要捕获多个异常： 从小到大 去捕获。</span></span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//监控区域</span></span><br><span class="line">           <span class="comment">// new Demo04().a();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;<span class="comment">//主动抛出异常 throw throws</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();<span class="comment">//主动抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;<span class="comment">//捕获异常 catch（想要捕获的异常类型）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序出现异常，变量B不能为零&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Throwable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;<span class="comment">//处理善后工作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//finally 可以不要， 一般使用时 在关闭 io流 资源关闭时使用、</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span> <span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span> <span class="params">()</span>&#123;</span><br><span class="line">        a();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在方法中抛出异常"><a href="#在方法中抛出异常" class="headerlink" title="在方法中抛出异常"></a>在方法中抛出异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Demo04</span>().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设在方法中处理不了这个异常，那么我们就在方法上抛出异常</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">      <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;<span class="comment">//主动抛出异常 throw throws</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();<span class="comment">//主动抛出异常,一般在方法中使用</span></span><br><span class="line">         &#125;</span><br><span class="line">     System.out.println(a/b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构三大循环</title>
    <url>/posts/5f91e7e3.html</url>
    <content><![CDATA[<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h4><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><h5 id="while-是最基本的循环，他的结构为"><a href="#while-是最基本的循环，他的结构为" class="headerlink" title="while 是最基本的循环，他的结构为:"></a>while 是最基本的循环，他的结构为:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（不二表达式）&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环体内容&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="只要布尔表达式为TRUE，循环就会一直执行下去。"><a href="#只要布尔表达式为TRUE，循环就会一直执行下去。" class="headerlink" title="只要布尔表达式为TRUE，循环就会一直执行下去。"></a>只要布尔表达式为TRUE，循环就会一直执行下去。</h4><h4 id="我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。"><a href="#我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。" class="headerlink" title="我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。"></a>我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</h4><h4 id="少部分情况需要循环一直执行例如服务器响应监听。"><a href="#少部分情况需要循环一直执行例如服务器响应监听。" class="headerlink" title="少部分情况需要循环一直执行例如服务器响应监听。"></a>少部分情况需要循环一直执行例如服务器响应监听。</h4><h4 id="循环条件一直为TRUE就会造成死循环，我们正常的业务编程中应该尽量避免死循环，会影响程序性能或者造成程序卡死崩溃！"><a href="#循环条件一直为TRUE就会造成死循环，我们正常的业务编程中应该尽量避免死循环，会影响程序性能或者造成程序卡死崩溃！" class="headerlink" title="循环条件一直为TRUE就会造成死循环，我们正常的业务编程中应该尽量避免死循环，会影响程序性能或者造成程序卡死崩溃！"></a>循环条件一直为TRUE就会造成死循环，我们正常的业务编程中应该尽量避免死循环，会影响程序性能或者造成程序卡死崩溃！</h4><h3 id="do-while-循环-1"><a href="#do-while-循环-1" class="headerlink" title="do while 循环"></a>do while 循环</h3><h4 id="对于while-语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件也至少执行一次。"><a href="#对于while-语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件也至少执行一次。" class="headerlink" title="对于while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件也至少执行一次。"></a>对于while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件也至少执行一次。</h4><h4 id="do-while-循环和while循环相似，不同的是，do-while-循环至少执行一次。"><a href="#do-while-循环和while循环相似，不同的是，do-while-循环至少执行一次。" class="headerlink" title="do while 循环和while循环相似，不同的是，do while 循环至少执行一次。"></a>do while 循环和while循环相似，不同的是，do while 循环至少执行一次。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码语句，循环体&#125;while（布尔表达式）;</span></span><br></pre></td></tr></table></figure>

<h4 id="while和do-while的区别"><a href="#while和do-while的区别" class="headerlink" title="while和do while的区别:"></a>while和do while的区别:</h4><ol>
<li><p>while先判断后执行,do while是先执行后判断！</p>
</li>
<li><p>do while 总是保证循环体会之前被执行一次！这是他们的主要差别</p>
</li>
</ol>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="虽然所有循环体结构都可以用while或者do-while表示-但JAVA提供了另一种for循环-使一些循环结构变得更加简单"><a href="#虽然所有循环体结构都可以用while或者do-while表示-但JAVA提供了另一种for循环-使一些循环结构变得更加简单" class="headerlink" title="虽然所有循环体结构都可以用while或者do..while表示,但JAVA提供了另一种for循环,使一些循环结构变得更加简单"></a>虽然所有循环体结构都可以用while或者do..while表示,但JAVA提供了另一种for循环,使一些循环结构变得更加简单</h4><h4 id="for循环语句是支持跌代的一种通用结构-是最有效-最灵活的一种结构"><a href="#for循环语句是支持跌代的一种通用结构-是最有效-最灵活的一种结构" class="headerlink" title="for循环语句是支持跌代的一种通用结构,是最有效,最灵活的一种结构"></a>for循环语句是支持跌代的一种通用结构,是最有效,最灵活的一种结构</h4><h4 id="for-循执行的次数是在执行前就确定的代码语句"><a href="#for-循执行的次数是在执行前就确定的代码语句" class="headerlink" title="for 循执行的次数是在执行前就确定的代码语句:"></a>for 循执行的次数是在执行前就确定的代码语句:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新或步进语句)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码循环体;代码语句;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">while</span>(a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>; <span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;while 循环结束&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化 //条件判断 //迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System-out.println(<span class="string">&quot;for循环结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于-for-循环有以下几点说明："><a href="#关于-for-循环有以下几点说明：" class="headerlink" title="关于 for 循环有以下几点说明："></a>关于 for 循环有以下几点说明：</h4><h5 id="1-最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。-死循环"><a href="#1-最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。-死循环" class="headerlink" title="1.最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。(死循环)"></a>1.最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。(死循环)</h5><h5 id="2-然后检车布尔表达式的值，如果是true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。"><a href="#2-然后检车布尔表达式的值，如果是true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。" class="headerlink" title="2.然后检车布尔表达式的值，如果是true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。"></a>2.然后检车布尔表达式的值，如果是true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</h5><h5 id="3-执行一次循环后，更新循环控制变量-迭代因子控制循环变量的增减-。再次执行上面的过程。"><a href="#3-执行一次循环后，更新循环控制变量-迭代因子控制循环变量的增减-。再次执行上面的过程。" class="headerlink" title="3.执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减)。再次执行上面的过程。"></a>3.执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减)。再次执行上面的过程。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死循环</span></span><br><span class="line"><span class="keyword">for</span>(; ;)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo02</span> &#123;</span><br><span class="line">    <span class="comment">//输出1-1000被5整除的数字并一行显示4个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (i%(<span class="number">5</span>*<span class="number">3</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.println();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">          <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span>(j&lt;=<span class="number">1000</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.print(j + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j%<span class="number">20</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">// 0- 100 奇数 偶数、之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oddSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                oddSum+=i;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                evenSum+=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(evenSum);</span><br><span class="line">        System.out.println(oddSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo05</span> &#123;</span><br><span class="line"><span class="comment">// 9 9乘法表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot;*&quot;</span>+i+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增强for-循环"><a href="#增强for-循环" class="headerlink" title="增强for 循环"></a>增强for 循环</h4><h5 id="这里先做了解-之后数组和集合重点使用"><a href="#这里先做了解-之后数组和集合重点使用" class="headerlink" title="这里先做了解,之后数组和集合重点使用"></a>这里先做了解,之后数组和集合重点使用</h5><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(声明语句:表达式)&#123;</span><br><span class="line">//代码句子</span><br><span class="line">&#125;</span><br><span class="line">public class ForDemo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int [] num =&#123;10,20,30,40&#125;;//定义了一个数组</span><br><span class="line"></span><br><span class="line">        for (int i =0; i&lt;5 ; i++)&#123;</span><br><span class="line">            System.out.println(num[i]);</span><br><span class="line">            System.out.println(&quot;================&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历数组元素  增强for循环核心还是上者</span><br><span class="line">        for (int x :num)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域在循环语句块，其值与此时数组元素的值相等。"><a href="#声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域在循环语句块，其值与此时数组元素的值相等。" class="headerlink" title="声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域在循环语句块，其值与此时数组元素的值相等。"></a>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域在循环语句块，其值与此时数组元素的值相等。</h4><h4 id="表达式-表达式时要访问的数组名，或者是返回值为数组的方法。"><a href="#表达式-表达式时要访问的数组名，或者是返回值为数组的方法。" class="headerlink" title="表达式: 表达式时要访问的数组名，或者是返回值为数组的方法。"></a>表达式: 表达式时要访问的数组名，或者是返回值为数组的方法。</h4><h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><ul>
<li><h4 id="break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。-break语句也在switch语句中使用"><a href="#break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。-break语句也在switch语句中使用" class="headerlink" title="break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句也在switch语句中使用)"></a>break在任何循环语句的主体部分，均可用break控制循环的流程。<u>break用于强行退出循环</u>，不执行循环中剩余的语句。(break语句也在switch语句中使用)</h4></li>
<li><h4 id="continue-语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判断。"><a href="#continue-语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判断。" class="headerlink" title="continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判断。"></a>continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判断。</h4></li>
</ul>
<h3 id="关于goto关键字"><a href="#关于goto关键字" class="headerlink" title="关于goto关键字"></a>关于goto关键字</h3><ul>
<li><pre><code>#### goto关键字很早就在程序设计语言中出现。尽管goto仍是java的一个保留字，但并未在语言中得到正式使用；Java 没有goto，然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子---带标签的break和continue。
</code></pre>
</li>
<li><h4 id="“标签”是指后面跟一个冒号的标识符，例如：label："><a href="#“标签”是指后面跟一个冒号的标识符，例如：label：" class="headerlink" title="“标签”是指后面跟一个冒号的标识符，例如：label："></a>“标签”是指后面跟一个冒号的标识符，例如：label：</h4></li>
<li><h4 id="对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方。"><a href="#对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方。" class="headerlink" title="对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方。"></a>对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，他们就会中断到存在标签的地方。</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印101-105之间所有的质数</span></span><br><span class="line">        <span class="comment">//质数是指在大于1的自然数中，除了1和它本身以外不在有其他的自然数。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        outer:<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">101</span>; i &lt; <span class="number">150</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类的详情</title>
    <url>/posts/bcf3512a.html</url>
    <content><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="abstract-修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。"><a href="#abstract-修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。" class="headerlink" title="abstract 修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。"></a>abstract 修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。</h4><h4 id="抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。"><a href="#抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。" class="headerlink" title="抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。"></a>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</h4><h4 id="抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。"><a href="#抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。" class="headerlink" title="抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。"></a>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</h4><h4 id="抽象方法，只有方法的声明，没有方法的实现，他是用来让子类实现的，"><a href="#抽象方法，只有方法的声明，没有方法的实现，他是用来让子类实现的，" class="headerlink" title="抽象方法，只有方法的声明，没有方法的实现，他是用来让子类实现的，"></a>抽象方法，只有方法的声明，没有方法的实现，他是用来让子类实现的，</h4><h4 id="子类继承抽象类，那么必须要实现抽象类，没有实现的抽象方法，否则该子类也要声明为抽象类。"><a href="#子类继承抽象类，那么必须要实现抽象类，没有实现的抽象方法，否则该子类也要声明为抽象类。" class="headerlink" title="子类继承抽象类，那么必须要实现抽象类，没有实现的抽象方法，否则该子类也要声明为抽象类。"></a>子类继承抽象类，那么必须要实现抽象类，没有实现的抽象方法，否则该子类也要声明为抽象类。</h4><ol>
<li><h5 id="抽象类不能new对象，只能靠子类去实现他"><a href="#抽象类不能new对象，只能靠子类去实现他" class="headerlink" title="抽象类不能new对象，只能靠子类去实现他"></a>抽象类不能new对象，只能靠子类去实现他</h5></li>
<li><h5 id="抽象类中可以写普通方法"><a href="#抽象类中可以写普通方法" class="headerlink" title="抽象类中可以写普通方法"></a>抽象类中可以写普通方法</h5></li>
<li><h5 id="抽象方法必须在抽象类中。"><a href="#抽象方法必须在抽象类中。" class="headerlink" title="抽象方法必须在抽象类中。"></a>抽象方法必须在抽象类中。</h5></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>接口的定义和实现</title>
    <url>/posts/224e502b.html</url>
    <content><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><h5 id="抽象类：只有具体实现"><a href="#抽象类：只有具体实现" class="headerlink" title="抽象类：只有具体实现"></a>抽象类：只有具体实现</h5><h5 id="抽象类：具体实现和规范（抽象方法）都有"><a href="#抽象类：具体实现和规范（抽象方法）都有" class="headerlink" title="抽象类：具体实现和规范（抽象方法）都有"></a>抽象类：具体实现和规范（抽象方法）都有</h5><h5 id="接口：只有规范！自己无法写方法，专业的约束！约束和实现分离；面向接口编程"><a href="#接口：只有规范！自己无法写方法，专业的约束！约束和实现分离；面向接口编程" class="headerlink" title="接口：只有规范！自己无法写方法，专业的约束！约束和实现分离；面向接口编程~"></a>接口：只有规范！自己无法写方法，专业的约束！约束和实现分离；面向接口编程~</h5><h5 id="接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。"><a href="#接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。" class="headerlink" title="接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。"></a>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。</h5><h5 id="接口的本质是契约，就像我们人的法律一样。制定好后大家都遵守。"><a href="#接口的本质是契约，就像我们人的法律一样。制定好后大家都遵守。" class="headerlink" title="接口的本质是契约，就像我们人的法律一样。制定好后大家都遵守。"></a>接口的本质是契约，就像我们人的法律一样。制定好后大家都遵守。</h5><h5 id="精髓就是对对象的抽象，最能体现这一点的就是接口。"><a href="#精髓就是对对象的抽象，最能体现这一点的就是接口。" class="headerlink" title="精髓就是对对象的抽象，最能体现这一点的就是接口。"></a>精髓就是对对象的抽象，最能体现这一点的就是接口。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interfa 定义的关键字，接口都需要有实现类	</span></span><br><span class="line"><span class="comment">//接口中所有定义方法其实都是抽象的 public abstract	</span></span><br><span class="line"><span class="comment">//接口中定义的变量(属性)都是常量 public static final</span></span><br><span class="line"><span class="comment">//抽象类：extends  和 接口 实现 implements 接口</span></span><br><span class="line"><span class="comment">//实现了接口的类，就需要重写接口中的方法</span></span><br><span class="line"><span class="comment">//多继承，利用接口实现多继承。 </span></span><br></pre></td></tr></table></figure>

<h4 id="接口的作用："><a href="#接口的作用：" class="headerlink" title="接口的作用："></a>接口的作用：</h4><ol>
<li><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5></li>
<li><h5 id="定义一些方法，让不同的人实现"><a href="#定义一些方法，让不同的人实现" class="headerlink" title="定义一些方法，让不同的人实现~"></a>定义一些方法，让不同的人实现~</h5></li>
<li><h5 id="public-abstract-抽象"><a href="#public-abstract-抽象" class="headerlink" title="public  abstract 抽象"></a>public  abstract 抽象</h5></li>
<li><h5 id="public-static-final-常量"><a href="#public-static-final-常量" class="headerlink" title="public static final 常量"></a>public static final 常量</h5></li>
<li><h5 id="接口不能被实例化-接口中没有构造方法。"><a href="#接口不能被实例化-接口中没有构造方法。" class="headerlink" title="接口不能被实例化~接口中没有构造方法。"></a>接口不能被实例化~接口中没有构造方法。</h5></li>
<li><h5 id="implements-可以实现多个接口"><a href="#implements-可以实现多个接口" class="headerlink" title="implements 可以实现多个接口"></a>implements 可以实现多个接口</h5></li>
<li><h5 id="必须要重写接口中的方法-！！！"><a href="#必须要重写接口中的方法-！！！" class="headerlink" title="必须要重写接口中的方法~！！！"></a>必须要重写接口中的方法~！！！</h5></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/340249a9.html</url>
    <content><![CDATA[<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul>
<li><h5 id="数组是相同类型数据的有序集合"><a href="#数组是相同类型数据的有序集合" class="headerlink" title="数组是相同类型数据的有序集合"></a>数组是相同类型数据的有序集合</h5></li>
<li><h5 id="数组描述的是相同类型的若干个数据，按照一定的先后顺序排列组合而成。"><a href="#数组描述的是相同类型的若干个数据，按照一定的先后顺序排列组合而成。" class="headerlink" title="数组描述的是相同类型的若干个数据，按照一定的先后顺序排列组合而成。"></a>数组描述的是相同类型的若干个数据，按照一定的先后顺序排列组合而成。</h5></li>
<li><h5 id="其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问他们。"><a href="#其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问他们。" class="headerlink" title="其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问他们。"></a>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问他们。</h5></li>
</ul>
<h3 id="数组声明创建"><a href="#数组声明创建" class="headerlink" title="数组声明创建"></a>数组声明创建</h3><ul>
<li><h4 id="首先必须声明数组变量，才能在程序中使用数组。"><a href="#首先必须声明数组变量，才能在程序中使用数组。" class="headerlink" title="首先必须声明数组变量，才能在程序中使用数组。"></a>首先必须声明数组变量，才能在程序中使用数组。</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar; <span class="comment">//首选方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];<span class="comment">//效果相同但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="Java语言使用new操作符来创建数组，语法如下："><a href="#Java语言使用new操作符来创建数组，语法如下：" class="headerlink" title="Java语言使用new操作符来创建数组，语法如下："></a>Java语言使用new操作符来创建数组，语法如下：</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[]arrayRefVer = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="数组的元素是通过索引访问的，数组索引-下标值-从0开始。"><a href="#数组的元素是通过索引访问的，数组索引-下标值-从0开始。" class="headerlink" title="数组的元素是通过索引访问的，数组索引(下标值)从0开始。"></a>数组的元素是通过索引访问的，数组索引(下标值)从0开始。</h4></li>
<li><h4 id="获取数组的v长度-arrays-length"><a href="#获取数组的v长度-arrays-length" class="headerlink" title="获取数组的v长度 arrays.length"></a>获取数组的v长度 arrays.length</h4></li>
<li><h4 id="如果没有给数组某个元素赋值的话-默认值-为-类型的默认值"><a href="#如果没有给数组某个元素赋值的话-默认值-为-类型的默认值" class="headerlink" title="如果没有给数组某个元素赋值的话 默认值 为 类型的默认值"></a>如果没有给数组某个元素赋值的话 默认值 为 类型的默认值</h4></li>
</ul>
<table>
<thead>
<tr>
<th>int</th>
<th>double</th>
<th>String</th>
<th>boolean</th>
<th>char</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0.0</td>
<td>null</td>
<td>false</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] array ;<span class="comment">//定义一个数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];<span class="comment">//创建了一个数组，这里面可以存放10个int类型的数字</span></span><br><span class="line">    <span class="comment">//给数组元素赋值</span></span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">        array[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">        array[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">        array[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">        array[<span class="number">6</span>]=<span class="number">7</span>;</span><br><span class="line">        array[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">        array[<span class="number">8</span>]=<span class="number">9</span>;</span><br><span class="line">        array[<span class="number">9</span>]=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三种初始化"><a href="#三种初始化" class="headerlink" title="三种初始化"></a>三种初始化</h3><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] a =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">man [] mans = &#123;<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="number">2</span>,<span class="number">2</span>))&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] a = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h4><h5 id="数组是引用类型，他的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。"><a href="#数组是引用类型，他的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。" class="headerlink" title="数组是引用类型，他的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。"></a>数组是引用类型，他的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。</h5><ul>
<li><h3 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h3></li>
<li><h5 id="其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。"><a href="#其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。" class="headerlink" title="其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。"></a>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</h5></li>
<li><h5 id="其元素必须是相同类型，不允许出现混合类型。"><a href="#其元素必须是相同类型，不允许出现混合类型。" class="headerlink" title="其元素必须是相同类型，不允许出现混合类型。"></a>其元素必须是相同类型，不允许出现混合类型。</h5></li>
<li><h5 id="数组中的原始可以是任何数据类型，包括基本类型和引用类型。"><a href="#数组中的原始可以是任何数据类型，包括基本类型和引用类型。" class="headerlink" title="数组中的原始可以是任何数据类型，包括基本类型和引用类型。"></a>数组中的原始可以是任何数据类型，包括基本类型和引用类型。</h5></li>
<li><h5 id="数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。"><a href="#数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。" class="headerlink" title="数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。"></a>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</h5></li>
<li><h5 id="数组本身就是对象，java中的对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。"><a href="#数组本身就是对象，java中的对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。" class="headerlink" title="数组本身就是对象，java中的对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。"></a>数组本身就是对象，java中的对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。</h5></li>
</ul>
<h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul>
<li><h5 id="For-Each循环"><a href="#For-Each循环" class="headerlink" title="For -Each循环"></a>For -Each循环</h5></li>
<li><h5 id="数组作为方法入参数"><a href="#数组作为方法入参数" class="headerlink" title="数组作为方法入参数"></a>数组作为方法入参数</h5></li>
<li><h5 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTres</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] num = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;num.length;i++)&#123;<span class="comment">//打印数组内所有元素</span></span><br><span class="line">        System.out.println(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sun</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; num.length;i++)&#123;</span><br><span class="line">            sun +=num[i];</span><br><span class="line">            <span class="comment">//打印数组元素之和</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sum&quot;</span>+sun);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//输出数组元素最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]&gt;max)&#123;</span><br><span class="line">                max=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;max=&quot;</span>+max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组的进阶用法"><a href="#数组的进阶用法" class="headerlink" title="数组的进阶用法"></a>数组的进阶用法</h4><p>&#x2F;&#x2F;反转数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTres01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">int</span> [] num = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="comment">//        //进阶数组 ,jdk 1.5 后 适合打印数组 ，如果操作数组下标元素 不适合。</span></span><br><span class="line"><span class="comment">//        for (int i : num) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">       <span class="type">int</span>[] reverse = reverse(num);</span><br><span class="line">        printArray(reverse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse(<span class="type">int</span> [] arrays)&#123;</span><br><span class="line">        <span class="type">int</span> [] result = <span class="keyword">new</span> <span class="title class_">int</span>[arrays.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转数组的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = result.length-<span class="number">1</span>;i&lt; arrays.length;i++,j--)&#123;</span><br><span class="line">            result[j]= arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数组的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> [] arrays)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt; arrays.length;i++)&#123;</span><br><span class="line">            System.out.println(arrays[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h4 id="多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个以为数组"><a href="#多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个以为数组" class="headerlink" title="多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个以为数组"></a>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个以为数组</h4><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a [] [] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h4 id="解析：以上二维数组a可以看成一个两行五列的数组。"><a href="#解析：以上二维数组a可以看成一个两行五列的数组。" class="headerlink" title="解析：以上二维数组a可以看成一个两行五列的数组。"></a>解析：以上二维数组a可以看成一个两行五列的数组。</h4><h3 id="数组总共有八大排序"><a href="#数组总共有八大排序" class="headerlink" title="数组总共有八大排序!"></a>数组总共有八大排序!</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="冒泡排序无疑是最为出名的排序算法之一。"><a href="#冒泡排序无疑是最为出名的排序算法之一。" class="headerlink" title="冒泡排序无疑是最为出名的排序算法之一。"></a>冒泡排序无疑是最为出名的排序算法之一。</h5><h5 id="冒泡的代码还是相当简单的-，两层循环，外层冒泡轮数，里层依次比较，江湖人人皆知晓。"><a href="#冒泡的代码还是相当简单的-，两层循环，外层冒泡轮数，里层依次比较，江湖人人皆知晓。" class="headerlink" title="冒泡的代码还是相当简单的 ，两层循环，外层冒泡轮数，里层依次比较，江湖人人皆知晓。"></a>冒泡的代码还是相当简单的 ，两层循环，外层冒泡轮数，里层依次比较，江湖人人皆知晓。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 冒泡排序</span></span><br><span class="line"><span class="comment">    * 1.比较数组中，两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置</span></span><br><span class="line"><span class="comment">    * 2.每一次比较，都会产生出一个最大，或者最小的数字；</span></span><br><span class="line"><span class="comment">    * 3.下一轮则可以少一次排序！</span></span><br><span class="line"><span class="comment">    * 4.依次排序，知道结束！</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        <span class="type">int</span> [] sorts = sorts(a);</span><br><span class="line">        <span class="comment">//调用完我们自己写的排序方法以后，返回一个排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(sorts));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sorts(<span class="type">int</span> [] array)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//外层循环，判断我木门这个要走多少次;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j+<span class="number">1</span>]&gt;array[j])&#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 冒泡排序</span></span><br><span class="line"><span class="comment">         * 1.比较数组中，两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置</span></span><br><span class="line"><span class="comment">         * 2.每一次比较，都会产生出一个最大，或者最小的数字；</span></span><br><span class="line"><span class="comment">         * 3.下一轮则可以少一次排序！</span></span><br><span class="line"><span class="comment">         * 4.依次排序，知道结束！</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        <span class="type">int</span> [] sorts = sorts(a);</span><br><span class="line">        <span class="comment">//调用完我们自己写的排序方法以后，返回一个排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(sorts));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sorts(<span class="type">int</span> [] array)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">fans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//外层循环，判断我木门这个要走多少次;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j+<span class="number">1</span>]&gt;array[j])&#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                    fans=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">if</span> (fans==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><ul>
<li><h4 id="当一个数组中大部分元素为0，或者为统一值的数组时，可以用稀疏数组来保存该数组。"><a href="#当一个数组中大部分元素为0，或者为统一值的数组时，可以用稀疏数组来保存该数组。" class="headerlink" title="当一个数组中大部分元素为0，或者为统一值的数组时，可以用稀疏数组来保存该数组。"></a>当一个数组中大部分元素为0，或者为统一值的数组时，可以用稀疏数组来保存该数组。</h4></li>
<li><h4 id="稀疏数组的处理方式是："><a href="#稀疏数组的处理方式是：" class="headerlink" title="稀疏数组的处理方式是："></a>稀疏数组的处理方式是：</h4><ul>
<li><h5 id="记录数组一共有几行几列，有多少个不同的值"><a href="#记录数组一共有几行几列，有多少个不同的值" class="headerlink" title="记录数组一共有几行几列，有多少个不同的值"></a>记录数组一共有几行几列，有多少个不同的值</h5></li>
<li><h5 id="把具有不用值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模"><a href="#把具有不用值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模" class="headerlink" title="把具有不用值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模"></a>把具有不用值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</h5></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArratRet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建了一个二位数组 11* 11 0：没有棋子 1：黑棋 2：白棋</span></span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : array) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换为稀疏数组保存</span></span><br><span class="line">        <span class="comment">//获取有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">11</span> ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;有效值个数:&quot;</span>+sum);</span><br><span class="line">        <span class="comment">//创建一个稀疏数组的数组</span></span><br><span class="line">        <span class="type">int</span> [][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        array1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        array1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        array1[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//遍历二维数组，将非零的值，存放在稀疏数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;array[i].length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array1[count][<span class="number">0</span>]=i;</span><br><span class="line">                    array1[count][<span class="number">1</span>]=j;</span><br><span class="line">                    array1[count][<span class="number">2</span>]=array[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//输出稀疏数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;array1.length ; i++) &#123;</span><br><span class="line">            System.out.println(array1[i][<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span></span><br><span class="line">                            + array1[i][<span class="number">1</span>]</span><br><span class="line">                         +<span class="string">&quot;\t&quot;</span>+array1[i][<span class="number">2</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;还原&quot;</span>);</span><br><span class="line">        <span class="comment">//读取稀疏数组</span></span><br><span class="line">        <span class="type">int</span> [][] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1[<span class="number">0</span>][<span class="number">0</span>]][array1[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//给其中的元素还原值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array1.length; i++) &#123;</span><br><span class="line">            array2[array1[i][<span class="number">0</span>]][array1[i][<span class="number">1</span>]]=array1[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出还原的数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : array2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法的重载</title>
    <url>/posts/70ec998a.html</url>
    <content><![CDATA[<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><h4 id="方法的重载就是在一个类里面，有相同的方法名称-函数名称-，但形参不同的函数。"><a href="#方法的重载就是在一个类里面，有相同的方法名称-函数名称-，但形参不同的函数。" class="headerlink" title="方法的重载就是在一个类里面，有相同的方法名称(函数名称)，但形参不同的函数。"></a>方法的重载就是在一个类里面，有相同的方法名称(函数名称)，但形参不同的函数。</h4><h4 id="方法的重载的规则："><a href="#方法的重载的规则：" class="headerlink" title="方法的重载的规则："></a>方法的重载的规则：</h4><ul>
<li><h5 id="方法名称必须相同。"><a href="#方法名称必须相同。" class="headerlink" title="方法名称必须相同。"></a>方法名称必须相同。</h5></li>
<li><h5 id="参数列表必须不同-个数不同，或类型不同、参数排列顺序不同等"><a href="#参数列表必须不同-个数不同，或类型不同、参数排列顺序不同等" class="headerlink" title="参数列表必须不同(个数不同，或类型不同、参数排列顺序不同等)"></a>参数列表必须不同(个数不同，或类型不同、参数排列顺序不同等)</h5></li>
<li><h5 id="方法的返回值类型可以相同也可以不相同。"><a href="#方法的返回值类型可以相同也可以不相同。" class="headerlink" title="方法的返回值类型可以相同也可以不相同。"></a>方法的返回值类型可以相同也可以不相同。</h5></li>
<li><h5 id="仅仅返回值类型不同不足以成为方法的重载。"><a href="#仅仅返回值类型不同不足以成为方法的重载。" class="headerlink" title="仅仅返回值类型不同不足以成为方法的重载。"></a>仅仅返回值类型不同不足以成为方法的重载。</h5></li>
</ul>
<h4 id="实现理论："><a href="#实现理论：" class="headerlink" title="实现理论："></a>实现理论：</h4><h5 id="方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。"><a href="#方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。" class="headerlink" title="方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。"></a>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> add(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">       System.out.println(num);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">      	 <span class="keyword">return</span> a+b;</span><br><span class="line">  		 &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a+b;</span><br><span class="line"> 			  &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123; </span><br><span class="line">       <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>html基础</title>
    <url>/posts/1a147173.html</url>
    <content><![CDATA[<h3 id="什么是html5和它的优势"><a href="#什么是html5和它的优势" class="headerlink" title="什么是html5和它的优势"></a>什么是html5和它的优势</h3><h6 id="HTML5作为HTML的最新版本，是HTML的传递和延续。经历HTML4-0、XHTML再到HTML5从某种意义上讲，这是HTML超文本标签语言的更新与规范过程。因此，HTML5并没有给用户带来多大的冲击，大部分标签在HTML5版本中依然适用。"><a href="#HTML5作为HTML的最新版本，是HTML的传递和延续。经历HTML4-0、XHTML再到HTML5从某种意义上讲，这是HTML超文本标签语言的更新与规范过程。因此，HTML5并没有给用户带来多大的冲击，大部分标签在HTML5版本中依然适用。" class="headerlink" title="HTML5作为HTML的最新版本，是HTML的传递和延续。经历HTML4.0、XHTML再到HTML5从某种意义上讲，这是HTML超文本标签语言的更新与规范过程。因此，HTML5并没有给用户带来多大的冲击，大部分标签在HTML5版本中依然适用。"></a>HTML5作为HTML的最新版本，是HTML的传递和延续。经历HTML4.0、XHTML再到HTML5从某种意义上讲，这是HTML超文本标签语言的更新与规范过程。因此，HTML5并没有给用户带来多大的冲击，大部分标签在HTML5版本中依然适用。</h6><h6 id="HTML5的优势主要体现在兼容、合理、易用三个方面，本节将做具体介绍。"><a href="#HTML5的优势主要体现在兼容、合理、易用三个方面，本节将做具体介绍。" class="headerlink" title="HTML5的优势主要体现在兼容、合理、易用三个方面，本节将做具体介绍。"></a>HTML5的优势主要体现在兼容、合理、易用三个方面，本节将做具体介绍。</h6><h6 id="HTML5并不是对之前HTML语言颠覆性的革新，它的核心理念就是要保持与过去技术的完美衔接，因此HTML5有很好的兼容性。"><a href="#HTML5并不是对之前HTML语言颠覆性的革新，它的核心理念就是要保持与过去技术的完美衔接，因此HTML5有很好的兼容性。" class="headerlink" title="HTML5并不是对之前HTML语言颠覆性的革新，它的核心理念就是要保持与过去技术的完美衔接，因此HTML5有很好的兼容性。"></a>HTML5并不是对之前HTML语言颠覆性的革新，它的核心理念就是要保持与过去技术的完美衔接，因此HTML5有很好的兼容性。</h6><h6 id="HTML5中增加和删除的标签都是对现有的网页和用户习惯进行分析、概括而推出的作为当下流行的标签语言，HTML5严格遵循-“简单至上”的原则。"><a href="#HTML5中增加和删除的标签都是对现有的网页和用户习惯进行分析、概括而推出的作为当下流行的标签语言，HTML5严格遵循-“简单至上”的原则。" class="headerlink" title="HTML5中增加和删除的标签都是对现有的网页和用户习惯进行分析、概括而推出的作为当下流行的标签语言，HTML5严格遵循 “简单至上”的原则。"></a>HTML5中增加和删除的标签都是对现有的网页和用户习惯进行分析、概括而推出的作为当下流行的标签语言，HTML5严格遵循 “简单至上”的原则。</h6><h5 id="标签-位于文档的最前面，用于向浏览器说明当前文档使用哪种-HTML-或-XHTML-标准规范。"><a href="#标签-位于文档的最前面，用于向浏览器说明当前文档使用哪种-HTML-或-XHTML-标准规范。" class="headerlink" title="&lt;!DOCTYPE&gt;标签 位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范。"></a>&lt;!DOCTYPE&gt;标签 位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范。</h5><h5 id="标签-位于-标签之后，也称为根标签，用于告知浏览器其自身是一个-HTML-文档。"><a href="#标签-位于-标签之后，也称为根标签，用于告知浏览器其自身是一个-HTML-文档。" class="headerlink" title="&lt;html’&gt; 标签 位于&lt;!DOCTYPE&gt; 标签之后，也称为根标签，用于告知浏览器其自身是一个 HTML 文档。"></a>&lt;html’&gt; 标签 位于&lt;!DOCTYPE&gt; 标签之后，也称为根标签，用于告知浏览器其自身是一个 HTML 文档。</h5><h5 id="标签用于定定义HTML文档的头部信息，也称为头部标签，紧跟在“”标签之后，主要用来封装其他位于文档头部的标签。"><a href="#标签用于定定义HTML文档的头部信息，也称为头部标签，紧跟在“”标签之后，主要用来封装其他位于文档头部的标签。" class="headerlink" title="&lt;head’&gt;标签用于定定义HTML文档的头部信息，也称为头部标签，紧跟在“&lt;html’&gt;”标签之后，主要用来封装其他位于文档头部的标签。"></a>&lt;head’&gt;标签用于定定义HTML文档的头部信息，也称为头部标签，紧跟在“&lt;html’&gt;”标签之后，主要用来封装其他位于文档头部的标签。</h5><h5 id="标签用于定定义HTML文档所要显示的内容，也称为主体标签。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于标签内。"><a href="#标签用于定定义HTML文档所要显示的内容，也称为主体标签。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于标签内。" class="headerlink" title="&lt;body’&gt;标签用于定定义HTML文档所要显示的内容，也称为主体标签。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于&lt;body’&gt;标签内。"></a>&lt;body’&gt;标签用于定定义HTML文档所要显示的内容，也称为主体标签。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于&lt;body’&gt;标签内。</h5><h5 id="在HTML页面中，带有“-”符号的元素被称为HTML标签，如上面提到的“”、””、””都是HTML标签。所谓标签就是放在“-”符号中表示某个功能的编码命令，也称为HTML标签或HTML元素，本书统一称作HTML标签"><a href="#在HTML页面中，带有“-”符号的元素被称为HTML标签，如上面提到的“”、””、””都是HTML标签。所谓标签就是放在“-”符号中表示某个功能的编码命令，也称为HTML标签或HTML元素，本书统一称作HTML标签" class="headerlink" title="在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的“&lt;html’&gt;”、”&lt;head’&gt;”、”&lt;body’&gt;”都是HTML标签。所谓标签就是放在“&lt; &gt;”符号中表示某个功能的编码命令，也称为HTML标签或HTML元素，本书统一称作HTML标签"></a>在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的“&lt;html’&gt;”、”&lt;head’&gt;”、”&lt;body’&gt;”都是HTML标签。所谓标签就是放在“&lt; &gt;”符号中表示某个功能的编码命令，也称为HTML标签或HTML元素，本书统一称作HTML标签</h5><h4 id="标签概述"><a href="#标签概述" class="headerlink" title="标签概述"></a>标签概述</h4><h5 id="双标签也称体标签，是指由开始和结束两个标签符组成的标签。"><a href="#双标签也称体标签，是指由开始和结束两个标签符组成的标签。" class="headerlink" title="双标签也称体标签，是指由开始和结束两个标签符组成的标签。"></a>双标签也称体标签，是指由开始和结束两个标签符组成的标签。</h5><h5 id="单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。"><a href="#单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。" class="headerlink" title="单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。"></a>单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。</h5><h6 id="HTML标签的作用原理就是选择网页内容，从而进行描述，也就是说需要描述哪个元素，就选择哪个元素，所以才会有双标签的出现，用于定义标签作用的开始与结束。而单标签本身就可以描述一个功能，不需要选择。例如，水平线标签-按照双标签的语法，它应该写成“”，但是水平线标签不需要选择，本身就代表一条水平线，此时写成双标签就显得有点多余，但是又不能没有结束符号，所以在标签名称后面加一个关闭符，即。"><a href="#HTML标签的作用原理就是选择网页内容，从而进行描述，也就是说需要描述哪个元素，就选择哪个元素，所以才会有双标签的出现，用于定义标签作用的开始与结束。而单标签本身就可以描述一个功能，不需要选择。例如，水平线标签-按照双标签的语法，它应该写成“”，但是水平线标签不需要选择，本身就代表一条水平线，此时写成双标签就显得有点多余，但是又不能没有结束符号，所以在标签名称后面加一个关闭符，即。" class="headerlink" title="HTML标签的作用原理就是选择网页内容，从而进行描述，也就是说需要描述哪个元素，就选择哪个元素，所以才会有双标签的出现，用于定义标签作用的开始与结束。而单标签本身就可以描述一个功能，不需要选择。例如，水平线标签&lt;hr &#x2F;‘’&gt;,按照双标签的语法，它应该写成“&lt;hr’&gt;&lt;&#x2F;hr’&gt;”，但是水平线标签不需要选择，本身就代表一条水平线，此时写成双标签就显得有点多余，但是又不能没有结束符号，所以在标签名称后面加一个关闭符，即&lt;标签名 &#x2F;&gt;。"></a>HTML标签的作用原理就是选择网页内容，从而进行描述，也就是说需要描述哪个元素，就选择哪个元素，所以才会有双标签的出现，用于定义标签作用的开始与结束。而单标签本身就可以描述一个功能，不需要选择。例如，水平线标签&lt;hr &#x2F;‘’&gt;,按照双标签的语法，它应该写成“&lt;hr’&gt;&lt;&#x2F;hr’&gt;”，但是水平线标签不需要选择，本身就代表一条水平线，此时写成双标签就显得有点多余，但是又不能没有结束符号，所以在标签名称后面加一个关闭符，即&lt;标签名 &#x2F;&gt;。</h6><h4 id="标签的关系"><a href="#标签的关系" class="headerlink" title="标签的关系"></a>标签的关系</h4><h5 id="并列关系也称为兄弟关系，就是两个标签处于同一级别，并且没有包含关系。例如在HTML5的结构代码中，标签和标签就是并列关系。在HTML标签中，无论是单标签还是双标签，都可以拥有并列关系。"><a href="#并列关系也称为兄弟关系，就是两个标签处于同一级别，并且没有包含关系。例如在HTML5的结构代码中，标签和标签就是并列关系。在HTML标签中，无论是单标签还是双标签，都可以拥有并列关系。" class="headerlink" title="并列关系也称为兄弟关系，就是两个标签处于同一级别，并且没有包含关系。例如在HTML5的结构代码中，&lt;head’&gt;标签和&lt;body’&gt;标签就是并列关系。在HTML标签中，无论是单标签还是双标签，都可以拥有并列关系。"></a>并列关系也称为兄弟关系，就是两个标签处于同一级别，并且没有包含关系。例如在HTML5的结构代码中，&lt;head’&gt;标签和&lt;body’&gt;标签就是并列关系。在HTML标签中，无论是单标签还是双标签，都可以拥有并列关系。</h5><h4 id="标签的属性"><a href="#标签的属性" class="headerlink" title="标签的属性"></a>标签的属性</h4><h5 id="“键值对”可以理解为对“属性”设置“属性值”。键值对有多种表现形式，例如color-”red”-、width-200px-等，其中color和width即为“键值对”中的“键”（英文key），red和200px为“键值对”中的“值”（英文value）。“键值对”广泛地应用于编程中，HTML属性的定义形式“属性-”属性值””只是“键值对”中的一种。"><a href="#“键值对”可以理解为对“属性”设置“属性值”。键值对有多种表现形式，例如color-”red”-、width-200px-等，其中color和width即为“键值对”中的“键”（英文key），red和200px为“键值对”中的“值”（英文value）。“键值对”广泛地应用于编程中，HTML属性的定义形式“属性-”属性值””只是“键值对”中的一种。" class="headerlink" title="“键值对”可以理解为对“属性”设置“属性值”。键值对有多种表现形式，例如color&#x3D;”red” 、width:200px;等，其中color和width即为“键值对”中的“键”（英文key），red和200px为“键值对”中的“值”（英文value）。“键值对”广泛地应用于编程中，HTML属性的定义形式“属性&#x3D;”属性值””只是“键值对”中的一种。"></a>“键值对”可以理解为对“属性”设置“属性值”。键值对有多种表现形式，例如color&#x3D;”red” 、width:200px;等，其中color和width即为“键值对”中的“键”（英文key），red和200px为“键值对”中的“值”（英文value）。“键值对”广泛地应用于编程中，HTML属性的定义形式“属性&#x3D;”属性值””只是“键值对”中的一种。</h5><h4 id="HTML5文档头部相关标签"><a href="#HTML5文档头部相关标签" class="headerlink" title="HTML5文档头部相关标签"></a>HTML5文档头部相关标签</h4><h5 id="标签用于定义HTML页面的标题，即给网页取一个名字，必须位于标签之内。"><a href="#标签用于定义HTML页面的标题，即给网页取一个名字，必须位于标签之内。" class="headerlink" title="&lt;title‘&gt;标签用于定义HTML页面的标题，即给网页取一个名字，必须位于&lt;head’&gt;标签之内。"></a>&lt;title‘&gt;标签用于定义HTML页面的标题，即给网页取一个名字，必须位于&lt;head’&gt;标签之内。</h5><h5 id="标签用于定义页面的元信息，可重复出现在头部标签中。"><a href="#标签用于定义页面的元信息，可重复出现在头部标签中。" class="headerlink" title="&lt;‘meta &#x2F;&gt;标签用于定义页面的元信息，可重复出现在&lt;’head’&gt;头部标签中。"></a>&lt;‘meta &#x2F;&gt;标签用于定义页面的元信息，可重复出现在&lt;’head’&gt;头部标签中。</h5><h5 id="一个HTML文档只能含有一对标签，之间的内容将显示在浏览器窗口的标题栏中。"><a href="#一个HTML文档只能含有一对标签，之间的内容将显示在浏览器窗口的标题栏中。" class="headerlink" title="一个HTML文档只能含有一对&lt;title‘&gt;&lt;&#x2F;title’&gt;标签，&lt;title‘&gt;&lt;&#x2F;title’&gt;之间的内容将显示在浏览器窗口的标题栏中。"></a>一个HTML文档只能含有一对&lt;title‘&gt;&lt;&#x2F;title’&gt;标签，&lt;title‘&gt;&lt;&#x2F;title’&gt;之间的内容将显示在浏览器窗口的标题栏中。</h5><h5 id="网页标题名称"><a href="#网页标题名称" class="headerlink" title="&lt;title‘&gt;网页标题名称&lt;&#x2F;title’&gt;"></a>&lt;title‘&gt;网页标题名称&lt;&#x2F;title’&gt;</h5><h4 id="文本控制标签"><a href="#文本控制标签" class="headerlink" title="文本控制标签"></a>文本控制标签</h4><h5 id="无论网页内容如何丰富，文字自始至终都是网页中最基本的元素。为了使文字排版整齐、结构清晰，HTML中提供了一系列文本控制标签，如标题标签-、段落标签等"><a href="#无论网页内容如何丰富，文字自始至终都是网页中最基本的元素。为了使文字排版整齐、结构清晰，HTML中提供了一系列文本控制标签，如标题标签-、段落标签等" class="headerlink" title="无论网页内容如何丰富，文字自始至终都是网页中最基本的元素。为了使文字排版整齐、结构清晰，HTML中提供了一系列文本控制标签，如标题标签&lt;h1‘&gt;~&lt;h6’&gt;、段落标签&lt;P‘&gt;等"></a>无论网页内容如何丰富，文字自始至终都是网页中最基本的元素。为了使文字排版整齐、结构清晰，HTML中提供了一系列文本控制标签，如标题标签&lt;h1‘&gt;~&lt;h6’&gt;、段落标签&lt;P‘&gt;等</h5><h4 id="页面格式化标签"><a href="#页面格式化标签" class="headerlink" title="页面格式化标签"></a>页面格式化标签</h4><h5 id="HTML提供了6个等级的标题，即、、、、和，从到标题的重要性依次递减。"><a href="#HTML提供了6个等级的标题，即、、、、和，从到标题的重要性依次递减。" class="headerlink" title="HTML提供了6个等级的标题，即&lt;h1’&gt;、&lt;h2‘&gt;、&lt;h3’&gt;、&lt;h4‘&gt;、&lt;h5’&gt;和&lt;h6‘&gt;，从&lt;h1’&gt;到&lt;h6‘&gt;标题的重要性依次递减。"></a>HTML提供了6个等级的标题，即&lt;h1’&gt;、&lt;h2‘&gt;、&lt;h3’&gt;、&lt;h4‘&gt;、&lt;h5’&gt;和&lt;h6‘&gt;，从&lt;h1’&gt;到&lt;h6‘&gt;标题的重要性依次递减。</h5><h4 id="页面格式化标签-1"><a href="#页面格式化标签-1" class="headerlink" title="页面格式化标签"></a>页面格式化标签</h4><h5 id="在网页中使用标签来定义段落。标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。"><a href="#在网页中使用标签来定义段落。标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。" class="headerlink" title="在网页中使用标签来定义段落。&lt;p’&gt;标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。"></a>在网页中使用<p>标签来定义段落。&lt;p’&gt;标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;对齐方式&quot;</span>&gt;</span>段落文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。水平线可以通过标签来定义。"><a href="#在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。水平线可以通过标签来定义。" class="headerlink" title="在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。水平线可以通过&lt;hr &#x2F;’&gt;标签来定义。"></a>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。水平线可以通过&lt;hr &#x2F;’&gt;标签来定义。</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">属性</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">水平线标签</span><br><span class="line">在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。水平线可以通过<span class="tag">&lt;<span class="name">hr</span> /&gt;</span>标签来定义。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>含义</strong></th>
<th><strong>属性值</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>align</strong></td>
<td>设置水平线的对齐方式</td>
<td>可选择left、right、center三种值，默认为center，居中对齐显示。</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>设置水平线的粗细</td>
<td>以像素为单位，默认为2像素。</td>
</tr>
<tr>
<td><strong>color</strong></td>
<td>设置水平线的颜色</td>
<td>可用颜色名称、十六进制#RGB、rgb(r,g,b)。</td>
</tr>
<tr>
<td><strong>width</strong></td>
<td>设置水平线的宽度</td>
<td>可以是确定的像素值，也可以是浏览器窗口的百分比，默认为100%。</td>
</tr>
</tbody></table>
<h4 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h4><h5 id="在word中，按【Enter】键可以将一段文字换行显示，但在网页中，如果想要将某段文本强制换行显示，就需要使用换行标签。"><a href="#在word中，按【Enter】键可以将一段文字换行显示，但在网页中，如果想要将某段文本强制换行显示，就需要使用换行标签。" class="headerlink" title="在word中，按【Enter】键可以将一段文字换行显示，但在网页中，如果想要将某段文本强制换行显示，就需要使用换行标签。"></a>在word中，按【Enter】键可以将一段文字换行显示，但在网页中，如果想要将某段文本强制换行显示，就需要使用换行标签<br />。</h5><h4 id="文本样式标记"><a href="#文本样式标记" class="headerlink" title="文本样式标记"></a>文本样式标记</h4><h5 id="用来控制网页中文本的字体、字号和颜色。"><a href="#用来控制网页中文本的字体、字号和颜色。" class="headerlink" title="用来控制网页中文本的字体、字号和颜色。"></a>用来控制网页中文本的字体、字号和颜色。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font 属性=&quot;属性值&quot;&gt;文本内容&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<h5 id="文本样式标记常用属性"><a href="#文本样式标记常用属性" class="headerlink" title="文本样式标记常用属性"></a>文本样式标记常用属性</h5><table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>face</td>
<td>设置文字的字体，例如微软雅黑、黑体、宋体等</td>
</tr>
<tr>
<td>size</td>
<td>设置文字的大小，可以取1到7之间的整数值</td>
</tr>
<tr>
<td>color</td>
<td>设置文字的颜色</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>标记</strong></th>
<th><strong>显示效果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;b‘&gt;&lt;&#x2F;b’&gt;和&lt;strong‘&gt;&lt;&#x2F;strong’&gt;</td>
<td>文字以粗体方式显示（XHTML推荐使用strong）</td>
</tr>
<tr>
<td>&lt;i‘&gt;&lt;&#x2F;i’&gt;和&lt;em’&gt;&lt;&#x2F;em‘&gt;</td>
<td>文字以斜体方式显示（XHTML推荐使用em）</td>
</tr>
<tr>
<td>&lt;s‘&gt;&lt;&#x2F;s’&gt;和&lt;del’&gt;&lt;&#x2F;del‘&gt;</td>
<td>文字以加删除线方式显示（XHTML推荐使用del）</td>
</tr>
<tr>
<td>&lt;u‘&gt;&lt;&#x2F;u’&gt;和&lt;ins‘&gt;&lt;&#x2F;ins’&gt;</td>
<td>文字以加下划线方式显示（XHTML不赞成使用u）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>类型的转换</title>
    <url>/posts/6280299f.html</url>
    <content><![CDATA[<h1 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h1><h4 id="由于Java-是强类型语言，所以要进行有些运算的时候，需要用到类型转换"><a href="#由于Java-是强类型语言，所以要进行有些运算的时候，需要用到类型转换" class="headerlink" title="由于Java 是强类型语言，所以要进行有些运算的时候，需要用到类型转换"></a>由于Java 是强类型语言，所以要进行有些运算的时候，需要用到类型转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由低------------------------------到高</span><br><span class="line">byte → short → char → int → long → float → double</span><br></pre></td></tr></table></figure>

<h4 id="在运算中，不同类型的数据先转化为同一类型，然后进行运算。"><a href="#在运算中，不同类型的数据先转化为同一类型，然后进行运算。" class="headerlink" title="在运算中，不同类型的数据先转化为同一类型，然后进行运算。"></a>在运算中，不同类型的数据先转化为同一类型，然后进行运算。</h4><h3 id="强制类型转换和自动类型转换"><a href="#强制类型转换和自动类型转换" class="headerlink" title="强制类型转换和自动类型转换"></a>强制类型转换和自动类型转换</h3><p>注意点：</p>
<ol>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换位不相干的类型</li>
<li>在把高容量转换到低容量的时候，强制转换</li>
<li>在转换的时候可能存在内存溢出，或者精度问题！</li>
</ol>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>(类型)变量名     高到低</p>
<h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>由低—–高</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/posts/de7c53fe.html</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>等待与唤醒案例</li>
<li>线程池</li>
</ul>
<p>-[ ] 能够理解线程通信概念<br>-[ ] 能够理解等待唤醒机制<br>-[ ] 能够描述Java中线程池运行原理</p>
<h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312334084.bmp"></p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait&#x2F;notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="literal">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="literal">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="literal">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZi</span> &#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChiHuo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChiHuo</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="literal">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZiPu</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="literal">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        <span class="type">BaoZi</span> <span class="variable">bz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZi</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ChiHuo</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChiHuo</span>(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        <span class="type">BaoZiPu</span> <span class="variable">bzp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZiPu</span>(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>

<h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312335702.jpg"></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
<h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202110312335846.bmp"></p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义异常</title>
    <url>/posts/5f2e64d3.html</url>
    <content><![CDATA[<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="使用Java-内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。"><a href="#使用Java-内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。" class="headerlink" title="使用Java 内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。"></a>使用Java 内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需要继承Exception类即可。</h4><h4 id="在程序中使用自定义异常类，大体可分为以下几个步骤"><a href="#在程序中使用自定义异常类，大体可分为以下几个步骤" class="headerlink" title="在程序中使用自定义异常类，大体可分为以下几个步骤:"></a>在程序中使用自定义异常类，大体可分为以下几个步骤:</h4><ul>
<li><h5 id="创建自定义异常类"><a href="#创建自定义异常类" class="headerlink" title="创建自定义异常类"></a>创建自定义异常类</h5></li>
<li><h5 id="在方法中通过throw关键字抛出异常对象"><a href="#在方法中通过throw关键字抛出异常对象" class="headerlink" title="在方法中通过throw关键字抛出异常对象"></a>在方法中通过throw关键字抛出异常对象</h5></li>
<li><h5 id="如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并抛出处理；否则在方法的声明处通过throws关键字指明耀抛出给方法调用者的异常，继续进行下一步操作。"><a href="#如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并抛出处理；否则在方法的声明处通过throws关键字指明耀抛出给方法调用者的异常，继续进行下一步操作。" class="headerlink" title="如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并抛出处理；否则在方法的声明处通过throws关键字指明耀抛出给方法调用者的异常，继续进行下一步操作。"></a>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并抛出处理；否则在方法的声明处通过throws关键字指明耀抛出给方法调用者的异常，继续进行下一步操作。</h5></li>
<li><h5 id="在出现异常方法的调用者中捕获并处理异常"><a href="#在出现异常方法的调用者中捕获并处理异常" class="headerlink" title="在出现异常方法的调用者中捕获并处理异常"></a>在出现异常方法的调用者中捕获并处理异常</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">//传递数字&gt;10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo05</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.detail=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString 异常的打印信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Demo05&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//可能会存在异常的方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> Demo05 &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传递的参数为：&quot;</span>+a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Demo05</span>(a);<span class="comment">//抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Demo05 demo05) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;e&quot;</span>+demo05);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h4><ul>
<li><h5 id="处理运行时异常时，采用逻辑去合理规避同时辅助-try-catch-处理"><a href="#处理运行时异常时，采用逻辑去合理规避同时辅助-try-catch-处理" class="headerlink" title="处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理"></a>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理</h5></li>
<li><h5 id="在多重catch块后面，可以加一个catch-Exception-来处理可能被遗漏的异常"><a href="#在多重catch块后面，可以加一个catch-Exception-来处理可能被遗漏的异常" class="headerlink" title="在多重catch块后面，可以加一个catch(Exception)来处理可能被遗漏的异常"></a>在多重catch块后面，可以加一个catch(Exception)来处理可能被遗漏的异常</h5></li>
<li><h5 id="对于不确定的代码，也可以加上try-catch，处理潜在异常"><a href="#对于不确定的代码，也可以加上try-catch，处理潜在异常" class="headerlink" title="对于不确定的代码，也可以加上try-catch，处理潜在异常"></a>对于不确定的代码，也可以加上try-catch，处理潜在异常</h5></li>
<li><h5 id="尽量去处理异常，切忌只是简单的调用printStackTrace-去打印输出"><a href="#尽量去处理异常，切忌只是简单的调用printStackTrace-去打印输出" class="headerlink" title="尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出"></a>尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出</h5></li>
<li><h5 id="具体如何处理异常，要根据不同的业务需求和异常类型去决定"><a href="#具体如何处理异常，要根据不同的业务需求和异常类型去决定" class="headerlink" title="具体如何处理异常，要根据不同的业务需求和异常类型去决定"></a>具体如何处理异常，要根据不同的业务需求和异常类型去决定</h5></li>
<li><h5 id="尽量添加finally语句块去释放占用资源。"><a href="#尽量添加finally语句块去释放占用资源。" class="headerlink" title="尽量添加finally语句块去释放占用资源。"></a>尽量添加finally语句块去释放占用资源。</h5></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/posts/f29265a7.html</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h4 id="JAVA-语言支持如下运算符"><a href="#JAVA-语言支持如下运算符" class="headerlink" title="JAVA 语言支持如下运算符:"></a>JAVA 语言支持如下运算符:</h4><ul>
<li>算术运算符: +, -, * ,  &#x2F;, %, ++, –</li>
<li>赋值运算符 &#x3D;</li>
<li>关系运算符: &gt; ,  &lt; ,  &gt;&#x3D; , &lt;&#x3D; , &#x3D;&#x3D; , !&#x3D; instanceof</li>
<li>逻辑运算符：&amp;&amp;,||,!</li>
<li>位运算符:  &amp; , |  , ^ ，~，&gt;&gt;  ,  &lt;&lt;  ,   &gt;&gt;&gt;</li>
<li>条件运算符:    ？：</li>
<li>扩展赋值运算符:  +&#x3D;  -&#x3D;   *&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二元运算符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">System.out.println(a+b);</span><br><span class="line">System.out.println(a-b);</span><br><span class="line">System.out.println(a*b);</span><br><span class="line">System.out.println(a/b);</span><br><span class="line"><span class="comment">//关系运算符返回的结果为：正确，错误  布尔值</span></span><br><span class="line"><span class="comment">//取余，模运算</span></span><br><span class="line">System.out.println(c%a); <span class="comment">// c/a   25/10  = 2 ....5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//++自增 --自减</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> a++; <span class="comment">//执行完这行代码后，先给e赋值，在自增</span></span><br><span class="line"><span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> ++a; <span class="comment">//执行这行代码前 a先自增，然后在赋值给b</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;a &amp;&amp; b:&quot;</span>+(a&amp;&amp;b));<span class="comment">//逻辑与运算：两个变量都为真，结果才为true</span></span><br><span class="line">       System.out.println(<span class="string">&quot;a || b:&quot;</span>+(a||b));<span class="comment">//逻辑与运算：两个变量有一个为真，结果才为true</span></span><br><span class="line">       System.out.println(<span class="string">&quot;！(a &amp;&amp; b):&quot;</span>+!(a&amp;&amp;b));<span class="comment">//如果是真，则变为假，如果是假则变为真</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo08&#123;</span><br><span class="line">public static void main (String [] args)&#123;</span><br><span class="line">		</span><br><span class="line">		// x ? y : z</span><br><span class="line">		// 如果x == true ，则结果为y，否则结果为 Z</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/posts/f6491ffb.html</url>
    <content><![CDATA[<h1 id="【网络编程】"><a href="#【网络编程】" class="headerlink" title="【网络编程】"></a>【网络编程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>软件架构CS／BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C&#x2F;S结构</strong> ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808370.jpg"></p>
<p><strong>B&#x2F;S结构</strong> ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061809918.jpg"></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
</li>
<li><p><strong>TCP&#x2F;IP协议：</strong> 传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808665.jpg"></p>
<p>上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061809307.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061809581.jpg"></p>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。</li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。</li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808699.jpg"></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061810800.jpg">    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.jpg&quot;</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUPload_Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span>   <span class="variable">bos</span>   <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="type">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传完毕 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808010.jpg"></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;back ........&quot;</span>);</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="type">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] back = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808015.png"></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">    	<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">   	    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808039.jpg"></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808236.jpg"></p>
</li>
</ol>
<p>GET&#x2F;web&#x2F;index.html HTTP&#x2F;1.1是浏览器的请求消息。&#x2F;web&#x2F;index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"><span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">        <span class="type">byte</span>[] bytes= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061809682.png"></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Web</span>(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Web</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Web</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                        <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                <span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="type">byte</span>[] bytes= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061808029.png">图解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202112061814075.bmp" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>递 归</title>
    <url>/posts/fe53c3fa.html</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>递归分为两种，直接递归和间接递归。</li>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法,禁止递归</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01DiGui</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// a();</span></span><br><span class="line">		b(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment">	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo01DiGui</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//Demo01DiGui();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">	 * 4993</span></span><br><span class="line"><span class="comment">	 * 	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		b(++i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">	 * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a方法&quot;</span>);</span><br><span class="line">		a();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 &#x3D; num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      	<span class="comment">// 调用求和的方法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(num);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	   num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">      	   相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202111181931254.jpg"></p>
<blockquote>
<p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p>
</blockquote>
<h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul>
<li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">  	<span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">      	<span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getValue(n);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘为:&quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  判断:</span></span><br><span class="line"><span class="comment">      	  当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">      	  当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    		<span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录:&quot;</span>+file.getAbsolutePath());</span><br><span class="line">              	<span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir2</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.java&quot;</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>



<h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir3</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">  	<span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	<span class="keyword">return</span> f.getName().endsWith(<span class="string">&quot;.java&quot;</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/posts/a0b50c75.html</url>
    <content><![CDATA[<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li><h5 id="A方法调用B方法，我们很容易理解"><a href="#A方法调用B方法，我们很容易理解" class="headerlink" title="A方法调用B方法，我们很容易理解"></a>A方法调用B方法，我们很容易理解</h5></li>
<li><h5 id="递归就是：A方法调用A方法！就是自己调用自己"><a href="#递归就是：A方法调用A方法！就是自己调用自己" class="headerlink" title="递归就是：A方法调用A方法！就是自己调用自己"></a>递归就是：A方法调用A方法！就是自己调用自己</h5></li>
<li><h5 id="利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大地较少了程序代码量。递归的能力在于用有限的语句来定义定向的无限集合。"><a href="#利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大地较少了程序代码量。递归的能力在于用有限的语句来定义定向的无限集合。" class="headerlink" title="利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大地较少了程序代码量。递归的能力在于用有限的语句来定义定向的无限集合。"></a>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大地较少了程序代码量。递归的能力在于用有限的语句来定义定向的无限集合。</h5></li>
<li><h5 id="递归结构包括两个部分："><a href="#递归结构包括两个部分：" class="headerlink" title="递归结构包括两个部分："></a><u><strong>递归结构包括两个部分：</strong></u></h5><h5 id="递归头：什么时候不调用自身的方法。如果没有头，将陷入死循环。"><a href="#递归头：什么时候不调用自身的方法。如果没有头，将陷入死循环。" class="headerlink" title="递归头：什么时候不调用自身的方法。如果没有头，将陷入死循环。"></a><u><strong>递归头：什么时候不调用自身的方法。如果没有头，将陷入死循环。</strong></u></h5><h5 id="递归体：什么时候需要调用自身方法。"><a href="#递归体：什么时候需要调用自身方法。" class="headerlink" title="递归体：什么时候需要调用自身方法。"></a><u><strong>递归体：什么时候需要调用自身方法。</strong></u></h5><p>递归思想：</p>
<p>边界条件：边界</p>
<p>前阶段：</p>
<p>返回阶段：n*(n-1)</p>
<p>小阶段的可以使用，大阶段不推荐使用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFn</span> &#123;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(f(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的面对对象的三大特性</title>
    <url>/posts/bf990afe.html</url>
    <content><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><h4 id="该露的露，该藏的藏"><a href="#该露的露，该藏的藏" class="headerlink" title="该露的露，该藏的藏"></a>该露的露，该藏的藏</h4><ul>
<li><h5 id="我们程序设计要追求“高内聚，低耦合”。高内聚就是累的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。"><a href="#我们程序设计要追求“高内聚，低耦合”。高内聚就是累的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。" class="headerlink" title="我们程序设计要追求“高内聚，低耦合”。高内聚就是累的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。"></a>我们程序设计要追求“高内聚，低耦合”。高内聚就是累的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</h5></li>
</ul>
</li>
<li><h4 id="封装-数据的隐藏"><a href="#封装-数据的隐藏" class="headerlink" title="封装(数据的隐藏)"></a>封装(数据的隐藏)</h4><ul>
<li><h5 id="通常应禁止访问一个对象中数据的实际表达，而应通过操作接口来访问，这称为信息隐藏。"><a href="#通常应禁止访问一个对象中数据的实际表达，而应通过操作接口来访问，这称为信息隐藏。" class="headerlink" title="通常应禁止访问一个对象中数据的实际表达，而应通过操作接口来访问，这称为信息隐藏。"></a>通常应禁止访问一个对象中数据的实际表达，而应通过操作接口来访问，这称为信息隐藏。</h5></li>
</ul>
</li>
<li><h4 id="记住这句话就够了：属性私有get-set"><a href="#记住这句话就够了：属性私有get-set" class="headerlink" title="记住这句话就够了：属性私有get&#x2F;set"></a>记住这句话就够了：属性私有get&#x2F;set</h4><h4 id="private：-私有的"><a href="#private：-私有的" class="headerlink" title="private： 私有的"></a>private： 私有的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性私有</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//提供一些可以操作这个属性的方法</span></span><br><span class="line"><span class="comment">//提供一些public 的get set 方法</span></span><br><span class="line"><span class="comment">//get 获得这个数据</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set 给这个数据设置值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">快捷键ALT + INSERT</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="1-提高程序的安全性，保护数据"><a href="#1-提高程序的安全性，保护数据" class="headerlink" title="1.提高程序的安全性，保护数据"></a>1.提高程序的安全性，保护数据</h5><h5 id="2-隐藏代码的实现细节"><a href="#2-隐藏代码的实现细节" class="headerlink" title="2.隐藏代码的实现细节"></a>2.隐藏代码的实现细节</h5><h5 id="3-统一接口"><a href="#3-统一接口" class="headerlink" title="3.统一接口"></a>3.统一接口</h5><h5 id="4-系统可维护增加了"><a href="#4-系统可维护增加了" class="headerlink" title="4.系统可维护增加了"></a>4.系统可维护增加了</h5><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><h5 id="继承的本质是对某一批类的抽象，从而实现对现实时间更好的建模"><a href="#继承的本质是对某一批类的抽象，从而实现对现实时间更好的建模" class="headerlink" title="继承的本质是对某一批类的抽象，从而实现对现实时间更好的建模"></a>继承的本质是对某一批类的抽象，从而实现对现实时间更好的建模</h5></li>
<li><h5 id="extends的意思是”扩展”。子类是父类的扩展。"><a href="#extends的意思是”扩展”。子类是父类的扩展。" class="headerlink" title="extends的意思是”扩展”。子类是父类的扩展。"></a>extends的意思是”扩展”。子类是父类的扩展。</h5></li>
<li><h5 id="Java中的类只有单继承，没有多继承。"><a href="#Java中的类只有单继承，没有多继承。" class="headerlink" title="Java中的类只有单继承，没有多继承。"></a>Java中的类只有单继承，没有多继承。</h5></li>
<li><h5 id="继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。"><a href="#继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。" class="headerlink" title="继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。"></a>继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。</h5></li>
<li><h5 id="继承关系的两个类，一个为子类-派生类-，一个为父类-基类-。子类继承父类，使用关键字extends来表示。"><a href="#继承关系的两个类，一个为子类-派生类-，一个为父类-基类-。子类继承父类，使用关键字extends来表示。" class="headerlink" title="继承关系的两个类，一个为子类(派生类)，一个为父类(基类)。子类继承父类，使用关键字extends来表示。"></a>继承关系的两个类，一个为子类(派生类)，一个为父类(基类)。子类继承父类，使用关键字extends来表示。</h5></li>
<li><h5 id="子类和父类之间，从意义上来讲应该具有“is-a”的关系"><a href="#子类和父类之间，从意义上来讲应该具有“is-a”的关系" class="headerlink" title="子类和父类之间，从意义上来讲应该具有“is a”的关系"></a>子类和父类之间，从意义上来讲应该具有“is a”的关系</h5></li>
<li><h5 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h5></li>
<li><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5></li>
<li><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><h5 id="子类继承了父类就拥有了父类的全部方法"><a href="#子类继承了父类就拥有了父类的全部方法" class="headerlink" title="子类继承了父类就拥有了父类的全部方法"></a>子类继承了父类就拥有了父类的全部方法</h5></li>
</ul>
<h4 id="在java-中所有的类，都默认直接或间接继承了object"><a href="#在java-中所有的类，都默认直接或间接继承了object" class="headerlink" title="在java 中所有的类，都默认直接或间接继承了object"></a>在java 中所有的类，都默认直接或间接继承了object</h4><h4 id="私有修饰符修饰的类和变量无法被继承"><a href="#私有修饰符修饰的类和变量无法被继承" class="headerlink" title="私有修饰符修饰的类和变量无法被继承"></a>私有修饰符修饰的类和变量无法被继承</h4><h5 id="this-调用当前类"><a href="#this-调用当前类" class="headerlink" title="this. 调用当前类"></a>this. 调用当前类</h5><h5 id="super-调用父类"><a href="#super-调用父类" class="headerlink" title="super.调用父类"></a>super.调用父类</h5><h5 id="创建了子类对象时默认调用父类无参构造"><a href="#创建了子类对象时默认调用父类无参构造" class="headerlink" title="创建了子类对象时默认调用父类无参构造"></a>创建了子类对象时默认调用父类无参构造</h5><h5 id="在调用父类构造时，必须在子类构造第一行。"><a href="#在调用父类构造时，必须在子类构造第一行。" class="headerlink" title="在调用父类构造时，必须在子类构造第一行。"></a>在调用父类构造时，必须在子类构造第一行。</h5><h4 id="super注意点"><a href="#super注意点" class="headerlink" title="super注意点:"></a>super注意点:</h4><ol>
<li><h5 id="super调用父类的构造方法，必须在构造方法的第一个"><a href="#super调用父类的构造方法，必须在构造方法的第一个" class="headerlink" title="super调用父类的构造方法，必须在构造方法的第一个"></a>super调用父类的构造方法，必须在构造方法的第一个</h5></li>
<li><h5 id="super-必须只能出现在子类的方法或者构造方法中！"><a href="#super-必须只能出现在子类的方法或者构造方法中！" class="headerlink" title="super 必须只能出现在子类的方法或者构造方法中！"></a>super 必须只能出现在子类的方法或者构造方法中！</h5></li>
<li><h5 id="super和this不能同时调用构造方法"><a href="#super和this不能同时调用构造方法" class="headerlink" title="super和this不能同时调用构造方法"></a>super和this不能同时调用构造方法</h5><h5 id="this："><a href="#this：" class="headerlink" title="this："></a>this：</h5><h5 id="代表的对象不同"><a href="#代表的对象不同" class="headerlink" title="代表的对象不同:"></a>代表的对象不同:</h5><h5 id="this-本身调用者这个对象"><a href="#this-本身调用者这个对象" class="headerlink" title="this: 本身调用者这个对象"></a>this: 本身调用者这个对象</h5><h5 id="super-代表父类对象的应用"><a href="#super-代表父类对象的应用" class="headerlink" title="super 代表父类对象的应用"></a>super 代表父类对象的应用</h5><h5 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h5><h5 id="this-：-没有继承也可以使用"><a href="#this-：-没有继承也可以使用" class="headerlink" title="this ： 没有继承也可以使用"></a>this ： 没有继承也可以使用</h5><h5 id="super：只能在继承条件才可以使用"><a href="#super：只能在继承条件才可以使用" class="headerlink" title="super：只能在继承条件才可以使用"></a>super：只能在继承条件才可以使用</h5><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法:"></a>构造方法:</h5><h5 id="this-调用本类的构造"><a href="#this-调用本类的构造" class="headerlink" title="this();调用本类的构造"></a>this();调用本类的构造</h5><h5 id="super-调用父类的构造"><a href="#super-调用父类的构造" class="headerlink" title="super();调用父类的构造"></a>super();调用父类的构造</h5></li>
</ol>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><h4 id="Override-重写"><a href="#Override-重写" class="headerlink" title="Override 重写"></a>Override 重写</h4><h5 id="重写都是方法的重写，和属性无关。"><a href="#重写都是方法的重写，和属性无关。" class="headerlink" title="重写都是方法的重写，和属性无关。"></a>重写都是方法的重写，和属性无关。</h5><h4 id="静态的方法和非静态的方法区别很大，"><a href="#静态的方法和非静态的方法区别很大，" class="headerlink" title="静态的方法和非静态的方法区别很大，"></a>静态的方法和非静态的方法区别很大，</h4><h5 id="静态方法的调用之和左边，定义的数据类型有关"><a href="#静态方法的调用之和左边，定义的数据类型有关" class="headerlink" title="静态方法的调用之和左边，定义的数据类型有关"></a>静态方法的调用之和左边，定义的数据类型有关</h5><h4 id="重写：需要有继承关系，子类重写父类的方法！"><a href="#重写：需要有继承关系，子类重写父类的方法！" class="headerlink" title="重写：需要有继承关系，子类重写父类的方法！"></a>重写：需要有继承关系，子类重写父类的方法！</h4><ol>
<li><h5 id="方法名必须相同"><a href="#方法名必须相同" class="headerlink" title="方法名必须相同"></a>方法名必须相同</h5></li>
<li><h5 id="参数列表必须相同"><a href="#参数列表必须相同" class="headerlink" title="参数列表必须相同"></a>参数列表必须相同</h5></li>
<li><h5 id="修饰符：范围可以扩大-不能缩小-public-Protected-default-pricate"><a href="#修饰符：范围可以扩大-不能缩小-public-Protected-default-pricate" class="headerlink" title="修饰符：范围可以扩大 ;不能缩小  public &gt; Protected &gt;default&gt;pricate"></a>修饰符：范围可以扩大 ;不能缩小  public &gt; Protected &gt;default&gt;pricate</h5></li>
<li><h5 id="抛出的异常：范围，可以被缩小，但不能扩大"><a href="#抛出的异常：范围，可以被缩小，但不能扩大" class="headerlink" title="抛出的异常：范围，可以被缩小，但不能扩大"></a>抛出的异常：范围，可以被缩小，但不能扩大</h5></li>
</ol>
<h4 id="重写，子类的方法和父类必须一致，方法体不同"><a href="#重写，子类的方法和父类必须一致，方法体不同" class="headerlink" title="重写，子类的方法和父类必须一致，方法体不同"></a>重写，子类的方法和父类必须一致，方法体不同</h4><h4 id="为什么需要重写："><a href="#为什么需要重写：" class="headerlink" title="为什么需要重写："></a>为什么需要重写：</h4><ol>
<li><h5 id="父类的功能，子类不一定需要，或者不一定满足。"><a href="#父类的功能，子类不一定需要，或者不一定满足。" class="headerlink" title="父类的功能，子类不一定需要，或者不一定满足。"></a>父类的功能，子类不一定需要，或者不一定满足。</h5></li>
<li><h5 id="快捷键-ALT-Insert-：-override；"><a href="#快捷键-ALT-Insert-：-override；" class="headerlink" title="快捷键 ALT + Insert ： override；"></a>快捷键 ALT + Insert ： override；</h5></li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><h5 id="即同一方法可以根据发送对象的不同而采用多种不同的行为方式。"><a href="#即同一方法可以根据发送对象的不同而采用多种不同的行为方式。" class="headerlink" title="即同一方法可以根据发送对象的不同而采用多种不同的行为方式。"></a>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</h5></li>
<li><h5 id="一个对象的实际类型是确定的，但可以指向对象的引用类型有很多"><a href="#一个对象的实际类型是确定的，但可以指向对象的引用类型有很多" class="headerlink" title="一个对象的实际类型是确定的，但可以指向对象的引用类型有很多"></a>一个对象的实际类型是确定的，但可以指向对象的引用类型有很多</h5></li>
<li><h4 id="多态存在的条件"><a href="#多态存在的条件" class="headerlink" title="多态存在的条件"></a>多态存在的条件</h4><ul>
<li><h5 id="有继承关系"><a href="#有继承关系" class="headerlink" title="有继承关系"></a>有继承关系</h5></li>
<li><h5 id="子类重写父类的方法"><a href="#子类重写父类的方法" class="headerlink" title="子类重写父类的方法"></a>子类重写父类的方法</h5></li>
<li><h5 id="父类引用指向子类对象"><a href="#父类引用指向子类对象" class="headerlink" title="父类引用指向子类对象"></a>父类引用指向子类对象</h5></li>
</ul>
</li>
<li><h4 id="注意：多态是方法的多态，属性没有多态性"><a href="#注意：多态是方法的多态，属性没有多态性" class="headerlink" title="注意：多态是方法的多态，属性没有多态性"></a>注意：多态是方法的多态，属性没有多态性</h4></li>
<li><h5 id="一个对象的实际类型是确定的"><a href="#一个对象的实际类型是确定的" class="headerlink" title="一个对象的实际类型是确定的"></a>一个对象的实际类型是确定的</h5></li>
<li><h5 id="可以指向的引用类型就不确定了；父类的引用指向子类"><a href="#可以指向的引用类型就不确定了；父类的引用指向子类" class="headerlink" title="可以指向的引用类型就不确定了；父类的引用指向子类"></a>可以指向的引用类型就不确定了；父类的引用指向子类</h5></li>
<li><h5 id="子类能调用的方法都是自己的或者继承类的"><a href="#子类能调用的方法都是自己的或者继承类的" class="headerlink" title="子类能调用的方法都是自己的或者继承类的"></a>子类能调用的方法都是自己的或者继承类的</h5></li>
<li><h5 id="父类型，可以指向子类，但是不能调用子类独有的方法"><a href="#父类型，可以指向子类，但是不能调用子类独有的方法" class="headerlink" title="父类型，可以指向子类，但是不能调用子类独有的方法"></a>父类型，可以指向子类，但是不能调用子类独有的方法</h5></li>
<li><h5 id="对象能执行那些方法，主要看对象左边的类型，和右边关系不大！"><a href="#对象能执行那些方法，主要看对象左边的类型，和右边关系不大！" class="headerlink" title="对象能执行那些方法，主要看对象左边的类型，和右边关系不大！"></a>对象能执行那些方法，主要看对象左边的类型，和右边关系不大！</h5></li>
<li><h5 id="子类重写了父类的方法，执行子类的方法"><a href="#子类重写了父类的方法，执行子类的方法" class="headerlink" title="子类重写了父类的方法，执行子类的方法"></a>子类重写了父类的方法，执行子类的方法</h5></li>
</ul>
<h3 id="多态注意事项："><a href="#多态注意事项：" class="headerlink" title="多态注意事项："></a>多态注意事项：</h3><ol>
<li><h4 id="多态是方法的多态，属性没有多态"><a href="#多态是方法的多态，属性没有多态" class="headerlink" title="多态是方法的多态，属性没有多态"></a>多态是方法的多态，属性没有多态</h4></li>
<li><h4 id="父类和子类，有联系-类型转换异常ClassCastException"><a href="#父类和子类，有联系-类型转换异常ClassCastException" class="headerlink" title="父类和子类，有联系 类型转换异常ClassCastException"></a>父类和子类，有联系 类型转换异常ClassCastException</h4></li>
<li><h4 id="存在条件：继承关系，方法需要重写，父类引用指向子类对象！"><a href="#存在条件：继承关系，方法需要重写，父类引用指向子类对象！" class="headerlink" title="存在条件：继承关系，方法需要重写，父类引用指向子类对象！"></a>存在条件：继承关系，方法需要重写，父类引用指向子类对象！</h4><h4 id="不能被重写的方法："><a href="#不能被重写的方法：" class="headerlink" title="不能被重写的方法："></a>不能被重写的方法：</h4><ol>
<li><h5 id="static-方法属于类，他不属于实例"><a href="#static-方法属于类，他不属于实例" class="headerlink" title="static 方法属于类，他不属于实例"></a>static 方法属于类，他不属于实例</h5></li>
<li><h5 id="final-常量："><a href="#final-常量：" class="headerlink" title="final 常量："></a>final 常量：</h5></li>
<li><h5 id="private方法："><a href="#private方法：" class="headerlink" title="private方法："></a>private方法：</h5></li>
</ol>
</li>
</ol>
<h5 id="instanceof-类型转换-引用类型"><a href="#instanceof-类型转换-引用类型" class="headerlink" title="instanceof (类型转换)  引用类型"></a>instanceof (类型转换)  引用类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>   <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ear&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ear&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStent</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []ags)</span>&#123;</span><br><span class="line">            <span class="comment">//一个对象的实际类型是确定的</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            <span class="comment">//可以指向的引用类型就不确定了；父类的引用指向子类</span></span><br><span class="line">            <span class="type">Student</span>  <span class="variable">s1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="comment">//Person 父类型，可以指向子类，但是不能调用子类独有的方法</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">s3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对象能执行那些方法，主要看对象左边的类型，和右边关系不大！</span></span><br><span class="line">            <span class="comment">//子类重写了父类的方法，执行子类的方法</span></span><br><span class="line">            ((Student) s2).eat();<span class="comment">//父类向下强转</span></span><br><span class="line">            s1.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="父类引用指向子类的对象"><a href="#父类引用指向子类的对象" class="headerlink" title="父类引用指向子类的对象"></a>父类引用指向子类的对象</h5></li>
<li><h5 id="把子类转换为父类，向上转型"><a href="#把子类转换为父类，向上转型" class="headerlink" title="把子类转换为父类，向上转型"></a>把子类转换为父类，向上转型</h5></li>
<li><h5 id="把父类转换为子类，向下转型：强制转换"><a href="#把父类转换为子类，向下转型：强制转换" class="headerlink" title="把父类转换为子类，向下转型：强制转换"></a>把父类转换为子类，向下转型：强制转换</h5></li>
<li><h5 id="方便方法的调用，减少重复的代码"><a href="#方便方法的调用，减少重复的代码" class="headerlink" title="方便方法的调用，减少重复的代码"></a>方便方法的调用，减少重复的代码</h5></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/28239a8d.html</url>
    <content><![CDATA[<h3 id="面向过程-面向对象"><a href="#面向过程-面向对象" class="headerlink" title="面向过程&amp;面向对象"></a>面向过程&amp;面向对象</h3><ul>
<li><h4 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h4><ul>
<li><h5 id="步骤清晰简单，第一步做什么，第二步做什么"><a href="#步骤清晰简单，第一步做什么，第二步做什么" class="headerlink" title="步骤清晰简单，第一步做什么，第二步做什么"></a>步骤清晰简单，第一步做什么，第二步做什么</h5></li>
<li><h5 id="面对过程适合处理一些较为简单的问题"><a href="#面对过程适合处理一些较为简单的问题" class="headerlink" title="面对过程适合处理一些较为简单的问题"></a>面对过程适合处理一些较为简单的问题</h5></li>
</ul>
</li>
<li><h4 id="面对对象思想"><a href="#面对对象思想" class="headerlink" title="面对对象思想"></a>面对对象思想</h4><ul>
<li><h5 id="物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独的思考。最后，才对某个分类下的细节进行面对过程的思索。"><a href="#物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独的思考。最后，才对某个分类下的细节进行面对过程的思索。" class="headerlink" title="物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独的思考。最后，才对某个分类下的细节进行面对过程的思索。"></a>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独的思考。最后，才对某个分类下的细节进行面对过程的思索。</h5></li>
<li><h5 id="面对对象适合处复杂的问题，适合处理需要多人协同的问题"><a href="#面对对象适合处复杂的问题，适合处理需要多人协同的问题" class="headerlink" title="面对对象适合处复杂的问题，适合处理需要多人协同的问题"></a>面对对象适合处复杂的问题，适合处理需要多人协同的问题</h5></li>
</ul>
</li>
<li><h4 id="对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面对对象的思路来分析整个系统。但是，具体到微观操作，仍需要面向过程的思路去处理。"><a href="#对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面对对象的思路来分析整个系统。但是，具体到微观操作，仍需要面向过程的思路去处理。" class="headerlink" title="对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面对对象的思路来分析整个系统。但是，具体到微观操作，仍需要面向过程的思路去处理。"></a>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面对对象的思路来分析整个系统。但是，具体到微观操作，仍需要面向过程的思路去处理。</h4></li>
</ul>
<h3 id="什么是面对对象"><a href="#什么是面对对象" class="headerlink" title="什么是面对对象"></a>什么是面对对象</h3><ul>
<li><h5 id="面对对象编程-Object-Oriented-Programming-oop"><a href="#面对对象编程-Object-Oriented-Programming-oop" class="headerlink" title="面对对象编程(Object-Oriented Programming,oop)"></a>面对对象编程(Object-Oriented Programming,oop)</h5></li>
<li><h5 id="面向对象编程的本质就是：以类的方式组织代码，以对象的组织-封装-数据"><a href="#面向对象编程的本质就是：以类的方式组织代码，以对象的组织-封装-数据" class="headerlink" title="面向对象编程的本质就是：以类的方式组织代码，以对象的组织(封装)数据"></a>面向对象编程的本质就是：以类的方式组织代码，以对象的组织(封装)数据</h5></li>
<li><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul>
<li><h5 id="共性抽离"><a href="#共性抽离" class="headerlink" title="共性抽离"></a>共性抽离</h5></li>
</ul>
</li>
<li><h4 id="三大特性："><a href="#三大特性：" class="headerlink" title="三大特性："></a>三大特性：</h4><ul>
<li><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul>
<li>数据包装 数据封装</li>
</ul>
</li>
<li><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul>
<li>子类父类 父子关系</li>
</ul>
</li>
<li><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul>
<li>描述同一物体的多种形态</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="从认识论角度考虑是先有对象后有类。对象，是具体的事物。类是抽象的，是对对象的抽象"><a href="#从认识论角度考虑是先有对象后有类。对象，是具体的事物。类是抽象的，是对对象的抽象" class="headerlink" title="从认识论角度考虑是先有对象后有类。对象，是具体的事物。类是抽象的，是对对象的抽象"></a>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类是抽象的，是对对象的抽象</h5></li>
<li><h5 id="从代码运行角度考虑是先有类后有对象。类是对象的模板。"><a href="#从代码运行角度考虑是先有类后有对象。类是对象的模板。" class="headerlink" title="从代码运行角度考虑是先有类后有对象。类是对象的模板。"></a>从代码运行角度考虑是先有类后有对象。类是对象的模板。</h5></li>
</ul>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><h4 id="类是一种抽象的数据类型，他是对某一类事物整体描述-定义，但是并不能代表某一个具体的事物。"><a href="#类是一种抽象的数据类型，他是对某一类事物整体描述-定义，但是并不能代表某一个具体的事物。" class="headerlink" title="类是一种抽象的数据类型，他是对某一类事物整体描述&#x2F;定义，但是并不能代表某一个具体的事物。"></a>类是一种抽象的数据类型，他是对某一类事物整体描述&#x2F;定义，但是并不能代表某一个具体的事物。</h4><ul>
<li><h5 id="例如：-动物、植物、手机、电脑"><a href="#例如：-动物、植物、手机、电脑" class="headerlink" title="例如： 动物、植物、手机、电脑"></a>例如： 动物、植物、手机、电脑</h5></li>
<li><h5 id="例如：-Person类、pet类、car类等，这些类都是用来描述-定义某一类具体的事物应该具备的特点和行为。"><a href="#例如：-Person类、pet类、car类等，这些类都是用来描述-定义某一类具体的事物应该具备的特点和行为。" class="headerlink" title="例如： Person类、pet类、car类等，这些类都是用来描述\定义某一类具体的事物应该具备的特点和行为。"></a>例如： Person类、pet类、car类等，这些类都是用来描述\定义某一类具体的事物应该具备的特点和行为。</h5></li>
</ul>
<h4 id="对象是抽象概念的具体实例"><a href="#对象是抽象概念的具体实例" class="headerlink" title="对象是抽象概念的具体实例"></a>对象是抽象概念的具体实例</h4><h5 id="张三就是人的一个具体实例，张三家中的旺财就是狗的一个具体实例"><a href="#张三就是人的一个具体实例，张三家中的旺财就是狗的一个具体实例" class="headerlink" title="张三就是人的一个具体实例，张三家中的旺财就是狗的一个具体实例"></a>张三就是人的一个具体实例，张三家中的旺财就是狗的一个具体实例</h5><h5 id="能狗体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。"><a href="#能狗体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。" class="headerlink" title="能狗体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。"></a>能狗体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。</h5><h3 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h3><h4 id="使用new关键字创建对象"><a href="#使用new关键字创建对象" class="headerlink" title="使用new关键字创建对象"></a>使用new关键字创建对象</h4><h4 id="使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。"><a href="#使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。" class="headerlink" title="使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。"></a>使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</h4><h4 id="类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点："><a href="#类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：" class="headerlink" title="类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点："></a>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：</h4><ol>
<li><h5 id="必须和类的名字相同"><a href="#必须和类的名字相同" class="headerlink" title="必须和类的名字相同"></a>必须和类的名字相同</h5></li>
<li><h5 id="必须没有返回类型，也不能写void"><a href="#必须没有返回类型，也不能写void" class="headerlink" title="必须没有返回类型，也不能写void"></a>必须没有返回类型，也不能写void</h5><h5 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h5><p>注意：抽象实例化对象后 会有默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oop.demo01;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">     String name;</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;在学习&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//类 : 抽象的，实例化</span></span><br><span class="line">        <span class="comment">// 类实例化后会返回一个自己的对象</span></span><br><span class="line">        <span class="comment">//stydent对象就是一个Student类的具体实例！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaomin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaomin.name = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">        xiaomin.age = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="构造器-也叫构造方法"><a href="#构造器-也叫构造方法" class="headerlink" title="构造器 也叫构造方法"></a>构造器 也叫构造方法</h3><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><h5 id="1-和类名相同"><a href="#1-和类名相同" class="headerlink" title="1.和类名相同"></a>1.和类名相同</h5><h5 id="2-没有返回值"><a href="#2-没有返回值" class="headerlink" title="2.没有返回值"></a>2.没有返回值</h5><h4 id="this-当前类的-后面-的是传经来的参数。"><a href="#this-当前类的-后面-的是传经来的参数。" class="headerlink" title="this.当前类的 后面&#x3D; 的是传经来的参数。"></a>this.当前类的 后面&#x3D; 的是传经来的参数。</h4><h5 id="一个类即使什么都不写，它也会存在一个方法"><a href="#一个类即使什么都不写，它也会存在一个方法" class="headerlink" title="一个类即使什么都不写，它也会存在一个方法"></a>一个类即使什么都不写，它也会存在一个方法</h5><h5 id="显示的定义构造器"><a href="#显示的定义构造器" class="headerlink" title="显示的定义构造器"></a>显示的定义构造器</h5><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><h5 id="1-使用new关键字，本质是在调用构造器"><a href="#1-使用new关键字，本质是在调用构造器" class="headerlink" title="1.使用new关键字，本质是在调用构造器"></a>1.使用new关键字，本质是在调用构造器</h5><h5 id="2-用来初始化值"><a href="#2-用来初始化值" class="headerlink" title="2.用来初始化值"></a>2.用来初始化值</h5><h4 id="无参构造-类里面默认构造方法。"><a href="#无参构造-类里面默认构造方法。" class="headerlink" title="无参构造: 类里面默认构造方法。"></a>无参构造: 类里面默认构造方法。</h4><h4 id="有参构造：一旦定义了有参构造，无参构造就一定要存在。"><a href="#有参构造：一旦定义了有参构造，无参构造就一定要存在。" class="headerlink" title="有参构造：一旦定义了有参构造，无参构造就一定要存在。"></a>有参构造：一旦定义了有参构造，无参构造就一定要存在。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br><span class="line">快捷键 alt + insert</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">	<span class="comment">//new 实例化对象</span></span><br><span class="line">	<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序结构和IF选择结构</title>
    <url>/posts/d7363e83.html</url>
    <content><![CDATA[<p>​		</p>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul>
<li><h4 id="Java-的基本结构就是顺序结构，除非特别指明，否则这就按照顺序一句一句执行。"><a href="#Java-的基本结构就是顺序结构，除非特别指明，否则这就按照顺序一句一句执行。" class="headerlink" title="Java 的基本结构就是顺序结构，除非特别指明，否则这就按照顺序一句一句执行。"></a>Java 的基本结构就是顺序结构，除非特别指明，否则这就按照顺序一句一句执行。</h4></li>
<li><h4 id="顺序结构是最简单的算法结构。"><a href="#顺序结构是最简单的算法结构。" class="headerlink" title="顺序结构是最简单的算法结构。"></a>顺序结构是最简单的算法结构。</h4></li>
<li><h4 id="语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是有若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。"><a href="#语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是有若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。" class="headerlink" title="语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是有若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。"></a>语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是有若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。</h4></li>
</ul>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul>
<li><h4 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a>if单选择结构</h4></li>
<li><h4 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h4></li>
<li><h4 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h4></li>
<li><h4 id="嵌套的if结构"><a href="#嵌套的if结构" class="headerlink" title="嵌套的if结构"></a>嵌套的if结构</h4></li>
<li><h4 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h4><h4 id="if-单选择结构"><a href="#if-单选择结构" class="headerlink" title="if 单选择结构"></a>if 单选择结构</h4><h5 id="我们很多时候要去判断一个东西是否可行，然后我们才去执行，这样的一个过程中用if语句来表示"><a href="#我们很多时候要去判断一个东西是否可行，然后我们才去执行，这样的一个过程中用if语句来表示" class="headerlink" title="我们很多时候要去判断一个东西是否可行，然后我们才去执行，这样的一个过程中用if语句来表示"></a>我们很多时候要去判断一个东西是否可行，然后我们才去执行，这样的一个过程中用if语句来表示</h5><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果布尔表达式 为ture 将执行的语句称之为循环体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个内容&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//equals ：判断字符串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;Hlleo&quot;</span>))&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="if-双选择结构"><a href="#if-双选择结构" class="headerlink" title="if 双选择结构"></a>if 双选择结构</h3><h4 id="两个判断-if-else结构"><a href="#两个判断-if-else结构" class="headerlink" title="两个判断 if - else结构"></a>两个判断 if - else结构</h4><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">If(布尔表达式)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为true就运行这里的代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式的值为false就运行这里的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">60</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="if多选择结构-1"><a href="#if多选择结构-1" class="headerlink" title="if多选择结构"></a>if多选择结构</h3><h4 id="代码判断需求多的就需要用到-if-else-if"><a href="#代码判断需求多的就需要用到-if-else-if" class="headerlink" title="代码判断需求多的就需要用到 if else if"></a>代码判断需求多的就需要用到 if else if</h4><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式1的值为true执行这段代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式2的值为true执行这段代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式3的值为true执行这段代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果以上布尔表达式都不为true执行这段代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfelseifDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;=<span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;<span class="number">60</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的if结构-1"><a href="#嵌套的if结构-1" class="headerlink" title="嵌套的if结构"></a>嵌套的if结构</h3><h4 id="使用嵌套的if…else-语句是合法的，也就是说你可以在另外一个-if或者else-if-语句中使用if或者if-else-语句中使用if-或者-if-else-语句。你可以像-if-语句一样嵌套-else-if-…-else。"><a href="#使用嵌套的if…else-语句是合法的，也就是说你可以在另外一个-if或者else-if-语句中使用if或者if-else-语句中使用if-或者-if-else-语句。你可以像-if-语句一样嵌套-else-if-…-else。" class="headerlink" title="使用嵌套的if…else 语句是合法的，也就是说你可以在另外一个 if或者else if 语句中使用if或者if else 语句中使用if 或者 if else 语句。你可以像 if 语句一样嵌套 else if ….else。"></a>使用嵌套的if…else 语句是合法的，也就是说你可以在另外一个 if或者else if 语句中使用if或者if else 语句中使用if 或者 if else 语句。你可以像 if 语句一样嵌套 else if ….else。</h4><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式1的值为true 执行代码</span></span><br><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//如果布尔表达式2的值为true 执行代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch-多选择结构"><a href="#switch-多选择结构" class="headerlink" title="switch 多选择结构"></a>switch 多选择结构</h3><h4 id="多选择结构还有一个实现方式就是switch-case-语句"><a href="#多选择结构还有一个实现方式就是switch-case-语句" class="headerlink" title="多选择结构还有一个实现方式就是switch case 语句"></a>多选择结构还有一个实现方式就是switch case 语句</h4><h4 id="switch-case-语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。"><a href="#switch-case-语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。" class="headerlink" title="switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。"></a>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</h4><h5 id="switch-语句中的变量类型可以是："><a href="#switch-语句中的变量类型可以是：" class="headerlink" title="switch 语句中的变量类型可以是："></a>switch 语句中的变量类型可以是：</h5><h5 id="byte、short、int、或者char、也支持String-同时case-标签必须为字符串常量或者字面量"><a href="#byte、short、int、或者char、也支持String-同时case-标签必须为字符串常量或者字面量" class="headerlink" title="byte、short、int、或者char、也支持String 同时case 标签必须为字符串常量或者字面量"></a>byte、short、int、或者char、也支持String 同时case 标签必须为字符串常量或者字面量</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line"><span class="keyword">case</span> value :</span><br><span class="line">	<span class="comment">// 语句</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> value2 : </span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//你可以有任何数量的case语句</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">//可选</span></span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// case 穿透</span></span><br><span class="line">        <span class="comment">// switch 匹配一个具体值</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span><span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀3&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////String 类型</span></span><br><span class="line"><span class="comment">//字符的本质还是数字</span></span><br><span class="line"><span class="comment">//反编译  java ---- class(字节码文件) ---反编译(idea)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;Java&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Java&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;JAVA&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HTML&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;mysql&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/posts/54e1373e.html</url>
    <content><![CDATA[<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有住在南昌的女学生</span><br><span class="line">SELECT * from yd_student where sex=&#x27;女&#x27; and  address = &#x27;南昌&#x27;;</span><br><span class="line">-- 查询所有男生的信息</span><br><span class="line">SELECT * FROM yd_student WHERE sex=&#x27;男&#x27;;</span><br><span class="line">-- 查询所有女生的姓名，学号，地址</span><br><span class="line">SELECT name,sno,address FROM yd_student WHERE sex=&#x27;女&#x27;;</span><br><span class="line">-- 把南昌的女的学生删除</span><br><span class="line">DELETE from yd_student where sex=&#x27;女&#x27; and  address=&#x27;南昌&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询yd_user 按年龄排序</span><br><span class="line">SELECT * FROM yd_user ORDER BY age DESC;  -- 降序(大到小)</span><br><span class="line">SELECT * FROM yd_user ORDER BY age ASC;   -- 升序</span><br><span class="line"></span><br><span class="line">-- 分组查询</span><br><span class="line">SELECT * from yd_user GROUP BY sex,id;-- 分组查询</span><br><span class="line">-- 分组查询所有男生女生各有多少人</span><br><span class="line">SELECT sex,COUNT(sex) FROM yd_user GROUP BY sex;</span><br><span class="line">SELECT COUNT(*) from yd_user; -- 统计查询</span><br><span class="line">-- 分组查询，并且设置分组条件</span><br><span class="line">-- 1.查询按照性别分组后数量大于2的那个性别，输出性别及数量</span><br><span class="line">SELECT sex,COUNT(sex) from yd_user GROUP BY sex;</span><br><span class="line">HAVING COUNT(sex)&gt;2;</span><br><span class="line">-- 2.查询按照性别分组后年龄大于两岁，数量大于2的那个性别，输出性别及数量</span><br><span class="line">SELECT sex,COUNT(sex) from yd_user where age&gt;2 GROUP BY sex;</span><br><span class="line">HAVING COUNT(sex)&gt;2;</span><br><span class="line"></span><br><span class="line">-- 限制查询数量 limit</span><br><span class="line">-- 1.查前面两个人数据</span><br><span class="line">SELECT * from yd_user LIMIT 2;</span><br><span class="line">SELECT * from yd_user LIMIT 0,2;</span><br><span class="line">-- 2.查询从第二开始查询两条数据  前面的数字代表从第几条开始，后面的数字代表查询几条</span><br><span class="line">SELECT * from yd_user LIMIT 2,2;</span><br><span class="line">-- 3.查询从第二开始查询两条数据中的男的</span><br><span class="line">SELECT * from yd_user where sex=&#x27;男&#x27; LIMIT 2,2;</span><br><span class="line">-- 4查询从第二开始查询两条数据中的男的并按照年龄排序</span><br><span class="line">SELECT * from yd_user where sex=&#x27;男&#x27; ORDER BY age DESC LIMIT 0,3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 去除重复</span><br><span class="line">SELECT address from yd_student; -- 去除来自重复的地址</span><br><span class="line">SELECT DISTINCT address from yd_student; -- 地址</span><br><span class="line">SELECT DISTINCT name from yd_student;-- 名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 别名</span><br><span class="line">SELECT s.sex as &#x27;性别&#x27;,COUNT(*) as &#x27;总人数&#x27; from yd_student as s GROUP BY sex;-- 查询男生女生个有多少人数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT name as &#x27;姓名&#x27;,sex as&#x27;性别&#x27;,address as &#x27;地址&#x27; from yd_student;</span><br><span class="line"></span><br><span class="line">#查询工资&gt;12000的员工信息</span><br><span class="line">SELECT * from employees where salary&gt;12000;</span><br><span class="line">#查询部门编号不等于90的员工名和部门编号</span><br><span class="line">SELECT first_name,department_id from </span><br><span class="line">employees where department_id !=90;</span><br><span class="line">#查询工资在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT first_name,salary,commission_pct from </span><br><span class="line">employees where salary&gt;10000 and salary&lt;20000;</span><br><span class="line"></span><br><span class="line">SELECT first_name,salary,commission_pct from </span><br><span class="line">employees where salary BETWEEN 10000 and 20000;</span><br><span class="line">#查询部门编号不是在90到100之间，或者工资高于15000的员工信息</span><br><span class="line">SELECT * from employees where </span><br><span class="line">(department_id&lt;=90 and department_id&gt;=100) or salary&gt;15000;</span><br><span class="line">#查询员工last_name中包含字符a的员工信息</span><br><span class="line">SELECT * from employees where last_name like &quot;%a%&quot;;</span><br><span class="line">#查询员工last_name的第二个字符为a，第五个字符为e的员工信息</span><br><span class="line">SELECT * from employees where last_name like &quot;_a__e%&quot;;</span><br><span class="line">#查询员工last_name的第二个字符为_的员工信息</span><br><span class="line">SELECT * from employees where last_name like &quot;_\_%&quot;;</span><br><span class="line">#查询工资在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT first_name,salary,commission_pct from </span><br><span class="line">employees where salary&gt;10000 and salary&lt;20000;</span><br><span class="line">#查询员工的工种编号为 IT_PROG，AD_VP，AD_PRES中的一个的员工信息</span><br><span class="line">SELECT * from employees where </span><br><span class="line">job_id in(&#x27;IT_PROG&#x27;,&#x27;AD_VP&#x27;,&#x27;AD_PRES&#x27;);</span><br><span class="line"></span><br><span class="line">#查询没有奖金的员工信息</span><br><span class="line">select * from employees where commission_pct is null;</span><br><span class="line">#查询有奖金的员工信息</span><br><span class="line">select * from employees where commission_pct is not null; </span><br><span class="line">#查询员工号为176的员工的姓名、部门号和年薪</span><br><span class="line">select last_name,first_name,job_id from employees where employee_id = 176;</span><br><span class="line"></span><br><span class="line">#查询年龄最大的那个人</span><br><span class="line"></span><br><span class="line">Select max(age) from yd_user ;</span><br><span class="line"></span><br><span class="line">#查询年纪最小的那个人</span><br><span class="line"></span><br><span class="line">select min(min) from yd_user;</span><br><span class="line"></span><br><span class="line">#统计所有岁数的和</span><br><span class="line">select SUM(age) from yd_user;</span><br><span class="line"></span><br><span class="line">#查询数据库yd_users age 内为 2，3，30</span><br><span class="line">SELECT * FROM yd_users WHERE age in(2,3,30);</span><br><span class="line">#查询数据库yd_users age 内不为 2，3，30</span><br><span class="line">SELECT * FROM yd_users WHERE age  NOT	in(2,3,30);</span><br><span class="line">#查询数据库yd_users age 内字符串为空</span><br><span class="line">SELECT * FROM yd_users WHERE age = &#x27; &#x27;;</span><br><span class="line">#查询数据库yd_users age 内为null的值</span><br><span class="line">SELECT *FROM yd_users WHERE age is NULL;</span><br><span class="line">#查询数据库yd_users age 内为不为null的值</span><br><span class="line">SELECT * FROM yd_users WHERE age is not null;</span><br><span class="line">#查询性别不是男的人</span><br><span class="line">SELECT * FROM yd_users WHERE sex != &#x27;男&#x27;;</span><br><span class="line">SELECT * FROM yd_users WHERE sex &lt;&gt; &#x27;男&#x27;;</span><br><span class="line">#模糊查询</span><br><span class="line">#查询名字是包含e的人</span><br><span class="line">SELECT * FROM yd_study WHERE name LIKE &#x27;%e%&#x27;;</span><br><span class="line">#查询名字是J开头的人</span><br><span class="line">SELECT * FROM yd_study WHERE name like &#x27;j%&#x27;;</span><br><span class="line">#查询身份证号减去年龄等于360109的人</span><br><span class="line">SELECT * FROM yd_study WHERE idcard-age = 360109;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap框架基础</title>
    <url>/posts/c369155.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. Bootstrap
</code></pre>
<h2 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h2><pre><code>1. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。
    * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。
    * 好处：
        1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。
        2. 响应式布局。
            * 同一套页面可以兼容不同分辨率的设备。


2. 快速入门
    1. 下载Bootstrap
    2. 在项目中将这三个文件夹复制
    3. 创建html页面，引入必要的资源文件


    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;zh-CN&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;
        &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;
    
        &lt;!-- Bootstrap --&gt;
        &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre>
<p>​		<br>​		   ！ <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --><br>​		    <script src="js/jquery-3.2.1.min.js"></script><br>​		    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --><br>​		    <script src="js/bootstrap.min.js"></script><br>​		</head><br>​		<body><br>​		<h1>你好，世界！</h1><br>​		<br>​		</body><br>​		</html></p>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>* 同一套页面可以兼容不同分辨率的设备。
* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子
* 步骤：
    1. 定义容器。相当于之前的table、
        * 容器分类：
            1. container：两边留白
            2. container-fluid：每一种设备都是100%宽度
    2. 定义行。相当于之前的tr   样式：row
    3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目
        * 设备代号：
            1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12
            2. sm：小屏幕 平板 (≥768px)
            3. md：中等屏幕 桌面显示器 (≥992px)
            4. lg：大屏幕 大桌面显示器 (≥1200px)

    * 注意：
        1. 一行中如果格子数目超过12，则超出部分自动换行。
        2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。
        3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。
</code></pre>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><pre><code>1. 全局CSS样式：
    * 按钮：class=&quot;btn btn-default&quot;
    * 图片：
        *  class=&quot;img-responsive&quot;：图片在任意尺寸都占100%
        *  图片形状
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框
    * 表格
        * table
        * table-bordered
        * table-hover
    * 表单
        * 给表单项添加：class=&quot;form-control&quot; 
2. 组件：
    * 导航条
    * 分页条
3. 插件：
    * 轮播图
</code></pre>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;
    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;

    &lt;!-- Bootstrap --&gt;
    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre>
<p>​	<br>​	    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --><br>​	    <script src="js/jquery-3.2.1.min.js"></script><br>​	    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --><br>​	    <script src="js/bootstrap.min.js"></script><br>​	    <style><br>​	        .paddtop{<br>​	            padding-top: 10px;<br>​	        }<br>​	        .search-btn{<br>​	            float: left;<br>​	            border:1px solid #ffc900;<br>​	            width: 90px;<br>​	            height: 35px;<br>​	            background-color:#ffc900 ;<br>​	            text-align: center;<br>​	            line-height: 35px;<br>​	            margin-top: 15px;<br>​	        }<br>​	<br>​	        .search-input{<br>​	            float: left;<br>​	            border:2px solid #ffc900;<br>​	            width: 400px;<br>​	            height: 35px;<br>​	            padding-left: 5px;<br>​	            margin-top: 15px;<br>​	        }<br>​	        .jx{<br>​	            border-bottom: 2px solid #ffc900;<br>​	            padding: 5px;<br>​	        }<br>​	        .company{<br>​	            height: 40px;<br>​	            background-color: #ffc900;<br>​	            text-align: center;<br>​	            line-height:40px ;<br>​	            font-size: 8px;<br>​	        }<br>​	    </style><br>​	</head><br>​	<body><br>​	<br>       <!-- 1.页眉部分--><br>       <header class="container-fluid"><br>           <div class="row"><br>               <img src="img/top_banner.jpg" class="img-responsive"><br>           </div><br>           <div class="row paddtop"><br>               <div class="col-md-3"><br>                   <img src="img/logo.jpg" class="img-responsive"><br>               </div><br>               <div class="col-md-5"><br>                   <input class="search-input" placeholder="请输入线路名称"><br>                   <a class="search-btn" href="#">搜索</a><br>               </div><br>               <div class="col-md-4"><br>                   <img src="img/hotel_tel.png" class="img-responsive"><br>               </div></p>
<pre><code>       &lt;/div&gt;
       &lt;!--导航栏--&gt;
       &lt;div class=&quot;row&quot;&gt;
           &lt;nav class=&quot;navbar navbar-default&quot;&gt;
               &lt;div class=&quot;container-fluid&quot;&gt;
                   &lt;!-- Brand and toggle get grouped for better mobile display --&gt;
                   &lt;div class=&quot;navbar-header&quot;&gt;
                       &lt;!-- 定义汉堡按钮 --&gt;
                       &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;
                           &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                       &lt;/button&gt;
                       &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;
                   &lt;/div&gt;

                   &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;
                   &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;
                       &lt;ul class=&quot;nav navbar-nav&quot;&gt;
                           &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;
                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;

                       &lt;/ul&gt;
                   &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;
               &lt;/div&gt;&lt;!-- /.container-fluid --&gt;
           &lt;/nav&gt;

       &lt;/div&gt;

       &lt;!--轮播图--&gt;
       &lt;div class=&quot;row&quot;&gt;
           &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;
               &lt;!-- Indicators --&gt;
               &lt;ol class=&quot;carousel-indicators&quot;&gt;
                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;
                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;
                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;
               &lt;/ol&gt;

               &lt;!-- Wrapper for slides --&gt;
               &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;
                   &lt;div class=&quot;item active&quot;&gt;
                       &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt;
                   &lt;/div&gt;
                   &lt;div class=&quot;item&quot;&gt;
                       &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt;
                   &lt;/div&gt;
                   &lt;div class=&quot;item&quot;&gt;
                       &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt;
                   &lt;/div&gt;

               &lt;/div&gt;

               &lt;!-- Controls --&gt;
               &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;
                   &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
                   &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;
               &lt;/a&gt;
               &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;
                   &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
                   &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;
               &lt;/a&gt;
           &lt;/div&gt;
</code></pre>
<p>​	<br>​	<br>​	       </div><br>​	<br>​	   </header><br>​	   <!-- 2.主体部分--><br>​	   <div class="container"><br>​	        <div class="row jx"><br>​	            <img src="img/icon_5.jpg"><br>​	            <span>黑马精选</span><br>​	        </div><br>​	<br>           <div class="row paddtop"><br>               <div class="col-md-3"><br>                    <div class="thumbnail"><br>                        <img src="img/jiangxuan_3.jpg" alt=""><br>                        <p>上海直飞三亚5天4晚自由行(春节预售+亲子&#x2F;蜜月&#x2F;休闲游首选+豪华酒店任选+接送机)</p><br>                        <font color="red">&yen; 699</font><br>                    </div><br>               </div><br>               <div class="col-md-3"><br>                   <div class="thumbnail"><br>                       <img src="img/jiangxuan_3.jpg" alt=""><br>                       <p>上海直飞三亚5天4晚自由行(春节预售+亲子&#x2F;蜜月&#x2F;休闲游首选+豪华酒店任选+接送机)</p><br>                       <font color="red">&yen; 699</font><br>                   </div></p>
<pre><code>           &lt;/div&gt;
           &lt;div class=&quot;col-md-3&quot;&gt;

               &lt;div class=&quot;thumbnail&quot;&gt;
                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;
                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
               &lt;/div&gt;
           &lt;/div&gt;
           &lt;div class=&quot;col-md-3&quot;&gt;

               &lt;div class=&quot;thumbnail&quot;&gt;
                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;
                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
               &lt;/div&gt;
           &lt;/div&gt;
</code></pre>
<p>​	<br>​	       </div><br>​	       <div class="row jx"><br>​	           <img src="img/icon_6.jpg"><br>​	           <span>国内游</span><br>​	       </div><br>​	       <div class="row paddtop"><br>​	           <div class="col-md-4"><br>​	               <img src="img/guonei_1.jpg"><br>​	           </div><br>​	           <div class="col-md-8"><br>​	               <div class="row"><br>​	                   <div class="col-md-4"><br>​	                       <div class="thumbnail"><br>​	                           <img src="img/jiangxuan_3.jpg" alt=""><br>​	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子&#x2F;蜜月&#x2F;休闲游首选+豪华酒店任选+接送机)</p><br>​	                           <font color="red">&yen; 699</font><br>​	                       </div><br>​	                   </div><br>​	                   <div class="col-md-4"><br>​	                       <div class="thumbnail"><br>​	                           <img src="img/jiangxuan_3.jpg" alt=""><br>​	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子&#x2F;蜜月&#x2F;休闲游首选+豪华酒店任选+接送机)</p><br>​	                           <font color="red">&yen; 699</font><br>​	                       </div><br>​	<br>​	                   </div><br>​	                   <div class="col-md-4"><br>​	<br>                           <div class="thumbnail"><br>                               <img src="img/jiangxuan_3.jpg" alt=""><br>                               <p>上海直飞三亚5天4晚自由行(春节预售+亲子&#x2F;蜜月&#x2F;休闲游首选+豪华酒店任选+接送机)</p><br>                               <font color="red">&yen; 699</font><br>                           </div><br>                       </div></p>
<pre><code>               &lt;/div&gt;
               &lt;div class=&quot;row&quot;&gt;
                   &lt;div class=&quot;col-md-4&quot;&gt;
                       &lt;div class=&quot;thumbnail&quot;&gt;
                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;
                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                       &lt;/div&gt;
                   &lt;/div&gt;
                   &lt;div class=&quot;col-md-4&quot;&gt;
                       &lt;div class=&quot;thumbnail&quot;&gt;
                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;
                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                       &lt;/div&gt;

                   &lt;/div&gt;
                   &lt;div class=&quot;col-md-4&quot;&gt;

                       &lt;div class=&quot;thumbnail&quot;&gt;
                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;
                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                       &lt;/div&gt;
                   &lt;/div&gt;
</code></pre>
<p>​	<br>​	               </div><br>​	<br>​	           </div><br>​	<br>           </div><br>       </div><br>       <!-- 3.页脚部分--><br>       <footer class="container-fluid"><br>           <div class="row"><br>               <img src="img/footer_service.png" class="img-responsive"><br>           </div><br>           <div class="row company"><br>               江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882<br>           </div></p>
<pre><code>   &lt;/footer&gt;
</code></pre>
<p>​	<br>​	</body><br>​	</html></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>html和css</title>
    <url>/posts/4642a5d8.html</url>
    <content><![CDATA[<h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. HTML标签：表单标签

2. CSS：
</code></pre>
<h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：
    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。
    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围
        * 属性：
            * action：指定提交数据的URL
            * method:指定提交方式
                * 分类：一共7种，2种比较常用
                   * get：
                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。
                        2. 请求参数大小是有限制的。
                        3. 不太安全。
                   * post：
                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)
                        2. 请求参数的大小没有限制。
                        3. 较为安全。

        * 表单项中的数据要想被提交：必须指定其name属性
</code></pre>
<p>​		<br>​		* 表单项标签：<br>​			* input：可以通过type属性值，改变元素展示的样式<br>​				* type属性：<br>​					* text：文本输入框，默认值<br>​						* placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息	<br>​					* password：密码输入框<br>​					* radio:单选框<br>​						* 注意：<br>​							1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。<br>​							2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值<br>​							3. checked属性，可以指定默认值<br>​					* checkbox：复选框<br>​						* 注意：<br>​							1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值<br>​							2. checked属性，可以指定默认值<br>​	<br>                    * file：文件选择框<br>                    * hidden：隐藏域，用于提交一些信息。<br>                    * 按钮：<br>                        * submit：提交按钮。可以提交表单<br>                        * button：普通按钮<br>                        * image：图片提交按钮<br>                            * src属性指定图片的路径	</p>
<pre><code>           * label：指定输入项的文字描述信息
               * 注意：
                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。
        * select: 下拉列表
            * 子元素：option，指定列表项
            
        * textarea：文本域
            * cols：指定列数，每一行有多少个字符
            * rows：默认多少行。
</code></pre>
<h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表
    * 层叠：多个样式可以作用在同一个html的元素上，同时生效

2. 好处：
    1. 功能强大
    2. 将内容展示和样式控制分离
        * 降低耦合度。解耦
        * 让分工协作更容易
        * 提高开发效率


3. CSS的使用：CSS与html结合方式
    1. 内联样式
         * 在标签内使用style属性指定css代码
         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;
    2. 内部样式
        * 在head标签内，定义style标签，style标签的标签体内容就是css代码
        * 如：
            &lt;style&gt;
                div&#123;
                    color:blue;
                &#125;
        
            &lt;/style&gt;
            &lt;div&gt;hello css&lt;/div&gt;
    3. 外部样式
        1. 定义css资源文件。
        2. 在head标签内，定义link标签，引入外部的资源文件
        * 如：
    		* a.css文件：
                div&#123;
                    color:green;
                &#125;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;
            &lt;div&gt;hello css&lt;/div&gt;
            &lt;div&gt;hello css&lt;/div&gt;

    * 注意：
        * 1,2,3种方式 css作用范围越来越大
        * 1方式不常用，后期常用2,3
        * 3种格式可以写为：
            &lt;style&gt;
                @import &quot;css/a.css&quot;;
            &lt;/style&gt;

4. css语法：
    * 格式：
        选择器 &#123;
            属性名1:属性值1;
            属性名2:属性值2;
            ...
        &#125;
    * 选择器:筛选具有相似特征的元素
    * 注意：
        * 每一对属性需要使用；隔开，最后一对属性可以不加；


5. 选择器：筛选具有相似特征的元素
    * 分类：
        1. 基础选择器
            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一
                * 语法：#id属性值&#123;&#125;
            2. 元素选择器：选择具有相同标签名称的元素
                * 语法： 标签名称&#123;&#125;
                * 注意：id选择器优先级高于元素选择器
            3. 类选择器：选择具有相同的class属性值的元素。
                * 语法：.class属性值&#123;&#125;
                * 注意：类选择器选择器优先级高于元素选择器
        2. 扩展选择器：
            1. 选择所有元素：
                * 语法： *&#123;&#125;
            2. 并集选择器：
                * 选择器1,选择器2&#123;&#125;
            
            3. 子选择器：筛选选择器1元素下的选择器2元素
                * 语法：  选择器1 选择器2&#123;&#125;
            4. 父选择器：筛选选择器2的父元素选择器1
                * 语法：  选择器1 &gt; 选择器2&#123;&#125;

            5. 属性选择器：选择元素名称，属性名=属性值的元素
                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;

            6. 伪类选择器：选择一些元素具有的状态
                * 语法： 元素:状态&#123;&#125;
                * 如： &lt;a&gt;
                    * 状态：
                        * link：初始化的状态
                        * visited：被访问过的状态
                        * active：正在访问状态
                        * hover：鼠标悬浮状态
6. 属性
    1. 字体、文本
        * font-size：字体大小
        * color：文本颜色
        * text-align：对其方式
        * line-height：行高 
    2. 背景
        * background：
    3. 边框
        * border：设置边框，符合属性
    4. 尺寸
        * width：宽度
        * height：高度
    5. 盒子模型：控制布局
        * margin：外边距
        * padding：内边距
            * 默认情况下内边距会影响整个盒子的大小
            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小

        * float：浮动
            * left
            * right
</code></pre>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;注册页面&lt;/title&gt;
    &lt;style&gt;
        *&#123;
            margin: 0px;
            padding: 0px;
            box-sizing: border-box;
        &#125;
        body&#123;
            background: url(&quot;img/register_bg.png&quot;) no-repeat center;
            padding-top: 25px;
        &#125;
    
        .rg_layout&#123;
            width: 900px;
            height: 500px;
            border: 8px solid #EEEEEE;
            background-color: white;
            /*让div水平居中*/
            margin: auto;
        &#125;
    
        .rg_left&#123;
            /*border: 1px solid red;*/
            float: left;
            margin: 15px;
        &#125;
        .rg_left &gt; p:first-child&#123;
            color:#FFD026;
            font-size: 20px;
        &#125;
    
        .rg_left &gt; p:last-child&#123;
            color:#A6A6A6;
            font-size: 20px;
    
        &#125;
</code></pre>
<p>​		<br>​		    .rg_center{<br>​		        float: left;<br>​		       &#x2F;* border: 1px solid red;*&#x2F;<br>​		<br>            }</p>
<pre><code>        .rg_right&#123;
            /*border: 1px solid red;*/
            float: right;
            margin: 15px;
        &#125;
    
        .rg_right &gt; p:first-child&#123;
            font-size: 15px;
    
        &#125;
        .rg_right p a &#123;
            color:pink;
        &#125;
    
        .td_left&#123;
            width: 100px;
            text-align: right;
            height: 45px;
        &#125;
        .td_right&#123;
            padding-left: 50px ;
        &#125;
    
        #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;
            width: 251px;
            height: 32px;
            border: 1px solid #A6A6A6 ;
            /*设置边框圆角*/
            border-radius: 5px;
            padding-left: 10px;
        &#125;
        #checkcode&#123;
            width: 110px;
        &#125;
    
        #img_check&#123;
            height: 32px;
            vertical-align: middle;
        &#125;
    
        #btn_sub&#123;
            width: 150px;
            height: 40px;
            background-color: #FFD026;
            border: 1px solid #FFD026 ;
        &#125;
    
    &lt;/style&gt;
    
    &lt;/head&gt;
    &lt;body&gt;
    
    &lt;div class=&quot;rg_layout&quot;&gt;
        &lt;div class=&quot;rg_left&quot;&gt;
            &lt;p&gt;新用户注册&lt;/p&gt;
            &lt;p&gt;USER REGISTER&lt;/p&gt;
    
        &lt;/div&gt;
    
        &lt;div class=&quot;rg_center&quot;&gt;
            &lt;div class=&quot;rg_form&quot;&gt;
                &lt;!--定义表单 form--&gt;
                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;
                    &lt;table&gt;
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;
                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男
                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;
                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
</code></pre>
<p>​		<br>​		                    <tr><br>​		                        <td colspan="2" align="center"><input type="submit" id="btn_sub" value="注册"></td><br>​		                    </tr><br>​		                </table><br>​		<br>                    </form></p>
<p>​		<br>​		        </div><br>​		<br>            </div></p>
<pre><code>        &lt;div class=&quot;rg_right&quot;&gt;
            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;
        &lt;/div&gt;
</code></pre>
<p>​		<br>​		</div></p>
<p>​		<br>​		</body><br>​		</html></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>html基础</title>
    <url>/posts/1a147173.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web概念概述
2. HTML
</code></pre>
<h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：
    * 使用Java语言开发基于互联网的项目

* 软件架构：
    1. C/S: Client/Server 客户端/服务器端
        * 在用户本地有一个客户端程序，在远程有一个服务器端程序
        * 如：QQ，迅雷...
        * 优点：
            1. 用户体验好
        * 缺点：
            1. 开发、安装，部署，维护 麻烦
    2. B/S: Browser/Server 浏览器/服务器端
        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
        * 优点：
            1. 开发、安装，部署，维护 简单
        * 缺点：
            1. 如果应用过大，用户的体验可能会受到影响
            2. 对硬件要求过高

* B/S架构详解
    * 资源分类：
        1. 静态资源：
            * 使用静态网页开发技术发布的资源。
            * 特点：
                * 所有用户访问，得到的结果是一样的。
                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript
                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
        2. 动态资源：
            * 使用动态网页及时发布的资源。
            * 特点：
                * 所有用户访问，得到的结果可能不一样。
                * 如：jsp/servlet,php,asp...
                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器


    * 我们要学习动态资源，必须先学习静态资源！

    * 静态资源：
        * HTML：用于搭建基础网页，展示页面的内容
        * CSS：用于美化页面，布局页面
        * JavaScript：控制页面的元素，让页面有一些动态的效果
</code></pre>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言
    * Hyper Text Markup Language 超文本标记语言
        * 超文本:
            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.
        * 标记语言:
            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml
            * 标记语言不是编程语言

2. 快速入门：
    * 语法：
        1. html文档后缀名 .html 或者 .htm
        2. 标签分为
            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;
            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;

        3. 标签可以嵌套：
            需要正确嵌套，不能你中有我，我中有你
            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;
            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;

        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来
        5. html的标签不区分大小写，但是建议使用小写。

    * 代码：
        &lt;html&gt;
        
            &lt;head&gt;
                &lt;title&gt;title&lt;/title&gt;
            &lt;/head&gt;
            
            &lt;body&gt;
                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;
                
                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;
            
            &lt;/body&gt;
    
        &lt;/html&gt;

3. 标签学习：
    1. 文件标签：构成html最基本的标签
        * html:html文档的根标签
        * head：头标签。用于指定html文档的一些属性。引入外部的资源
        * title：标题标签。
        * body：体标签
        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档
    2. 文本标签：和文本有关的标签
        * 注释：&lt;!-- 注释内容 --&gt;
        * &lt;h1&gt; to &lt;h6&gt;：标题标签
            * h1~h6:字体大小逐渐递减
        * &lt;p&gt;：段落标签
        * &lt;br&gt;：换行标签
        * &lt;hr&gt;：展示一条水平线
            * 属性：
                * color：颜色
                * width：宽度
                * size：高度
                * align：对其方式
                    * center：居中
                    * left：左对齐
                    * right：右对齐
        * &lt;b&gt;：字体加粗
        * &lt;i&gt;：字体斜体
        * &lt;font&gt;:字体标签
        * &lt;center&gt;:文本居中
            * 属性：
                * color：颜色
                * size：大小
                * face：字体

        * 属性定义：
            * color：
                1. 英文单词：red,green,blue
                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)
                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF
            * width：
                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)
                2. 数值%：占比相对于父元素的比例

        * 案例：公司简介
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;ch&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;title&gt;黑马程序员简介&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
            
            &lt;h1&gt;
                公司简介
            &lt;/h1&gt;
            &lt;hr color=&quot;#ffd700&quot;&gt;
            
            &lt;p&gt;
            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。
            &lt;/p&gt;
            
            &lt;p&gt;
            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。
            &lt;/p&gt;
            
            &lt;p&gt;
            
            黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。
            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。
            &lt;/p&gt;
            
            &lt;p&gt;
            
            一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。
            &lt;/p&gt;
            
            &lt;hr color=&quot;#ffd700&quot;&gt;
            
            &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;
                &lt;center&gt;
                    江苏传智播客教育科技股份有限公司&lt;br&gt;
                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882
                &lt;/center&gt;
            &lt;/font&gt;
</code></pre>
<p>​				<br>​				<br>​				</body><br>​				</html><br>​	<br>​		3. 图片标签：<br>​			* img：展示图片<br>​				* 属性：<br>​					* src：指定图片的位置<br>​	<br>            * 代码：<br>                 <!--展示一张图片 img--></p>
<pre><code>            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;
        
            &lt;!--
                相对路径
                    * 以.开头的路径
                        * ./：代表当前目录  ./image/1.jpg
                        * ../:代表上一级目录
             --&gt;
        
            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;
        
            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;
    4. 列表标签：
        * 有序列表：
            * ol:
            * li:
        * 无序列表：
            * ul:
            * li:
    5. 链接标签：
        * a:定义一个超链接
            * 属性：
                * href：指定访问资源的URL(统一资源定位符)
                * target：指定打开资源的方式
                    * _self:默认值，在当前页面打开
                    * _blank：在空白页面打开

        * 代码：
             &lt;!--超链接  a--&gt;

            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
        
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;
        
            &lt;br&gt;
        
            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;
            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;
        
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;
    6. div和span：
        * div:每一个div占满一整行。块级标签
    	* span：文本信息在一行展示，行内标签 内联标签

    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。
        1. &lt;header&gt;：页眉
        2. &lt;footer&gt;：页脚


    8. 表格标签：
        * table：定义表格
            * width：宽度
            * border：边框
            * cellpadding：定义内容和单元格的距离
            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、
            * bgcolor：背景色
            * align：对齐方式
        * tr：定义行
            * bgcolor：背景色
            * align：对齐方式
        * td：定义单元格
            * colspan：合并列
            * rowspan：合并行
        * th：定义表头单元格
        * &lt;caption&gt;：表格标题
        * &lt;thead&gt;：表示表格的头部分
        * &lt;tbody&gt;：表示表格的体部分
        * &lt;tfoot&gt;：表示表格的脚部分
</code></pre>
<h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局	
2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
3. 如果某一行有多个单元格，则使用
    &lt;tr&gt;
        &lt;td&gt;
            &lt;table&gt;&lt;/table&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

4. 代码实现

    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;黑马旅游网&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    
        &lt;!--采用table来完成布局--&gt;
        &lt;!--最外层的table，用于整个页面的布局--&gt;
        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
           &lt;!-- 第1行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第2行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
    
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第3行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;
                            &lt;td&gt;
                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第4行 轮播图 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第5行 黑马精选--&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;
                    黑马精选
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第6行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第7行 国内游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;
                    国内游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第8行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre>
<p>​		<br>​		                    </tr><br>​		                </table><br>​		            </td><br>​		        </tr><br>​		<br>​		        <!-- 第9行 境外游 --><br>​		        <tr><br>​		            <td><br>​		                <img src="image/icon_7.jpg" alt=""><br>​		                境外游<br>​		                <hr  color="#ffd700" ><br>​		            </td><br>​		        </tr><br>​		<br>                <!-- 第10行 --><br>                <tr><br>                    <td><br>                        <table align="center" width="95%"><br>                            <tr><br>                                <td rowspan="2"><br>                                    <img src="image/jiangwai_1.jpg" alt=""><br>                                </td></p>
<pre><code>                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre>
<p>​		<br>​		                    </tr><br>​		                </table><br>​		            </td><br>​		        </tr><br>​		        <!-- 第11行 --><br>​		        <tr><br>​		            <td><br>​		                <img src="image/footer_service.png" alt="" width="100%"><br>​		            </td><br>​		        </tr><br>​		<br>​		        <!-- 第12行 --><br>​		        <tr><br>​		            <td align="center" bgcolor="#ffd700" height="40"><br>​		                <font color="gray" size="2"><br>​		                江苏传智播客教育科技股份有限公司<br>​		                版权所有Copyright 2006-2018&copy;, All Rights Reserved 苏ICP备16007882<br>​		                </font><br>​		            </td><br>​		        </tr><br>​		<br>            </table></p>
<p>​		<br>​		</body><br>​		</html></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/posts/a9ba4134.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JavaScript基础
</code></pre>
<h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><pre><code>* 概念：	一门客户端脚本语言
    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎
    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了

* 功能：
    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。

* JavaScript发展史：
    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--	，后来更名为：ScriptEase
    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript
    3. 1996年，微软抄袭JavaScript开发出JScript语言
    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。

    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)

* ECMAScript：客户端脚本语言的标准
    1. 基本语法：
        1. 与html结合方式
            1. 内部JS：
                * 定义&lt;script&gt;，标签体内容就是js代码
            2. 外部JS：
                * 定义&lt;script&gt;，通过src属性引入外部的js文件

            * 注意：
                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。
                2. &lt;script&gt;可以定义多个。
        2. 注释
            1. 单行注释：//注释内容
            2. 多行注释：/*注释内容*/
        3. 数据类型：
            1. 原始数据类型(基本数据类型)：
                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)
                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;
                3. boolean: true和false
                4. null：一个对象为空的占位符
                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined
                
            2. 引用数据类型：对象
            
        4. 变量
            * 变量：一小块存储数据的内存空间
            * Java语言是强类型语言，而JavaScript是弱类型语言。
                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据
                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。
            * 语法：
                * var 变量名 = 初始化值;
            
            * typeof运算符：获取变量的类型。
                * 注：null运算后得到的是object
        5. 运算符
            1. 一元运算符：只有一个运算数的运算符
                ++，-- ， +(正号)  
                * ++ --: 自增(自减)
                    * ++(--) 在前，先自增(自减)，再运算
                    * ++(--) 在后，先运算，再自增(自减)
                * +(-)：正负号
                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换
                    * 其他类型转number：
                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）
                        * boolean转number：true转为1，false转为0
            2. 算数运算符
                + - * / % ...

            3. 赋值运算符
                = += -+....

            4. 比较运算符
                &gt; &lt; &gt;= &lt;= == ===(全等于)
                * 比较方式
                  1. 类型相同：直接比较
                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。
                  2. 类型不同：先进行类型转换，再比较
                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false


            5. 逻辑运算符
                &amp;&amp; || !
                * 其他类型转boolean：
                   1. number：0或NaN为假，其他为真
                   2. string：除了空字符串(&quot;&quot;)，其他都是true
                   3. null&amp;undefined:都是false
                   4. 对象：所有对象都为true
            
            6. 三元运算符
                ? : 表达式
                var a = 3;
                var b = 4;
        
                var c = a &gt; b ? 1:0;
                * 语法：
                    * 表达式? 值1:值2;
                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；
            
        6. 流程控制语句：
            1. if...else...
            2. switch:
                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)
                    * switch(变量):
                        case 值:
                * 在JS中,switch语句可以接受任意的原始数据类型
            3. while
            4. do...while
            5. for
        7. JS特殊语法：
            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)
            2. 变量的定义使用var关键字，也可以不使用
        		* 用： 定义的变量是局部变量
                * 不用：定义的变量是全局变量(不建议)

        8. 练习：99乘法表
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;99乘法表&lt;/title&gt;
            &lt;style&gt;
                td&#123;
                    border: 1px solid;
                &#125;
        
            &lt;/style&gt;
        
            &lt;script&gt;
        
                document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);
</code></pre>
<p>​			<br>​			        &#x2F;&#x2F;1.完成基本的for循环嵌套，展示乘法表<br>​			        for (var i &#x3D; 1; i &lt;&#x3D; 9 ; i++) {<br>​			            document.write(“<tr>“);<br>​			            for (var j &#x3D; 1; j &lt;&#x3D;i ; j++) {<br>​			                document.write(“<td>“);<br>​			<br>                            &#x2F;&#x2F;输出  1 * 1 &#x3D; 1<br>                            document.write(i + “ * “ + j + “ &#x3D; “ + ( i*j) +”&nbsp;&nbsp;&nbsp;”);</p>
<pre><code>                        document.write(&quot;&lt;/td&gt;&quot;);
                    &#125;
                    /*//输出换行
                    document.write(&quot;&lt;br&gt;&quot;);*/
        
                    document.write(&quot;&lt;/tr&gt;&quot;);
                &#125;
        
                //2.完成表格嵌套
                document.write(&quot;&lt;/table&gt;&quot;);
        
            &lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        
        &lt;/body&gt;
        &lt;/html&gt;

    2. 基本对象：
        1. Function：函数(方法)对象
            1. 创建：
                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧
                2. 
                    function 方法名称(形式参数列表)&#123;
                        方法体
                    &#125;

                3. 
                   var 方法名 = function(形式参数列表)&#123;
                        方法体
                   &#125;
            2. 方法：

            3. 属性：
                length:代表形参的个数
            4. 特点：
                1. 方法定义是，形参的类型不用写,返回值类型也不写。
                2. 方法是一个对象，如果定义名称相同的方法，会覆盖
                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关
                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数
            5. 调用：
                方法名称(实际参数列表);
        
        2. Array:数组对象
            1. 创建：
                1. var arr = new Array(元素列表);
                2. var arr = new Array(默认长度);
                3. var arr = [元素列表];
            2. 方法
                join(参数):将数组中的元素按照指定的分隔符拼接为字符串
                push()	向数组的末尾添加一个或更多元素，并返回新的长度。
            3. 属性
                length:数组的长度
            4. 特点：
                1. JS中，数组元素的类型可变的。
                2. JS中，数组长度可变的。
        3. Boolean
        4. Date：日期对象
            1. 创建：
                var date = new Date();

            2. 方法：
                toLocaleString()：返回当前date对象对应的时间本地字符串格式
                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差
        5. Math：数学对象
            1. 创建：
                * 特点：Math对象不用创建，直接使用。  Math.方法名();

            2. 方法：
                random():返回 0 ~ 1 之间的随机数。 含0不含1
                ceil(x)：对数进行上舍入。
                floor(x)：对数进行下舍入。
                round(x)：把数四舍五入为最接近的整数。
            3. 属性：
                PI
        6. Number
        7. String
        8. RegExp：正则表达式对象
            1. 正则表达式：定义字符串的组成规则。
                1. 单个字符:[]
                    如： [a] [ab] [a-zA-Z0-9_]
                    * 特殊符号代表特殊含义的单个字符:
                        \d:单个数字字符 [0-9]
                        \w:单个单词字符[a-zA-Z0-9_]
                2. 量词符号：
                    ?：表示出现0次或1次
                    *：表示出现0次或多次
                    +：出现1次或多次
                    &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n
                        * m如果缺省： &#123;,n&#125;:最多n次
                        * n如果缺省：&#123;m,&#125; 最少m次
                3. 开始结束符号
                    * ^:开始
                    * $:结束
            2. 正则对象：
                1. 创建
                    1. var reg = new RegExp(&quot;正则表达式&quot;);
                    2. var reg = /正则表达式/;
                2. 方法	
                    1. test(参数):验证指定的字符串是否符合正则定义的规范	
        9. Global
            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();
            2. 方法：
                encodeURI():url编码
                decodeURI():url解码

                encodeURIComponent():url编码,编码的字符更多
                decodeURIComponent():url解码

                parseInt():将字符串转为数字
                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number
                isNaN():判断一个值是否是NaN
                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false

                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。
            3. URL编码
               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2

* BOM

* DOM
</code></pre>
<p>​	</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级基础</title>
    <url>/posts/831f8dce.html</url>
    <content><![CDATA[<h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. JavaScript：
    1. ECMAScript：
    2. BOM：
    3. DOM：
        1. 事件
</code></pre>
<h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容
* 获取页面标签(元素)对象：Element
    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象

* 操作Element对象：
    1. 修改属性值：
        1. 明确获取的对象是哪一个？
        2. 查看API文档，找其中有哪些属性可以设置
    2. 修改标签体内容：
        * 属性：innerHTML
        1. 获取元素对象
        2. 使用innerHTML属性修改标签体内容
</code></pre>
<h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2><pre><code>* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。
    * 造句：  xxx被xxx,我就xxx
        * 我方水晶被摧毁后，我就责备对友。
        * 敌方水晶被摧毁后，我就夸奖自己。

* 如何绑定事件
    1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码
        1. 事件：onclick--- 单击事件

    2. 通过js获取元素对象，指定事件属性，设置一个函数

    * 代码：
        &lt;body&gt;
            &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt;
            &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt;
            
            &lt;script&gt;
                function fun()&#123;
                    alert(&#39;我被点了&#39;);
                    alert(&#39;我又被点了&#39;);
                &#125;
            
                function fun2()&#123;
                    alert(&#39;咋老点我？&#39;);
                &#125;
            
                //1.获取light2对象
                var light2 = document.getElementById(&quot;light2&quot;);
                //2.绑定事件
                light2.onclick = fun2;
</code></pre>
<p>​				<br>                </script><br>            </body></p>
<pre><code>* 案例1：电灯开关
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;电灯开关&lt;/title&gt;
    
    &lt;/head&gt;
    &lt;body&gt;
    
    &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;
    
    &lt;script&gt;
        /*
            分析：
                1.获取图片对象
                2.绑定单击事件
                3.每次点击切换图片
                    * 规则：
                        * 如果灯是开的 on,切换图片为 off
                        * 如果灯是关的 off,切换图片为 on
                    * 使用标记flag来完成
    
         */
    
        //1.获取图片对象
        var light = document.getElementById(&quot;light&quot;);
    
        var flag = false;//代表灯是灭的。 off图片
    
        //2.绑定单击事件
        light.onclick = function()&#123;
            if(flag)&#123;//判断如果灯是开的，则灭掉
                light.src = &quot;img/off.gif&quot;;
                flag = false;
    
            &#125;else&#123;
                //如果灯是灭的，则打开
    
                light.src = &quot;img/on.gif&quot;;
                flag = true;
            &#125;
</code></pre>
<p>​		<br>            }</p>
<pre><code>    &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><pre><code>1. 概念：Browser Object Model 浏览器对象模型
    * 将浏览器的各个组成部分封装成对象。

2. 组成：
    * Window：窗口对象
    * Navigator：浏览器对象
    * Screen：显示器屏幕对象
    * History：历史记录对象
    * Location：地址栏对象

3. Window：窗口对象
    1. 创建
    2. 方法
         1. 与弹出框有关的方法：
            alert()	显示带有一段消息和一个确认按钮的警告框。
            confirm()	显示带有一段消息以及确认按钮和取消按钮的对话框。
                * 如果用户点击确定按钮，则方法返回true
                * 如果用户点击取消按钮，则方法返回false
            prompt()	显示可提示用户输入的对话框。
                * 返回值：获取用户输入的值
         2. 与打开关闭有关的方法：
            close()	关闭浏览器窗口。
                * 谁调用我 ，我关谁
            open()	打开一个新的浏览器窗口
                * 返回新的Window对象
         3. 与定时器有关的方式
            setTimeout()	在指定的毫秒数后调用函数或计算表达式。
                * 参数：
                    1. js代码或者方法对象
                    2. 毫秒值
                * 返回值：唯一标识，用于取消定时器
            clearTimeout()	取消由 setTimeout() 方法设置的 timeout。

            setInterval()	按照指定的周期（以毫秒计）来调用函数或计算表达式。
            clearInterval()	取消由 setInterval() 设置的 timeout。

    3. 属性：
        1. 获取其他BOM对象：
            history
            location
            Navigator
            Screen:
        2. 获取DOM对象
            document
    4. 特点
        * Window对象不需要创建可以直接使用 window使用。 window.方法名();
        * window引用可以省略。  方法名();


4. Location：地址栏对象
    1. 创建(获取)：
        1. window.location
        2. location

    2. 方法：
        * reload()	重新加载当前文档。刷新
    3. 属性
        * href	设置或返回完整的 URL。


5. History：历史记录对象
    1. 创建(获取)：
        1. window.history
        2. history

    2. 方法：
        * back()	加载 history 列表中的前一个 URL。
        * forward()	加载 history 列表中的下一个 URL。
        * go(参数)	加载 history 列表中的某个具体页面。
            * 参数：
                * 正数：前进几个历史记录
                * 负数：后退几个历史记录
    3. 属性：
        * length	返回当前窗口历史列表中的 URL 数量。
</code></pre>
<h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><pre><code>* 概念： Document Object Model 文档对象模型
    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作

* W3C DOM 标准被分为 3 个不同的部分：

    * 核心 DOM - 针对任何结构化文档的标准模型
        * Document：文档对象
        * Element：元素对象
        * Attribute：属性对象
        * Text：文本对象
        * Comment:注释对象

        * Node：节点对象，其他5个的父对象
    * XML DOM - 针对 XML 文档的标准模型
    * HTML DOM - 针对 HTML 文档的标准模型





* 核心DOM模型：
    * Document：文档对象
        1. 创建(获取)：在html dom模型中可以使用window对象来获取
            1. window.document
            2. document
        2. 方法：
            1. 获取Element对象：
                1. getElementById()	： 根据id属性值获取元素对象。id属性值一般唯一
                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组
                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组
                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组
            2. 创建其他DOM对象：
                createAttribute(name)
            	createComment()
            	createElement()
            	createTextNode()
        3. 属性
    * Element：元素对象
        1. 获取/创建：通过document来获取和创建
        2. 方法：
            1. removeAttribute()：删除属性
            2. setAttribute()：设置属性
    * Node：节点对象，其他5个的父对象
        * 特点：所有dom对象都可以被认为是一个节点
        * 方法：
            * CRUD dom树：
                * appendChild()：向节点的子节点列表的结尾添加新的子节点。
                * removeChild()	：删除（并返回）当前节点的指定子节点。
                * replaceChild()：用新节点替换一个子节点。
        * 属性：
            * parentNode 返回节点的父节点。


* HTML DOM
    1. 标签体的设置和获取：innerHTML
    2. 使用html元素对象的属性
    3. 控制元素样式
        1. 使用元素的style属性来设置
            如：
                 //修改样式方式1
                div1.style.border = &quot;1px solid red&quot;;
                div1.style.width = &quot;200px&quot;;
                //font-size--&gt; fontSize
                div1.style.fontSize = &quot;20px&quot;;
        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。
</code></pre>
<h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。	
    * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了
    * 事件源：组件。如： 按钮 文本输入框...
    * 监听器：代码。
    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。


* 常见的事件：
    1. 点击事件：
        1. onclick：单击事件
        2. ondblclick：双击事件
    2. 焦点事件
        1. onblur：失去焦点
        2. onfocus:元素获得焦点。

    3. 加载事件：
        1. onload：一张页面或一幅图像完成加载。

    4. 鼠标事件：
        1. onmousedown	鼠标按钮被按下。
        2. onmouseup	鼠标按键被松开。
        3. onmousemove	鼠标被移动。
        4. onmouseover	鼠标移到某元素之上。
        5. onmouseout	鼠标从某元素移开。
</code></pre>
<p>​			<br>        5. 键盘事件：<br>            1. onkeydown	某个键盘按键被按下。	<br>            2. onkeyup		某个键盘按键被松开。<br>            3. onkeypress	某个键盘按键被按下并松开。</p>
<pre><code>    6. 选择和改变
        1. onchange	域的内容被改变。
        2. onselect	文本被选中。

    7. 表单事件：
        1. onsubmit	确认按钮被点击。
        2. onreset	重置按钮被点击。
</code></pre>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>xml基础</title>
    <url>/posts/3b93ba3b.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. XML
    1. 概念
    2. 语法
    3. 解析
</code></pre>
<h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言
    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;

    * 功能
        * 存储数据
            1. 配置文件
            2. 在网络中传输
    * xml与html的区别
        1. xml标签都是自定义的，html标签是预定义。
        2. xml的语法严格，html语法松散
        3. xml是存储数据的，html是展示数据

    * w3c:万维网联盟

2. 语法：
    * 基本语法：
        1. xml文档的后缀名 .xml
        2. xml第一行必须定义为文档声明
        3. xml文档中有且仅有一个根标签
        4. 属性值必须使用引号(单双都可)引起来
        5. 标签必须正确关闭
        6. xml标签名称区分大小写
    * 快速入门：
        &lt;?xml version=&#39;1.0&#39; ?&gt;
        &lt;users&gt;
            &lt;user id=&#39;1&#39;&gt;
                &lt;name&gt;zhangsan&lt;/name&gt;
                &lt;age&gt;23&lt;/age&gt;
                &lt;gender&gt;male&lt;/gender&gt;
                &lt;br/&gt;
            &lt;/user&gt;
            
            &lt;user id=&#39;2&#39;&gt;
                &lt;name&gt;lisi&lt;/name&gt;
                &lt;age&gt;24&lt;/age&gt;
                &lt;gender&gt;female&lt;/gender&gt;
            &lt;/user&gt;
        &lt;/users&gt;
        
    * 组成部分：
        1. 文档声明
            1. 格式：&lt;?xml 属性列表 ?&gt;
            2. 属性列表：
                * version：版本号，必须的属性
                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
                * standalone：是否独立
                    * 取值：
                        * yes：不依赖其他文件
                        * no：依赖其他文件
        2. 指令(了解)：结合css的
            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;
        3. 标签：标签名称自定义的
            * 规则：
                * 名称可以包含字母、数字以及其他的字符 
                * 名称不能以数字或者标点符号开始 
                * 名称不能以字母 xml（或者 XML、Xml 等等）开始 
                * 名称不能包含空格 

        4. 属性：
            id属性值唯一
        5. 文本：
            * CDATA区：在该区域中的数据会被原样展示
                * 格式：  &lt;![CDATA[ 数据 ]]&gt;
</code></pre>
<p>​	<br>        * 约束：规定xml文档的书写规则<br>            * 作为框架的使用者(程序员)：<br>                1. 能够在xml中引入约束文档<br>                2. 能够简单的读懂约束文档</p>
<pre><code>        * 分类：
            1. DTD:一种简单的约束技术
            2. Schema:一种复杂的约束技术


        * DTD：
            * 引入dtd文档到xml文档中
                * 内部dtd：将约束规则定义在xml文档中
                * 外部dtd：将约束的规则定义在外部的dtd文件中
                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;
                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;


        * Schema:
            * 引入：
                1.填写xml文档的根元素
                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;
                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; 

            &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xmlns=&quot;http://www.itcast.cn/xml&quot;
                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;
</code></pre>
<p>​	</p>
<pre><code>3. 解析：操作xml文档，将文档中的数据读取到内存中
    * 操作xml文档
        1. 解析(读取)：将文档中的数据读取到内存中
        2. 写入：将内存中的数据保存到xml文档中。持久化的存储

    * 解析xml的方式：
        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
            * 优点：操作方便，可以对文档进行CRUD的所有操作
            * 缺点：占内存
        2. SAX：逐行读取，基于事件驱动的。
            * 优点：不占内存。
            * 缺点：只能读取，不能增删改
</code></pre>
<p>​		<br>        * xml常见的解析器：<br>            1. JAXP：sun公司提供的解析器，支持dom和sax两种思想<br>            2. DOM4J：一款非常优秀的解析器<br>            3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<br>            4. PULL：Android操作系统内置的解析器，sax方式的。</p>
<pre><code>    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        * 快速入门：
            * 步骤：
                1. 导入jar包
                2. 获取Document对象
                3. 获取对应的标签Element对象
                4. 获取数据

        * 代码：
             //2.1获取student.xml的path
            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document
            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);
            //3.获取元素对象 Element
            Elements elements = document.getElementsByTag(&quot;name&quot;);
    
            System.out.println(elements.size());
            //3.1获取第一个name的Element对象
            Element element = elements.get(0);
            //3.2获取数据
            String name = element.text();
            System.out.println(name);

    * 对象的使用：
        1. Jsoup：工具类，可以解析html或xml文档，返回Document
            * parse：解析html或xml文档，返回Document
                * parse​(File in, String charsetName)：解析xml或html文件的。
                * parse​(String html)：解析xml或html字符串
                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
        2. Document：文档对象。代表内存中的dom树
            * 获取Element对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用
        4. Element：元素对象
            1. 获取子元素对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

            2. 获取属性值
                * String attr(String key)：根据属性名称获取属性值
            3. 获取文本内容
                * String text():获取文本内容
                * String html():获取标签体的所有内容(包括字标签的字符串内容)
        5. Node：节点对象
            * 是Document和Element的父类
</code></pre>
<p>​			<br>        * 快捷查询方式：<br>            1. selector:选择器<br>                * 使用的方法：Elements	select​(String cssQuery)<br>                    * 语法：参考Selector类中定义的语法<br>            2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<br>                * 使用Jsoup的Xpath需要额外导入jar包。<br>                * 查询w3cshool参考手册，使用xpath的语法完成查询<br>                * 代码：<br>                    &#x2F;&#x2F;1.获取student.xml的path<br>                    String path &#x3D; JsoupDemo6.class.getClassLoader().getResource(“student.xml”).getPath();<br>                    &#x2F;&#x2F;2.获取Document对象<br>                    Document document &#x3D; Jsoup.parse(new File(path), “utf-8”);</p>
<pre><code>                //3.根据document对象，创建JXDocument对象
                JXDocument jxDocument = new JXDocument(document);
        
                //4.结合xpath语法查询
                //4.1查询所有student标签
                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);
                for (JXNode jxNode : jxNodes) &#123;
                    System.out.println(jxNode);
                &#125;
        
                System.out.println(&quot;--------------------&quot;);
        
                //4.2查询所有student标签下的name标签
                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);
                for (JXNode jxNode : jxNodes2) &#123;
                    System.out.println(jxNode);
                &#125;
        
                System.out.println(&quot;--------------------&quot;);
        
                //4.3查询student标签下带有id属性的name标签
                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);
                for (JXNode jxNode : jxNodes3) &#123;
                    System.out.println(jxNode);
                &#125;
                System.out.println(&quot;--------------------&quot;);
                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast
        
                List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#39;itcast&#39;]&quot;);
                for (JXNode jxNode : jxNodes4) &#123;
                    System.out.println(jxNode);
                &#125;
</code></pre>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>html基础</title>
    <url>/posts/1a147163.html</url>
    <content><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web概念概述
2. HTML
</code></pre>
<h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：
    * 使用Java语言开发基于互联网的项目

* 软件架构：
    1. C/S: Client/Server 客户端/服务器端
        * 在用户本地有一个客户端程序，在远程有一个服务器端程序
        * 如：QQ，迅雷...
        * 优点：
            1. 用户体验好
        * 缺点：
            1. 开发、安装，部署，维护 麻烦
    2. B/S: Browser/Server 浏览器/服务器端
        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
        * 优点：
            1. 开发、安装，部署，维护 简单
        * 缺点：
            1. 如果应用过大，用户的体验可能会受到影响
            2. 对硬件要求过高

* B/S架构详解
    * 资源分类：
        1. 静态资源：
            * 使用静态网页开发技术发布的资源。
            * 特点：
                * 所有用户访问，得到的结果是一样的。
                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript
                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
        2. 动态资源：
            * 使用动态网页及时发布的资源。
            * 特点：
                * 所有用户访问，得到的结果可能不一样。
                * 如：jsp/servlet,php,asp...
                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器


    * 我们要学习动态资源，必须先学习静态资源！

    * 静态资源：
        * HTML：用于搭建基础网页，展示页面的内容
        * CSS：用于美化页面，布局页面
        * JavaScript：控制页面的元素，让页面有一些动态的效果
</code></pre>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言
    * Hyper Text Markup Language 超文本标记语言
        * 超文本:
            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.
        * 标记语言:
            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml
            * 标记语言不是编程语言

2. 快速入门：
    * 语法：
        1. html文档后缀名 .html 或者 .htm
        2. 标签分为
            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;
            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;

        3. 标签可以嵌套：
            需要正确嵌套，不能你中有我，我中有你
            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;
            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;

        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来
        5. html的标签不区分大小写，但是建议使用小写。

    * 代码：
        &lt;html&gt;
        
            &lt;head&gt;
                &lt;title&gt;title&lt;/title&gt;
            &lt;/head&gt;
            
            &lt;body&gt;
                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;
                
                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;
            
            &lt;/body&gt;
    
        &lt;/html&gt;

3. 标签学习：
    1. 文件标签：构成html最基本的标签
        * html:html文档的根标签
        * head：头标签。用于指定html文档的一些属性。引入外部的资源
        * title：标题标签。
        * body：体标签
        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档
    2. 文本标签：和文本有关的标签
        * 注释：&lt;!-- 注释内容 --&gt;
        * &lt;h1&gt; to &lt;h6&gt;：标题标签
            * h1~h6:字体大小逐渐递减
        * &lt;p&gt;：段落标签
        * &lt;br&gt;：换行标签
        * &lt;hr&gt;：展示一条水平线
            * 属性：
                * color：颜色
                * width：宽度
                * size：高度
                * align：对其方式
                    * center：居中
                    * left：左对齐
                    * right：右对齐
        * &lt;b&gt;：字体加粗
        * &lt;i&gt;：字体斜体
        * &lt;font&gt;:字体标签
        * &lt;center&gt;:文本居中
            * 属性：
                * color：颜色
                * size：大小
                * face：字体

        * 属性定义：
            * color：
                1. 英文单词：red,green,blue
                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)
                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF
            * width：
                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)
                2. 数值%：占比相对于父元素的比例

        * 案例：公司简介
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;ch&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;title&gt;黑马程序员简介&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
            
            &lt;h1&gt;
                公司简介
            &lt;/h1&gt;
            &lt;hr color=&quot;#ffd700&quot;&gt;
            
            &lt;p&gt;
            &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。
            &lt;/p&gt;
            
            &lt;p&gt;
            目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。
            &lt;/p&gt;
            
            &lt;p&gt;
            
            黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。
            中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。
            &lt;/p&gt;
            
            &lt;p&gt;
            
            一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。
            &lt;/p&gt;
            
            &lt;hr color=&quot;#ffd700&quot;&gt;
            
            &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;
                &lt;center&gt;
                    江苏传智播客教育科技股份有限公司&lt;br&gt;
                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882
                &lt;/center&gt;
            &lt;/font&gt;
</code></pre>
<p>​				<br>​				<br>​				</body><br>​				</html><br>​	<br>​		3. 图片标签：<br>​			* img：展示图片<br>​				* 属性：<br>​					* src：指定图片的位置<br>​	<br>​			* 代码：<br>​				 <!--展示一张图片 img--><br>​	<br>                <img src="image/jingxuan_2.jpg" align="right" alt="古镇" width="500" height="500"/></p>
<pre><code>            &lt;!--
                相对路径
                    * 以.开头的路径
                        * ./：代表当前目录  ./image/1.jpg
                        * ../:代表上一级目录
             --&gt;
        
            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;
        
            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;
    4. 列表标签：
        * 有序列表：
            * ol:
            * li:
        * 无序列表：
            * ul:
            * li:
    5. 链接标签：
        * a:定义一个超链接
            * 属性：
                * href：指定访问资源的URL(统一资源定位符)
                * target：指定打开资源的方式
                    * _self:默认值，在当前页面打开
                    * _blank：在空白页面打开

        * 代码：
             &lt;!--超链接  a--&gt;

            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
        
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;
        
            &lt;br&gt;
        
            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;
            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;
        
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;
    6. div和span：
        * div:每一个div占满一整行。块级标签
    	* span：文本信息在一行展示，行内标签 内联标签

    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。
        1. &lt;header&gt;：页眉
        2. &lt;footer&gt;：页脚


    8. 表格标签：
        * table：定义表格
            * width：宽度
            * border：边框
            * cellpadding：定义内容和单元格的距离
            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、
            * bgcolor：背景色
            * align：对齐方式
        * tr：定义行
            * bgcolor：背景色
            * align：对齐方式
        * td：定义单元格
            * colspan：合并列
            * rowspan：合并行
        * th：定义表头单元格
        * &lt;caption&gt;：表格标题
        * &lt;thead&gt;：表示表格的头部分
        * &lt;tbody&gt;：表示表格的体部分
        * &lt;tfoot&gt;：表示表格的脚部分
</code></pre>
<h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局	
2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
3. 如果某一行有多个单元格，则使用
    &lt;tr&gt;
        &lt;td&gt;
            &lt;table&gt;&lt;/table&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

4. 代码实现

    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;黑马旅游网&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    
        &lt;!--采用table来完成布局--&gt;
        &lt;!--最外层的table，用于整个页面的布局--&gt;
        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
           &lt;!-- 第1行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第2行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
    
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第3行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;
                            &lt;td&gt;
                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第4行 轮播图 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第5行 黑马精选--&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;
                    黑马精选
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第6行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第7行 国内游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;
                    国内游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第8行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre>
<p>​		<br>​		                    </tr><br>​		                </table><br>​		            </td><br>​		        </tr><br>​		<br>​		        <!-- 第9行 境外游 --><br>​		        <tr><br>​		            <td><br>​		                <img src="image/icon_7.jpg" alt=""><br>​		                境外游<br>​		                <hr  color="#ffd700" ><br>​		            </td><br>​		        </tr><br>​		<br>​		        <!-- 第10行 --><br>​		        <tr><br>​		            <td><br>​		                <table align="center" width="95%"><br>​		                    <tr><br>​		                        <td rowspan="2"><br>​		                            <img src="image/jiangwai_1.jpg" alt=""><br>​		                        </td><br>​		<br>                                <td></p>
<pre><code>                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre>
<p>​		<br>​		                    </tr><br>​		                </table><br>​		            </td><br>​		        </tr><br>​		        <!-- 第11行 --><br>​		        <tr><br>​		            <td><br>​		                <img src="image/footer_service.png" alt="" width="100%"><br>​		            </td><br>​		        </tr><br>​		<br>​		        <!-- 第12行 --><br>​		        <tr><br>​		            <td align="center" bgcolor="#ffd700" height="40"><br>​		                <font color="gray" size="2"><br>​		                江苏传智播客教育科技股份有限公司<br>​		                版权所有Copyright 2006-2018&copy;, All Rights Reserved 苏ICP备16007882<br>​		                </font><br>​		            </td><br>​		        </tr><br>​		<br>​		    </table></p>
<p>​		<br>​		</body><br>​		</html></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/posts/82d7ef45.html</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>一级标题使用 #加空格</p>
<p>二级标题使用两个#加空格</p>
<p>三级标题使用三个#加空格</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>Hello,world!</strong>  粗体在文本前加两个#</p>
<p><em>Hello,world!</em>   	斜体体在文本前加一个#</p>
<p><em><strong>Hello,world!</strong></em>	粗斜体在文本前加三个#</p>
<p><del>Hello,world!</del>	删除线在文本前加两个~~</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个~</p>
<p>三个*</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>“<img src="/" alt="截图">”</p>
<p>插入图片使用！&#x2F;&#x2F;感叹号[]&#x2F;&#x2F;文件名(&#x2F;&#x2F;图片路径)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类、常用API</title>
    <url>/posts/48c8b89.html</url>
    <content><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Object类</li>
<li>Date类</li>
<li>DateFormat类</li>
<li>Calendar类</li>
<li>System类</li>
<li>StringBuilder类</li>
<li>包装类</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p>
<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，	那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="comment">/*extends Object*/</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p>
<p><img src="/img%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" alt="toString方法的自动重写"></p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%951.png"></p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%952.png"></p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%953.png"></p>
<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取出生日期,键盘输入</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">birthdayString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">	<span class="comment">// 将字符串日期,转成Date对象</span></span><br><span class="line">	<span class="comment">// 创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">	<span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 调用方法parse,字符串转成日期对象</span></span><br><span class="line">	<span class="type">Date</span> <span class="variable">birthdayDate</span> <span class="operator">=</span> sdf.parse(birthdayString);	</span><br><span class="line">	<span class="comment">// 获取今天的日期对象</span></span><br><span class="line">	<span class="type">Date</span> <span class="variable">todayDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();	</span><br><span class="line">	<span class="comment">// 将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">birthdaySecond</span> <span class="operator">=</span> birthdayDate.getTime();</span><br><span class="line">	<span class="type">long</span> <span class="variable">todaySecond</span> <span class="operator">=</span> todayDate.getTime();</span><br><span class="line">	<span class="type">long</span> <span class="variable">secone</span> <span class="operator">=</span> todaySecond-birthdaySecond;	</span><br><span class="line">	<span class="keyword">if</span> (secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p>
<p><img src="/img%5C%E6%97%A5%E5%8E%86.jpg"></p>
<p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06CalendarInit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get&#x2F;set方法"></a>get&#x2F;set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11SystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] src = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p><img src="/img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp"></p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="/img%5C06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="06-StringBuilder的原理"></p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StringBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder2</span> <span class="operator">=</span> builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="literal">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo18WrapperParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类、常用API2</title>
    <url>/posts/8eb50902.html</url>
    <content><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Object类</li>
<li>Date类</li>
<li>DateFormat类</li>
<li>Calendar类</li>
<li>System类</li>
<li>StringBuilder类</li>
<li>包装类</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p>
<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，	那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="comment">/*extends Object*/</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151846999.bmp" alt="toString方法的自动重写"></p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151848634.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151848116.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151848383.png"></p>
<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取出生日期,键盘输入</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">birthdayString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">	<span class="comment">// 将字符串日期,转成Date对象</span></span><br><span class="line">	<span class="comment">// 创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">	<span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 调用方法parse,字符串转成日期对象</span></span><br><span class="line">	<span class="type">Date</span> <span class="variable">birthdayDate</span> <span class="operator">=</span> sdf.parse(birthdayString);	</span><br><span class="line">	<span class="comment">// 获取今天的日期对象</span></span><br><span class="line">	<span class="type">Date</span> <span class="variable">todayDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();	</span><br><span class="line">	<span class="comment">// 将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">birthdaySecond</span> <span class="operator">=</span> birthdayDate.getTime();</span><br><span class="line">	<span class="type">long</span> <span class="variable">todaySecond</span> <span class="operator">=</span> todayDate.getTime();</span><br><span class="line">	<span class="type">long</span> <span class="variable">secone</span> <span class="operator">=</span> todaySecond-birthdaySecond;	</span><br><span class="line">	<span class="keyword">if</span> (secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151854008.jpg"></p>
<p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06CalendarInit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get&#x2F;set方法"></a>get&#x2F;set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11SystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] src = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p><img src="/img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp"></p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="https://cdn.jsdelivr.net/gh/JavaSpans/imgdemo@main/img/202109151840347.png" alt="06-StringBuilder的原理"></p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StringBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder2</span> <span class="operator">=</span> builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="literal">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo18WrapperParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection、泛型</title>
    <url>/posts/a69633d1.html</url>
    <content><![CDATA[<h1 id="day02【Collection、泛型】"><a href="#day02【Collection、泛型】" class="headerlink" title="day02【Collection、泛型】"></a>day02【Collection、泛型】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li>
<li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li>
<li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li>
<li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li>
<li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li>
<li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li>
<li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li>
<li><input disabled="" type="checkbox"> 能够理解泛型上下限</li>
<li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li>
</ul>
<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="/img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="/img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBForDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;String&gt;&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;Integer&gt; &#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;MVP&gt; &#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMVP</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> MVP <span class="title function_">getMVP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClassDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">mvp</span> <span class="operator">=</span> my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         <span class="type">Integer</span> <span class="variable">mvp2</span> <span class="operator">=</span> my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span> &#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; MVP <span class="title function_">show2</span><span class="params">(MVP mvp)</span> &#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MyGenericMethod</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyGenericMethod</span>();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">getE</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp1</span> <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;String&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String e)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> <span class="title class_">MyImp2</span>&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list &#x3D; new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">&quot;♥&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♣&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">&quot;小☺&quot;</span>);</span><br><span class="line">        pokerBox.add(<span class="string">&quot;大☠&quot;</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;田伯光：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;绿竹翁：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List、Set、数据结构、Collections</title>
    <url>/posts/206428c3.html</url>
    <content><![CDATA[<h1 id="day03-【List、Set、数据结构、Collections】"><a href="#day03-【List、Set、数据结构、Collections】" class="headerlink" title="day03 【List、Set、数据结构、Collections】"></a>day03 【List、Set、数据结构、Collections】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>数据结构</li>
<li>List集合</li>
<li>Set集合</li>
<li>Collections</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出List集合特点</li>
<li><input disabled="" type="checkbox"> 能够说出常见的数据结构</li>
<li><input disabled="" type="checkbox"> 能够说出数组结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出栈结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出队列结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出单向链表结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出Set集合的特点</li>
<li><input disabled="" type="checkbox"> 能够说出哈希表的特点</li>
<li><input disabled="" type="checkbox"> 使用HashSet集合存储自定义元素</li>
<li><input disabled="" type="checkbox"> 能够说出可变参数的格式</li>
<li><input disabled="" type="checkbox"> 能够使用集合工具类</li>
<li><input disabled="" type="checkbox"> 能够使用Comparator比较器进行排序</li>
</ul>
<h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<p><img src="/img%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%AF%94%E5%96%BB.png"></p>
<h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
<p><img src="/img%5C%E5%A0%86%E6%A0%88.png"></p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<p><img src="/img%5C%E9%98%9F%E5%88%97%E5%9B%BE.bmp"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
<p><img src="/img/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p>
</li>
<li><p>增删元素慢</p>
</li>
<li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="/img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></p>
</li>
<li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/img/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></p>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<p><img src="/img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p>
</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p><img src="/img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li>增加元素：只需要修改连接下个元素的地址即可。</li>
</ul>
<p>  <img src="/img%5C%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"></p>
<ul>
<li>删除元素：只需要修改连接下个元素的地址即可。</li>
</ul>
<p>  <img src="/img%5C%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"></p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<p><img src="/img%5C%E4%BA%8C%E5%8F%89%E6%A0%91.bmp"></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li><p>节点可以是红色的或者黑色的</p>
</li>
<li><p>根节点是黑色的</p>
</li>
<li><p>叶子节点(特指空节点)是黑色的</p>
</li>
<li><p>每个红色节点的子节点都是黑色的</p>
</li>
<li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p>
</li>
</ol>
<p>红黑树的特点:</p>
<p>​	速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
<h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p>
<p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p><img src="/img%5C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="/img%5C%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p>
<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<p><img src="/img%5C%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>

<h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeArgs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Map</title>
    <url>/posts/abe0ec5b.html</url>
    <content><![CDATA[<h1 id="day04-【Map】"><a href="#day04-【Map】" class="headerlink" title="day04 【Map】"></a>day04 【Map】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Map集合</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出Map集合特点</li>
<li><input disabled="" type="checkbox"> 使用Map集合添加方法保存数据</li>
<li><input disabled="" type="checkbox"> 使用”键找值”的方式遍历Map集合</li>
<li><input disabled="" type="checkbox"> 使用”键值对”的方式遍历Map集合</li>
<li><input disabled="" type="checkbox"> 能够使用HashMap存储自定义键值对的数据</li>
<li><input disabled="" type="checkbox"> 能够使用HashMap编写斗地主洗牌发牌案例</li>
</ul>
<h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<p><img src="/img%5CCollection%E4%B8%8EMap.bmp"></p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>
<ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Map接口的方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          	<span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p>
<h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           	<span class="comment">// 解析 </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p>
<blockquote>
<p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p>
<blockquote>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
</blockquote>
<p>编写学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student,String&gt;();</span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;  &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure>

<h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，键代表字符，值代表次数。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个字符串:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findChar</span><span class="params">(String line)</span> &#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJDK9</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);  </span><br><span class="line">        <span class="comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>需要注意以下两点：</p>
<blockquote>
<p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p>
<p>2:返回的集合是不可变的；</p>
</blockquote>
<h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p>
<ol>
<li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 	</p>
<p>   <img src="/img/debug1.png"></p>
</li>
<li><p>点击Debug运行模式       <img src="/img%5Cdebug2.png">                                                                                                                                                                      </p>
</li>
<li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p>
<p> <img src="/img%5Cdebug3.png"><img src="/img%5Cdebug4.png"></p>
</li>
<li><p>Debug调试窗口介绍</p>
<p> <img src="/img%5Cdebug5.png"></p>
</li>
<li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p>
<p><img src="/img%5Cdebug6.png"></p>
</li>
<li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p>
<p><img src="/img%5Cdebug7.png"></p>
</li>
<li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p>
<p><img src="/img%5Cdebug8.png"></p>
<p>回车之后效果：<img src="/img%5Cdebug9.png"></p>
<p>调试界面效果：<img src="/img%5Cdebug0.png"></p>
</li>
<li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p>
<p><img src="/img%5Cdebug11.png"></p>
</li>
<li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p>
<p><img src="/img%5Cdebug12.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p>
<p><img src="/img%5Cdebug13.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p>
<p><img src="/img%5Cdebug14.png"></p>
</li>
<li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p>
<p><img src="/img%5Cdebug15.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p>
<p><img src="/img%5Cdebug16.png"></p>
</li>
<li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p>
<p><img src="/img%5Cdebug17.png"></p>
</li>
</ol>
<h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p>
<p><img src="/img%5C%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p>
<p>具体规则：</p>
<ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol>
<li>准备牌：</li>
</ol>
<p>完成数字与纸牌的映射关系：</p>
<p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li>洗牌：</li>
</ol>
<p>通过数字完成洗牌发牌</p>
<ol start="3">
<li>发牌：</li>
</ol>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li>看牌：</li>
</ol>
<p>通过Map集合找到对应字符展示。</p>
<p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
<p><img src="/img%5C%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p>
<h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1组装54张扑克牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.1 创建Map集合存储</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pokerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 1.2 创建 花色集合 与 数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 存储 花色 与数字</span></span><br><span class="line">        Collections.addAll(colors, <span class="string">&quot;♦&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        Collections.addAll(numbers, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 存储编号变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        pokerMap.put(count++, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        pokerMap.put(count++, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.4 创建牌 存储到map集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> color + number;</span><br><span class="line">                pokerMap.put(count++, card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2 将54张牌顺序打乱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 取出编号 集合</span></span><br><span class="line">        Set&lt;Integer&gt; numberSet = pokerMap.keySet();</span><br><span class="line">        <span class="comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span></span><br><span class="line">        ArrayList&lt;Integer&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        numberList.addAll(numberSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打乱顺序</span></span><br><span class="line">        Collections.shuffle(numberList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span></span><br><span class="line">        <span class="comment">// 3.1 发牌的编号</span></span><br><span class="line">        <span class="comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; noP1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipaiNo = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2发牌的编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取该编号</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">no</span> <span class="operator">=</span> numberList.get(i);</span><br><span class="line">            <span class="comment">// 发牌</span></span><br><span class="line">            <span class="comment">// 留出底牌</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipaiNo.add(no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    noP1.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    noP2.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    noP3.add(no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span></span><br><span class="line">        <span class="comment">// 4.1 对手中编号进行排序</span></span><br><span class="line">        Collections.sort(noP1);</span><br><span class="line">        Collections.sort(noP2);</span><br><span class="line">        Collections.sort(noP3);</span><br><span class="line">        Collections.sort(dipaiNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 进行牌面的转换</span></span><br><span class="line">        <span class="comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3转换</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP1) &#123;</span><br><span class="line">            <span class="comment">// 4.4 根据编号找到 牌面 pokerMap</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerMap.get(i);</span><br><span class="line">            <span class="comment">// 添加到对应的 牌面集合中</span></span><br><span class="line">            player1.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP2) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerMap.get(i);</span><br><span class="line">            player2.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP3) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerMap.get(i);</span><br><span class="line">            player3.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : dipaiNo) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">card</span> <span class="operator">=</span> pokerMap.get(i);</span><br><span class="line">            dipai.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.5 查看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;石破天：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;鸠摩智：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常、线程</title>
    <url>/posts/580b947d.html</url>
    <content><![CDATA[<h1 id="day05-【异常、线程】"><a href="#day05-【异常、线程】" class="headerlink" title="day05 【异常、线程】"></a>day05 【异常、线程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>异常、线程</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别程序中异常和错误的区别</li>
<li><input disabled="" type="checkbox"> 说出异常的分类</li>
<li><input disabled="" type="checkbox"> 说出虚拟机处理异常的方式</li>
<li><input disabled="" type="checkbox"> 列举出常见的三个运行期异常</li>
<li><input disabled="" type="checkbox"> 能够使用try…catch关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够使用throws关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够自定义异常类</li>
<li><input disabled="" type="checkbox"> 能够处理自定义异常类</li>
<li><input disabled="" type="checkbox"> 说出进程的概念</li>
<li><input disabled="" type="checkbox"> 说出线程的概念</li>
<li><input disabled="" type="checkbox"> 能够理解并发与并行的区别</li>
<li><input disabled="" type="checkbox"> 能够开启新线程</li>
</ul>
<h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="/img%5C%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<p><img src="/img%5C%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp"></p>
<h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img src="/img%5C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p>
<h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTools</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p> <img src="/img%5C%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p>
<h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1 	抛出异常throw"></a>2.1 	抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span>&#123; </span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          	<span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
<li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p>
</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<p><img src="/img%5C%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp"></p>
<h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RegisterException</span>(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="/img%5C%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程</strong></p>
<p><img src="/img%5C%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>线程</strong></p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li>设置线程的优先级</li>
</ul>
<p><img src="/img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" alt="设置线程优先级"></p>
<ul>
<li>抢占式调度详解</li>
</ul>
<p>  大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>  实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>  其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<p>  <img src="/img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" alt="抢占式调度"></p>
</li>
</ul>
<h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池、Lambda表达式</title>
    <url>/posts/d2b27c03.html</url>
    <content><![CDATA[<h1 id="day07【线程池、Lambda表达式】"><a href="#day07【线程池、Lambda表达式】" class="headerlink" title="day07【线程池、Lambda表达式】"></a>day07【线程池、Lambda表达式】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>等待与唤醒案例</li>
<li>线程池</li>
<li>Lambda表达式</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够理解线程通信概念<br>-[ ] 能够理解等待唤醒机制<br>-[ ] 能够描述Java中线程池运行原理<br>-[ ] 能够理解函数式编程相对于面向对象的优点<br>-[ ] 能够掌握Lambda表达式的标准格式<br>-[ ] 能够使用Lambda标准格式使用Runnable与Comparator接口<br>-[ ] 能够掌握Lambda表达式的省略格式与规则<br>-[ ] 能够使用Lambda省略格式使用Runnable与Comparator接口<br>-[ ] 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够明确Lambda的两项使用前提</p>
<h1 id="第一章-等待唤醒机制"><a href="#第一章-等待唤醒机制" class="headerlink" title="第一章 等待唤醒机制"></a>第一章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp"></p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait&#x2F;notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="literal">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="literal">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="literal">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZi</span> &#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChiHuo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChiHuo</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="literal">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZiPu</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="literal">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        <span class="type">BaoZi</span> <span class="variable">bz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZi</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ChiHuo</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChiHuo</span>(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        <span class="type">BaoZiPu</span> <span class="variable">bzp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZiPu</span>(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>

<h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p><img src="/img%5C%E6%B8%B8%E6%B3%B3%E6%B1%A0.jpg"></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
<h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp"></p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p><img src="/img/03-Overview.png"></p>
<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​	做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​	只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="comment">// 匿名内部类</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src="/img/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png"></p>
<p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p><img src="/img/02-Lambda.png"></p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LambdaRunnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03ThreadInitParam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04ThreadNameless</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Comparator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       		<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07ComparatorLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          	<span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08InvokeCalc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line">      	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>File类、递归</title>
    <url>/posts/cdb4f0f7.html</url>
    <content><![CDATA[<h1 id="day08【File类、递归】"><a href="#day08【File类、递归】" class="headerlink" title="day08【File类、递归】"></a>day08【File类、递归】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>File类</li>
<li>递归</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出File对象的创建方式</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取名称的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取绝对路径的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取文件大小的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件夹的方法名称</li>
<li><input disabled="" type="checkbox"> 能够辨别相对路径和绝对路径</li>
<li><input disabled="" type="checkbox"> 能够遍历文件夹</li>
<li><input disabled="" type="checkbox"> 能够解释递归的含义</li>
<li><input disabled="" type="checkbox"> 能够使用递归的方式计算5的阶乘</li>
<li><input disabled="" type="checkbox"> 能够说出使用递归会内存溢出隐患的原因</li>
</ul>
<h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul>
<li><p><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </p>
</li>
<li><p><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</p>
</li>
<li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </p>
</li>
<li><p>构造举例，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileIs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 文件?:<span class="literal">false</span></span><br><span class="line">d:\aaa 目录?:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul>
<li><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p>
</li>
<li><p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>递归分为两种，直接递归和间接递归。</li>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法,禁止递归</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01DiGui</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// a();</span></span><br><span class="line">		b(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment">	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo01DiGui</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//Demo01DiGui();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">	 * 4993</span></span><br><span class="line"><span class="comment">	 * 	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		b(++i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">	 * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a方法&quot;</span>);</span><br><span class="line">		a();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 &#x3D; num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      	<span class="comment">// 调用求和的方法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(num);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	   num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">      	   相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/img/day08_01_%E9%80%92%E5%BD%92%E7%B4%AF%E5%92%8C.jpg"></p>
<blockquote>
<p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p>
</blockquote>
<h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul>
<li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">  	<span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">      	<span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getValue(n);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘为:&quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  判断:</span></span><br><span class="line"><span class="comment">      	  当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">      	  当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    		<span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录:&quot;</span>+file.getAbsolutePath());</span><br><span class="line">              	<span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir2</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.java&quot;</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>



<h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir3</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">  	<span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	<span class="keyword">return</span> f.getName().endsWith(<span class="string">&quot;.java&quot;</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字节流、字符流</title>
    <url>/posts/39666f99.html</url>
    <content><![CDATA[<h1 id="day09【字节流、字符流】"><a href="#day09【字节流、字符流】" class="headerlink" title="day09【字节流、字符流】"></a>day09【字节流、字符流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>IO流</li>
<li>字节流</li>
<li>字符流</li>
<li>异常处理</li>
<li>Properties</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出IO流的分类和功能</li>
<li><input disabled="" type="checkbox"> 能够使用字节输出流写出数据到文件</li>
<li><input disabled="" type="checkbox"> 能够使用字节输入流读取数据到程序</li>
<li><input disabled="" type="checkbox"> 能够理解读取数据read(byte[])方法的原理</li>
<li><input disabled="" type="checkbox"> 能够使用字节流完成文件的复制</li>
<li><input disabled="" type="checkbox"> 能够使用FileWirter写数据到文件</li>
<li><input disabled="" type="checkbox"> 能够说出FileWriter中关闭和刷新方法的区别</li>
<li><input disabled="" type="checkbox"> 能够使用FileWriter写数据的5个方法</li>
<li><input disabled="" type="checkbox"> 能够使用FileWriter写数据实现换行和追加写</li>
<li><input disabled="" type="checkbox"> 能够使用FileReader读数据</li>
<li><input disabled="" type="checkbox"> 能够使用FileReader读数据一次一个字符数组</li>
<li><input disabled="" type="checkbox"> 能够使用Properties的load方法加载文件中配置信息</li>
</ul>
<h1 id="第一章-IO概述"><a href="#第一章-IO概述" class="headerlink" title="第一章 IO概述"></a>第一章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p>
<p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java中I&#x2F;O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h2 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h2><p><img src="/img/1_io.jpg"></p>
<h2 id="1-4-顶级父类们"><a href="#1-4-顶级父类们" class="headerlink" title="1.4 顶级父类们"></a>1.4 顶级父类们</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<br /><strong>InputStream</strong></td>
<td align="center">字节输出流<br /><strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<br /><strong>Reader</strong></td>
<td align="center">字符输出流<br /><strong>Writer</strong></td>
</tr>
</tbody></table>
<h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamConstructor</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;黑马程序员&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马程序员</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。</li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>，<span class="literal">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p>
<p>以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamConstructor</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/img/2_copy.jpg"></p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8</p>
</li>
<li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</li>
</ol>
</blockquote>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderConstructor</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FRRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑</span><br><span class="line">马</span><br><span class="line">程</span><br><span class="line">序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FRRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员序</span><br></pre></td></tr></table></figure>

<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。</li>
</ul>
<h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">char</span>[] chars = <span class="string">&quot;黑马程序员&quot;</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 黑马程序员</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//黑马程序员</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);	<span class="comment">// 程序</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>，<span class="literal">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">黑马</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleException1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">&#x27;;&#x27;</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleException2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">r1</span> <span class="operator">=</span> resource1;</span><br><span class="line">     <span class="type">Resource</span> <span class="variable">r2</span> <span class="operator">=</span> resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  <span class="type">FileReader</span> <span class="variable">fr</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li>
</ul>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure>

<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲流、转换流、序列化流</title>
    <url>/posts/9b6019cd.html</url>
    <content><![CDATA[<h1 id="day10【缓冲流、转换流、序列化流】"><a href="#day10【缓冲流、转换流、序列化流】" class="headerlink" title="day10【缓冲流、转换流、序列化流】"></a>day10【缓冲流、转换流、序列化流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>缓冲流</li>
<li>转换流</li>
<li>序列化流</li>
<li>打印流</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够使用字节缓冲流读取数据到程序</li>
<li><input disabled="" type="checkbox"> 能够使用字节缓冲流写出数据到文件</li>
<li><input disabled="" type="checkbox"> 能够明确字符缓冲流的作用和基本用法</li>
<li><input disabled="" type="checkbox"> 能够使用缓冲流的特殊功能</li>
<li><input disabled="" type="checkbox"> 能够阐述编码表的意义</li>
<li><input disabled="" type="checkbox"> 能够使用转换流读取指定编码的文本文件</li>
<li><input disabled="" type="checkbox"> 能够使用转换流写入指定编码的文本文件</li>
<li><input disabled="" type="checkbox"> 能够说出打印流的特点</li>
<li><input disabled="" type="checkbox"> 能够使用序列化流写出对象到文件</li>
<li><input disabled="" type="checkbox"> 能够使用反序列化流读取文件到程序中</li>
</ul>
<h1 id="第一章-缓冲流"><a href="#第一章-缓冲流" class="headerlink" title="第一章 缓冲流"></a>第一章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>);</span><br><span class="line">        	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">十几分钟过去了...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">	     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>
<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">			<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">		 <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  &#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;程序&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;员&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>

<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二章-转换流"><a href="#第二章-转换流" class="headerlink" title="第二章 转换流"></a>第二章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="/img/1_charset.jpg"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？ </p>
<h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\out.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">FileName2</span> <span class="operator">=</span> <span class="string">&quot;E:\\out2.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="/img/2_zhuanhuan.jpg"></p>
<h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;      </span><br><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">     	<span class="type">String</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="string">&quot;file_gbk.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="string">&quot;file_utf8.txt&quot;</span>;</span><br><span class="line">		<span class="comment">// 2.创建流对象</span></span><br><span class="line">    	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile));</span><br><span class="line">		<span class="comment">// 3.读写数据</span></span><br><span class="line">    	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-序列化"><a href="#第三章-序列化" class="headerlink" title="第三章 序列化"></a>第三章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="/img/3_xuliehua.jpg"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure>

<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">    	<span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializeDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">ois</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="第四章-打印流"><a href="#第四章-打印流" class="headerlink" title="第四章 打印流"></a>第四章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure>

<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/posts/f6491cfb.html</url>
    <content><![CDATA[<h1 id="day11【网络编程】"><a href="#day11【网络编程】" class="headerlink" title="day11【网络编程】"></a>day11【网络编程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>软件架构CS／BS</li>
<li>网络通信三要素</li>
<li>TCP通信</li>
<li>Socket套接字</li>
<li>ServerSocket</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别UDP和TCP协议特点</li>
<li><input disabled="" type="checkbox"> 能够说出TCP协议下两个常用类名称</li>
<li><input disabled="" type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下文件上传案例</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下案例2</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C&#x2F;S结构</strong> ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<p><img src="/img/1_cs.jpg"></p>
<p><strong>B&#x2F;S结构</strong> ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><img src="/img/2_bs.jpg"></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
</li>
<li><p><strong>TCP&#x2F;IP协议：</strong> 传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
</li>
</ul>
<p><img src="/img/3_tcp_ip.jpg"></p>
<p>上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
</li>
</ul>
<p><img src="/img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/4_tcp.jpg"></p>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。</li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。</li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg"></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="/img/6_upload.jpg">    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy.jpg&quot;</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUPload_Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span>   <span class="variable">bos</span>   <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="type">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传完毕 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="/img/6_upload2.jpg"></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;back ........&quot;</span>);</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="type">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] back = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="/img%5C%E5%A4%8D%E5%88%B6.png"></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">    	<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">   	    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg"></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="/img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg"></p>
</li>
</ol>
<p>GET&#x2F;web&#x2F;index.html HTTP&#x2F;1.1是浏览器的请求消息。&#x2F;web&#x2F;index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"><span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">        <span class="type">byte</span>[] bytes= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="/img/%E6%95%88%E6%9E%9C%E5%9B%BE1.png"></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Web</span>(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Web</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Web</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">readWb</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                        <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                <span class="type">String</span> <span class="variable">requst</span> <span class="operator">=</span> readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="type">byte</span>[] bytes= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img src="/img/%E6%95%88%E6%9E%9C%E5%9B%BE2.png">图解：</p>
<p><img src="/img%5CBS%E9%80%9A%E4%BF%A1.bmp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>页面给方法传参</title>
    <url>/posts/c8ea6d71.html</url>
    <content><![CDATA[<h2 id="１．页面给方法传参"><a href="#１．页面给方法传参" class="headerlink" title="１．页面给方法传参"></a>１．页面给方法传参</h2><table>
<thead>
<tr>
<th>1 2 3 4 5 6 7 8 9</th>
<th>&#x2F;&#x2F; data-   eg：let arr &#x3D; [1,2,3]     <view wx:for='arr' data-id='item' data-name='terry' data-user-name='kylin'>     </view>     getId(e){       e.currentTarget.dataset.id      &#x2F;&#x2F;1&#x2F;2&#x2F;3       e.currentTarget.dataset.name     &#x2F;&#x2F;terry       e.currentTarget.dataset.userName   &#x2F;&#x2F;kylin     }</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="２．输入框给方法传参"><a href="#２．输入框给方法传参" class="headerlink" title="２．输入框给方法传参"></a>２．输入框给方法传参</h2><table>
<thead>
<tr>
<th></th>
<th><input type='text' bindtap='Handle'>     Handle(e){       let id &#x3D; e.detail.value   }</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="３．页面之间的传参"><a href="#３．页面之间的传参" class="headerlink" title="３．页面之间的传参"></a>３．页面之间的传参</h2><table>
<thead>
<tr>
<th></th>
<th>原页面     navigateTo({       url:’路径?id&#x3D;’+id+’&amp;userName&#x3D;’+userName     })     如果传的参数是数组或者对象，那么都会被强制解析成字符串     序列化   JSON.stringfy()     反序列化  JSON.parse()   被跳转页面     onLoad:function(option){       &#x2F;&#x2F;option是一个对象，里面存放的就是上一个页面传过来的参数       console.log(option);   &#x2F;&#x2F;{id: “10”, userName: “kylin”}     }</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>学校笔记</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
